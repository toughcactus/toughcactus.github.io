[{"id":0,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/","title":"虚幻引擎","section":"Docs","content":""},{"id":1,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.1%E5%9C%A8%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8CShooterGame%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE/","title":"运行ShooterGame示例项目","section":"角色和动画","content":" 下载ShooterGame # Epic Games Launcher \u0026gt; Samples \u0026gt; Shooter Game 支持引擎版本 4.0 - 4.27 ，当前使用引擎版本 5.1.1 需要修改的地方 # UMatineeCameraShake 已被 ULegacyCameraShake 替代 PLATFORM_PS4 一个不合适的改法是在引擎代码中，紧接着 SWITCH 定义该宏 另一个麻烦但更合理的改法是，屏蔽该宏的出现 Source/ShooterGame/Private/Player/ShhoterCharacter.cpp:322 参考 条件运算符的第二个和第三个操作数如果类型不一致，存在转换 AController * 和 AActor * 可以相互转换，此处有歧义2 运行效果 # "},{"id":2,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.2%E5%88%9D%E5%A7%8B%E5%8C%96ShootTraining%E9%A1%B9%E7%9B%AE/","title":"初始化ShootTraining项目","section":"角色和动画","content":"虚幻编辑器 Overview # 将ShooterGame作为内容包，基于此开发ShootTraining 如有室内设计师提供游戏资料，我们基于此开发游戏 一、创建ShootTraining项目 # Blank Blueprint 二、配置ShootTraining # 添加Copyright 项目设置 \u0026gt; Project \u0026gt; Description \u0026gt; Legal \u0026gt; Copyright Notice Shoot Training Game, All Rights Reserved. 关卡设置 添加关卡文件夹 Content/Levels 创建关卡 Content/Levels/DefaultMap Basic 设置EditorStartupMap和GameDefaultMap为DefaultMap 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 不使用预编译头文件 ShootTraining.Build.cs // PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PCHUsage = PCHUsageMode.NoPCHs; 添加外部资产文件夹 Content/ExternalContent 三、从ShooterGame导入资产 # 打开ShooterGame项目，在内容浏览器选中 Content/Animations/TTP_Animations 右键 \u0026gt; Migrate 取消Sounds勾选 通过虚幻编辑器，将 Content 目录下的 Animations Characters Environment 移动到 ExternalContent 目录下 不能直接迁移到 ExternalContent ，虚幻引擎会检查目录，要求这些资产的上级目录是 Content ，即使根目录是 Content 也无法通过检查 不能直接将三个文件夹移动到 ExternalContent 中，会导致资产之间的相互引用路径出错 Animations Characters Environment 三个文件夹里的内容都与 TTP_Animations 相关 打开ShootTraining项目，为 ExternalContent 设置文件夹颜色 选中Content/ExternalContent \u0026gt; 右键 效果图 外部资产结构 四、基于蓝图创建C++项目 # 添加C++类即可 创建蓝图项目的时间开销明显小于创建C++项目的时间开销 1. 创建 GameModeBase # STGameModeBase 不设置类类型 Content同级目录出现C++ Classes文件夹 2. 设置关卡使用 STGameModeBase # 五、脚本 # 编辑项目 build.sh #!/bin/bash BuildScript=\u0026#34;EpicGames/UE_5.1/Engine/Build/BatchFiles/Mac/Build.sh\u0026#34; ProjectName=\u0026#34;ShootTraining\u0026#34; Project=\u0026#34;Projects/5.1.1/\u0026#34;$ProjectName\u0026#34;/\u0026#34;$ProjectName\u0026#34;.uproject\u0026#34; Target=$ProjectName\u0026#34;Editor\u0026#34; $BuildScript $Target Mac Development \u0026#34;$Project\u0026#34; -waitmutex -NoHotReload 打开虚幻编辑器 open_editor.sh #!/bin/bash UnrealEditor=\u0026#34;EpicGames/UE_5.1/Engine/Binaries/Mac/UnrealEditor.app\u0026#34; ProjectName=\u0026#34;ShootTraining\u0026#34; Project=\u0026#34;Projects/5.1.1/\u0026#34;$ProjectName\u0026#34;/\u0026#34;$ProjectName\u0026#34;.uproject\u0026#34; open $Project 生成项目文件 generate_project_files.sh #!/bin/bash GenerateProjectFilesScript=\u0026#34;EpicGames/UE_5.1/Engine/Build/BatchFiles/Mac/GenerateProjectFiles.sh\u0026#34; ProjectName=\u0026#34;ShootTraining\u0026#34; Project=\u0026#34;Projects/5.1.1/\u0026#34;$ProjectName\u0026#34;/\u0026#34;$ProjectName\u0026#34;.uproject\u0026#34; $GenerateProjectFilesScript -projectfiles -project=$Project -game -rocket -progress -VSCode # $GenerateProjectFilesScript -projectfiles -project=$Project -game -rocket -progress -XCodeProjectFiles EngineCCDst=\u0026#34;EpicGames/UE_5.1/compile_commands.json\u0026#34; EngineCCSrc=\u0026#34;EpicGames/UE_5.1/.vscode/compileCommands_Default.json\u0026#34; ProjectCCDst=\u0026#34;Projects/5.1.1/\u0026#34;$ProjectName\u0026#34;/compile_commands.json\u0026#34; ProjectCCSrc=\u0026#34;Projects/5.1.1/\u0026#34;$ProjectName\u0026#34;/.vscode/compileCommands_\u0026#34;$ProjectName\u0026#34;.json\u0026#34; cp $EngineCCSrc $EngineCCDst cp $ProjectCCSrc $ProjectCCDst 六、查看项目源码中的版权信息 # "},{"id":3,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.3%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","title":"代码规范","section":"角色和动画","content":" Overview # .clang-format .gitignore 按个人习惯来，非建议 参考 大括号 放在新行 缩进 虚幻引擎建议使用制表符，也可以使用空格 一、定义格式化代码规则 # .clang-format YAML标记文件 参考 作为项目的一部分，描述管理代码文件的统一格式 每行遵循格式 key: value 1. 设置受约束的开发语言 # 如果项目中只一种开发语言，或者所有开发语言使用相同规范，可忽略该配置 Language: Cpp 2. 通用样式 # Google 一个制表符对应2个空格，大括号不在新行 BasedOnStyle: Google Microsoft 一个制表符对应4个空格，大括号在新行 BasedOnStyle: Microsoft 3. 缩进宽度 # IndentWidth: \u0026#39;4\u0026#39; 4. 缩进样式 # 空格 UseTab: Never 制表符 源文件中既有空格又有制表符 UseTab: Always 5. 制表符宽度 # 每6个空格替换一个制表符，若缩进使用制表符，效果很糟糕 TabWidth: \u0026#39;6\u0026#39; 6. 设置大括号位置 # 行尾 BreakBeforeBraces: Attach 新行 BreakBeforeBraces: Allman 7. 其他设置 # ColumnLimit: \u0026#39;140\u0026#39; AccessModifierOffset: \u0026#39;-4\u0026#39; SortIncludes: false AllowShortBlocksOnASingleLine: false AlignAfterOpenBracket: DontAlign AllowShortFunctionsOnASingleLine: Inline PointerAlignment: Left 二、Git仓库同步 # .gitignore 参考 告诉Git，同步时忽略的文件和文件夹 三、命名约定 # 虚幻编辑器 参考 虚幻编辑器 首 材质 M_ 材质实例 MI_ 基于C++的蓝图类 BP_ 动画蓝图 ABP_ 混合空间 BS_ "},{"id":4,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.4%E4%B8%BACharacter%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%9E%8B/","title":"为Character绑定模型","section":"角色和动画","content":" Part 1 创建 Character 和 PlayController # 虚幻编辑器 一、创建 Player/STBaseCharacter # ACharacter 公有类 二、创建 Player/STPlayerController # APlayerController 公有类 Part 2 使用 Character 和 PlayController # C++ 一、查看头文件包含路径 # 源文件路径中有指明上级文件夹 Player 设置头文件搜索路径，之后可以不指明上级文件夹 ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026#34;ShootTraining/Public/Player\u0026#34; }); 二、使用 STBaseCharacter 和 STPlayerController # STGameModeBase 包含头文件 源文件 #include \u0026#34;STBaseCharacter.h\u0026#34; #include \u0026#34;STPlayerController.h\u0026#34; 设置使用类 函数成员 private 在默认构造函数中调用 void ASTGameModeBase::InitCharacterAndPlayerController() { DefaultPawnClass = ASTBaseCharacter::StaticClass(); PlayerControllerClass = ASTPlayerController::StaticClass(); } 实现默认构造函数 public ASTGameModeBase::ASTGameModeBase() { InitCharacterAndPlayerController(); } 三、添加 Camera 组件 # STBaseCharacter 前向声明 头文件 class UCameraComponent; 包含头文件 源文件 #include \u0026#34;Camera/CameraComponent.h\u0026#34; 添加 Camera 组件 数据成员 protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \u0026#34;Components\u0026#34;) UCameraComponent *Camera; 初始化 Camera 组件 函数成员 private 在构造函数中调用 void ASTBaseCharacter::InitCameraComponent() { Camera = CreateDefaultSubobject\u0026lt;UCameraComponent\u0026gt;(\u0026#34;CameraComponent\u0026#34;); Camera-\u0026gt;SetupAttachment(GetRootComponent()); } Part 3 创建蓝图类 # 虚幻编辑器 一、查看 STGameModeBase 设置 # 二、创建 Content/Player/BP_STGameModeBase # 三、创建 Content/Player/BP_STBaseCharacter 和 Content/Player/BP_STPlayerController # 四、设置 BP_STGameModeBase # Part 4 绑定模型 # 虚幻编辑器 BP_STBaseCharacter 一、查看组件信息 # Capsule 组件 根组件 Arrow 组件 角色的前进方向 Camera 组件 C++ Mesh 组件 骨骼网格体(Skeletal Mesh) Character Movement 组件 纯逻辑 二、为Mesh组件绑定骨骼网格体 # Mesh 绑定 HeroTPP 材质自动应用 HeroTPP 移动到合适位置，旋转模型与前进方向一致 三、实现第三视角 # 分离 Camera 组件和 Mesh 组件 运行效果图 "},{"id":5,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.5%E5%AE%9E%E7%8E%B0Character%E5%89%8D%E5%90%8E%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8/","title":"实现Character前后左右移动","section":"角色和动画","content":" Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 1. 轴映射 # 连续 如 前后左右移动 2. 动作映射 # 离散 如 跳跃，装弹，更换武器 Part 2 实现前后左右移动逻辑 # C++ STBaseCharacter 1. 添加头文件 # 源文件 #include \u0026#34;Components/InputComponent.h\u0026#34; 2. 实现回调函数 # 函数成员 private void ASTBaseCharacter::MoveForward(float Amount) { AddMovementInput(GetActorForwardVector(), Amount); } void ASTBaseCharacter::MoveRight(float Amount) { AddMovementInput(GetActorRightVector(), Amount); } 3. 绑定函数描述和回调函数 # 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::BindMoveHandler(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAxis(\u0026#34;MoveForward\u0026#34;, this, \u0026amp;ASTBaseCharacter::MoveForward); PlayerInputComponent-\u0026gt;BindAxis(\u0026#34;MoveRight\u0026#34;, this, \u0026amp;ASTBaseCharacter::MoveRight); } "},{"id":6,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.6%E5%AE%9E%E7%8E%B0Character%E8%A7%86%E8%A7%92%E6%97%8B%E8%BD%AC/","title":"实现Character视角旋转","section":"角色和动画","content":" Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 1. 抬头，低头 # 鼠标垂直方向的移动决定抬头角度，绕Y轴旋转 函数描述 LookUp 键位 MouseY 2. 环顾四周 # 鼠标水平方向的移动决定身体旋转角度，绕Z轴旋转 函数描述 TurnAround 键位 MouseX Part 2 实现视角旋转逻辑1 # C++ 一、搭建框架 # 添加空函数并绑定函数描述和回调函数，之后再实现函数逻辑 函数成员 函数体为空 private void LookUp(float Amount); void TurnAround(float Amount); 绑定函数描述和回调函数 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::InitCameraRotate(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAxis(\u0026#34;LookUp\u0026#34;, this, \u0026amp;ASTBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026#34;TurnAround\u0026#34;, this, \u0026amp;ASTBaseCharacter::TurnAround); } 二、添加静态日志类型 # DEFINE_LOG_CATEGORY_STATIC(LogBaseCharacter, All, All) 三、实现回调函数 # void ASTBaseCharacter::LookUp(float Amount) { AddControllerPitchInput(Amount); UE_LOG(LogBaseCharacter, Log, TEXT(\u0026#34;LookUp Amount: %f\u0026#34;), Amount); } void ASTBaseCharacter::TurnAround(float Amount) { AddControllerYawInput(Amount); } Part 3 配置 Camera 组件在垂直方向上移动 # 虚幻编辑器 水平移动鼠标时，Character和摄像机一齐左右旋转 垂直移动鼠标时，Character无旋转 一、使 Camera 组件 跟随 Pawn 旋转 # BP_STBaseCharacter 选中Camera组件 \u0026gt; 细节面板 \u0026gt; CameraOptions \u0026gt; 使能UsePawnControlRotation 保存并编译 此时向下移动鼠标时，摄像机向上旋转，向上移动鼠标时，摄像机向下旋转 查看日志，鼠标向上移动时，Amount的确是正数 二、调试 InputPitchScale # BP_PlayerController 参考 引擎版本 5.1 之前，可以在 PlayerController蓝图类 的 细节面板 查看 InputPitchScale 打印 InputPitchScale 为负数，解释向上移动鼠标， Camera组件 向下旋转 尝试设置 InputPitchScale 为正数，向上移动鼠标， Camera 组件向上旋转 去除 BP_STPlayerController 中的打印和设置 去除 C++ 中 LookUp 中的日志打印 InputPitchScale InputYawScale InputRollScale 的绝对值对应旋转速度 三、将 LookUp 的 Scale 改为-1 # 此时，向上移动鼠标， Camera 组件向上旋转 可以注意到，垂直方向移动鼠标时，旋转的中心点是 Camera 组件 Part 4 添加 SpringArm 组件 # C++ STBaseCharacter 1. 前向声明 # 头文件 class USpringArmComponent; 2. 包含头文件 # 源文件 #include \u0026#34;GameFrameWork/SpringArmComponent.h\u0026#34; 3. 添加 SpringArm 组件 # 数据成员 protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \u0026#34;Components\u0026#34;) USpringArmComponent *SpringArm; 4. 初始化 SpringArm 组件 # 函数成员 private 在默认构造函数中调用 设置原型默认值 void ASTBaseCharacter::InitSpringArmAndCamera() { SpringArm = CreateDefaultSubobject\u0026lt;USpringArmComponent\u0026gt;(\u0026#34;SpringArmComponent\u0026#34;); SpringArm-\u0026gt;SetupAttachment(GetRootComponent());\tSpringArm-\u0026gt;bUsePawnControlRotation = true; Camera = CreateDefaultSubobject\u0026lt;UCameraComponent\u0026gt;(\u0026#34;CameraComponent\u0026#34;); Camera-\u0026gt;SetupAttachment(SpringArm); Camera-\u0026gt;bUsePawnControlRotation = false; } 不再在默认构造函数中调用InitCameraComponent Part 5 配置 SpringArm 组件 # 虚幻编辑器 BP_STBaseCharacter 一、查看 SpringArm 组件 # 二、关于 bUsePawnControlRotation # UCameraComponent 和 USpringArmComponent 均有该数据成员 在代码中设置 bUsePawnControlRotation ，设置的是原型数据成员初始值 在蓝图编辑器中，对基于C++类的蓝图类数据成员恢复默认值，得到原型中给出的初始值 已设置不会恢复默认值 当前， BP_BaseCharacter 中， SpringArm 组件的 bUsePawnControlRotation 使用默认值，而 Camera 组件的 bUsePawnControlRotation 仍使用我们之前设置的值 三、设置 SpringArm 组件和 Camera 组件的相对变换 # 清除 Camera 组件的相对变换 设置 SpringArm 组件 臂长 偏移 四、 Camera 组件和 SpringArm 组件的 bUsePawnControlRotation 生效问题 # 二者均为 true 时， SpringArm 组件的生效， Camera 组件以 Character 为中心绕Y轴旋转 二者均为 false ， Camera 组件不可绕Y轴旋转 仅 Camera 组件的为true，摄像机以 Camera 组件为中心绕Y轴旋转 去除 Camera 组件的 bUsePawnControlRotation 使能 Part 6 为 Character 绑定动画 # 虚幻编辑器 BP_STBaseCharacter 一、绑定动画 # 选中Mesh组件 \u0026gt; Details \u0026gt; Animation 设置AnimationMode为UseAnimationAsset 设置为AnimToPlay为Run_Fwd 编译并保存 二、效果图 # Part 7 实现视角旋转逻辑2 # C++ 一、比对 LookUp TurnAround AddControllerPitchInput 和 AddControllerYawInput # 函数签名一致 void ASTBaseCharacter::LookUp(float Amount) { AddControllerPitchInput(Amount); //\tUE_LOG(LogBaseCharacter, Log, TEXT(\u0026#34;LookUp Amount: %f\u0026#34;), Amount); } void ASTBaseCharacter::TurnAround(float Amount) { AddControllerYawInput(Amount); } void ASTBaseCharacter::InitCameraRotate(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAxis(\u0026#34;Lookup\u0026#34;, this, \u0026amp;ASTBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026#34;TurnAround\u0026#34;, this, \u0026amp;ASTBaseCharacter::TurnAround); } 二、函数描述直接绑定 AddControllerPitchInput 和 AddControllerYawInput # 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::InitCameraRotateFinal(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAxis(\u0026#34;Lookup\u0026#34;, this, \u0026amp;ASTBaseCharacter::AddControllerPitchInput); PlayerInputComponent-\u0026gt;BindAxis(\u0026#34;TurnAround\u0026#34;, this, \u0026amp;ASTBaseCharacter::AddControllerYawInput); } 不再在SetupPlayerInputComponent中调用InitCameraRotate "},{"id":7,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.7%E6%B7%BB%E5%8A%A0%E5%90%91%E5%89%8D%E8%B7%91%E6%AD%A5%E5%8A%A8%E7%94%BB/","title":"为Character添加跑步动画","section":"角色和动画","content":"虚幻编辑器 Overview # 动画随着Character运动速度变化 brush 是最简单的可编辑几何体，我们可以修改其顶点位置，调整其他参数，然后将其转换成静态网格体 CharacterMovement 组件负责 Character 运动，其各种属性均和 Character 运动有关 一、重新设置平台 # 从场景中移除Floor 添加 Geometry/Box 恢复默认位置，设置 brush 长宽高 二、Character运动速度上限 # BP_STBaseCharacter CharacterMovement组件 选择CharacterMovement组件 \u0026gt; 细节面板 \u0026gt; Character Movement: Walking \u0026gt; MaxWalkSpeed Character 的最大运动速度 单位 cm/s 虚幻引擎里的步长使用 cm 修改 MaxWalkSpeed ，当速度改为 1600 时，可以看到单位时间内移动的距离增加，而跑步动画没有加速过程 三、打印实时速度 # BP_STBaseCharacter EventGraph 获得Character速度 GetVelocity函数 获得Actor各个方向上的速度，保存在FVector中 获得速度标量 FVector::VectorLength 在屏幕上输出实时速度 PrintString 使用 AddOnScreenDebugMessage 移除打印 四、创建动画蓝图 # Animation Blueprint 动画蓝图和 Skeleton Mesh 有关 创建文件夹 Content/Players/Animations 动画蓝图命名 ABP_打头 方法一 基于 Skeleton Mesh 创建动画蓝图 # 选中ExternalContent/Characters/HeroTPP/HeroTPP \u0026gt; 右键 \u0026gt; Create \u0026gt; AnimBlueprint 方法二 在指定位置创建动画蓝图 # 去到 Content/Player/Animations \u0026gt; 右键 \u0026gt; Animation \u0026gt; 选择Animation Blueprint 选择 HeroTPP_Skeleton ，命名为 ABP_BaseCharacter 五、在蓝图编辑器中查看动画蓝图 # ABP_BaseCharacter 1. 事件图表 # EventGraph 处理各种动画事件 像使用 Tick 一样使用 EventBlueprintUpdateAnimation 2. 动画图表 # AnimGraph 处理所有动画 可以将动画作为 OutputPose 的输入 将 Run_Fwd 作为 OutputPose 的输入 设置 Run_Fwd 重复播放 选中Run_Fwd \u0026gt; Details \u0026gt; Settings \u0026gt; 使能 LoopAnimation 3. 动画资产窗口 # AssetBrowser 可以从 Window \u0026gt; AssetBrowser 打开 罗列了 SkeletonMesh 所有相关动画 六、让Character使用动画蓝图 # BP_STBaseCharacter ABP_BaseCharacter 之前 AnimationMode 的设置是 UseAnimationAsset ，而后选择 Run_Fwd 设置 AnimationMode 为 UseAnimationBlueprint BP_STBaseCharacter \u0026gt; Details \u0026gt; Animation \u0026gt; AnimationMode，选择 UseAnimationBlueprint 使用 ABP_BaseCharacter Animation \u0026gt; AnimClass，选择ABP_BaseCharacter 七、查看动画资产 # Run_Fwd 去到Content/ExternalContent/Animations/TTP_Animations 双击 Run_Fwd 可在 AssetBrowser 中选择其他动画 八、创建 混合空间 资产 # Blend Space 目标是，速度从 0 - 600 ，动画从 Idle 过渡到 Run_Fwd 动画混合 Animation Blend 流畅地从一个动画切入到另一个动画 混合空间 能在两个骨骼动画之间创建过渡动画 使用插值来得到动画姿势的中间值 和 Skeleton Mesh 有关 一维混合空间 Blend Space 1D 命名 混合空间 和 1D混合空间 均以BS_打头 1. 创建 BS_Locomotion # 去到Content/Player/Animations \u0026gt; 右键 选择 HeroTPP_Skeleton ，命名为 BS_Locomotion 2. 配置 BS_Locomotion # 双击打开 BS_Locomotion 配置轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis 设置名字 Name 设置为 Velocity 设置轴最大值 Maximum Axis Value 设置为 600 过渡区间 Grid Divisions 和可以添加的动画个数有关 配置动画 起点 Idle 终点 Run_Fwd 查看插值 Windows 按下 Control 键 MacOS 按下 Command 键 水平移动鼠标，绿色X随之在起点和终点间移动，视口展示过渡动画 九、将混合空间作为动画蓝图输入 # ABP_BaseCharacter BS_Locomotion 1. 获取实时速度 velocity # 事件图表 EventGraph 添加变量 Velocity Float 在细节面板进行设置 在 事件图表 中使用变量 Velocity ，选择设置变量值 在 EventBlueprintUpdateAnimation 之后，执行 SetVelocity 变量 Velocity 的输入是 Actor 实时速度 使用 GetPawnOwner 获得 Pawn 实例的引用 2. 设置动画蓝图输入 # 动画图表 AnimGraph 将BS_Locomotion作为OutputPose的输入，并将变量Velocity作为BS_Locomotion的输入 将 BS_Locomotion 设做 OutputPose 输入 在 动画图表 中使用变量 Velocity ，此处只能获取变量值，我们要的就是获取变量值 将变量 Velocity 作为 BS_Locomotion 的输入 "},{"id":8,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.8%E5%AE%9E%E7%8E%B0Character%E8%B7%B3%E8%B7%83/","title":"实现Character跳跃","section":"角色和动画","content":" Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 Jump 键位 SpaceBar Part 2 实现跳跃逻辑 # C++ 使用虚幻引擎提供的跳跃回调函数 绑定函数描述和回调函数 # 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::InitJump(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAction(\u0026#34;Jump\u0026#34;, IE_Pressed, this, \u0026amp;ASTBaseCharacter::Jump); } Part 3 添加跳跃动画 # 虚幻编辑器 ABP_BaseCharacter 跳跃动画 JumpStart JumpLoop JumpEnd 跳跃动画切换条件 变量 IsFalling 使用 ACharacter::IsFalling 来设置 true则Character在空中，false则说明Character在地面上 上一小节中，变量 Velocity 横跨 ABP_BaseCharacter 的 EventGraph 和 AnimGraph ，这里，布尔类型变量 IsFalling 也一样 在 EventGraph 设置变量值，在 AnimGraph 中使用变量 使用状态机 在一个动画蓝图中管理多个动画，并定义动画之间的转换条件 一、设置布尔型变量 IsFalling # EventGraph ACharacter::IsFalling 需要 Pawn 到 Character 的转换 不能同时从 EventBlueprintUpdateAnimation 出发 SetVelocity 之后，执行转换 输入是 Character 的 MovementComponent ，从 AsCharacter 到 Target ，自动添加提取数据成员 IsFalling 函数的返回类型是布尔，作为 SetIsFalling 的输入 完整 EventGraph 二、实现 状态机 # AnimGraph 添加 状态机 ，命名为 Locomotion ，作为 OutputPose 的输入 StateMechine 双击 Locomotion ，进入 状态机 仅一个入口 Entry 为 Entry 添加 State ，命名为 Walk 双击 Walk 为 Walk 设置输入动画 BS_Locomotion 即之前 AnimGraph 中， OutputPose 的输入 到此， Character 的运动动画和上一小节一致 直接从 AssetBrowser 把 Jump 的三个动画拖入 Locomotion 动画自动被封装为 State ，和之前 AddState ，再将动画作为输入达到的效果一样 添加状态转换路径 添加转换条件 双击转换图标 Walk \u0026gt; JumpStart IsFalling 为 true JumpStart \u0026gt; JumpLoop JumpStart 将近结束 JumpStart 只播放一次 JumpLoop \u0026gt; JumpEnd IsFalling 为 false JumpLoop 循环播放 JumpEnd \u0026gt; Walk JumpEnd 将近结束 JumpEnd 只播放一次 三、设置 State 输入动画 # 拿 JumpStart 状态举例 选中JumpStart动画 \u0026gt; Details \u0026gt; Settings \u0026gt; LoopAnimation 默认循环播放动画 设置 JumpStart JumpEnd JumpLoop 的 LoopAnimation Jump 动画 设计时， JumpStart 和 JumpEnd 只播放一次， JumpLoop 可循环 如此设置可以修复Character跳跃时的卡顿 四、添加楼梯，查看 Jump 三阶段是否正常显示 # 添加楼梯 PlaceActors \u0026gt; Geometry \u0026gt; LinearStair 设置阶数 选中LinearStairBrush \u0026gt; Details \u0026gt; BrushSettings \u0026gt; NumSteps Character 从楼梯跳到平面时，一直保持 JumpLoop 五、跑步时跳跃，落地平滑 # 可以减少 JumpEnd \u0026gt; Walk 的 TimeRemaining 来缩短平滑 六、跳跃高度 # BP_STBaseCharacter JumpZVelocity 和 JumpStart 的时长有关 JumpLoop 动画更适合从临界点落下 "},{"id":9,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.9%E5%AE%9E%E7%8E%B0Character%E8%B7%91%E6%AD%A5/","title":"实现Character跑步","section":"角色和动画","content":" Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 Run 键位 LeftShift 虽然是跑步键位，但是限制方向为向前 要求同时按下 W 或 Up 要求速度不为0 前方有障碍物时，不应该由走路转换成跑步动画 动作映射的回调函数参数列表为空 判断是否为前进方向时，还可根据速度矢量和朝向的夹角 Part 2 实现跑步逻辑 # C++ 一、判断跑步键位是否按下，方向是否为前进 # 数据成员 private bool IsForward = false; bool AbleRun = false; 二、实现键位按下逻辑，绑定函数描述和回调函数 # 函数成员 private 在SetupPlayerInputComponent中调用InitRun void ASTBaseCharacter::RunEnable() { AbleRun = true; } void ASTBaseCharacter::RunDisable() { AbleRun = false; } void ASTBaseCharacter::InitRun(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAction(\u0026#34;Run\u0026#34;, IE_Pressed, this, \u0026amp;ASTBaseCharacter::RunEnable); PlayerInputComponent-\u0026gt;BindAction(\u0026#34;Run\u0026#34;, IE_Released, this, \u0026amp;ASTBaseCharacter::RunDisable);\t} 三、判断方向是否为前进 # 函数成员 private 在MoveForward中调用 void ASTBaseCharacter::SetIsForward(float Amount) { IsForward = Amount \u0026gt; 0.0f; } 四、判断当前是否满足跑步条件 # 函数成员 public 供其他类使用 跑步加速 const函数 可在蓝图中调用 UFUNCTION(BlueprintCallable) bool IsRunning() const; bool ASTBaseCharacter::IsRunning() const { return AbleRun \u0026amp;\u0026amp; IsForward \u0026amp;\u0026amp; !GetVelocity().IsZero(); } Part 3 添加跑步动画 # 虚幻编辑器 一、实现跑步动画 # 一维混合空间 BS_Run 设置轴 Name Velocity MaxinumAxisValue 600 设置动画 起点 Idle 终点 RoadieRun_Fwd 二、修改 状态机 # ABP_STBaseCharacter 1. 添加变量 IsRunning 用作状态迁移条件 # EventGraph 使用 STBaseCharacter::IsRunning 需要 Pawn 到 STBaseCharacter 的转换 设置变量 IsRunning 完整 EventGraph 可以合并 Pawn 到 Character 和 STBaseCharacter 的转换 2. 添加转向动画 # AnimGraph 添加状态 Run ，使用 BS_Run 作为输入 BS_Run 的输入为 Velocity 当 IsRunning 为 true 时，从 Walk 迁移到 Run ，否则，从 Run 迁移到 Walk Run 和 Jump 的转换 初稿 第二稿 从 JumpEnd 回到 Walk 时，如果 IsRunning 为 true ，会立即切换到 Run 可以省略 JumpEnd 到 Run 的转换，降低状态机复杂度 3. 复用转换条件 # AnimGraph Run 到 JumpStart 的转换复用 Walk 到 JumpStart 的转换条件 选中Walk到JumpStart的条件 \u0026gt; Details \u0026gt; Transiton \u0026gt; Transition Rule Sharing \u0026gt; Promote To Share 命名为 IsFalling 共享条件显示为红色 选中Run到JumpStart的条件 \u0026gt; Details \u0026gt; Transition \u0026gt; Transition Rule Sharing \u0026gt; Use Shared \u0026gt; 选择IsFalling 完整状态机 三、成果 # 运行游戏，跑步动画正常切换，但跑步和走路的速度一样 下一步，实现跑步时提升速度 Part 4 创建 Components/STCharacterMovementComponent # 虚幻编辑器 CharacterMovementComponent 公有类 Part 5 实现跑步加速 # C++ 1. 添加头文件路径 # ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026#34;ShootTraining/Public/Player\u0026#34;, \u0026#34;ShootTraining/Public/Components\u0026#34; }); 2. 可配置 加速系数 # STCharacterMovementComponent 数据成员 public 原型可修改 范围 1.5 - 10 UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026#34;1.5\u0026#34;, ClampMax = \u0026#34;10.0\u0026#34;)) float SpeedAcceleration = 2.0f; 3. 当 Character 跑步时，增加最大速度 # STCharacterMovementComponent 使用 STBaseCharacter::IsRunning 判断当前是否满足跑步条件 包含头文件 源文件 #include \u0026#34;Player/STBaseCharacter.h\u0026#34; 覆写 UCharacterMovementComponent::GetMaxSpeed 当 Character 满足跑步条件时，增加最大速度 并不直接修改 MaxWalkSpeed 某个地方会调用 GetMaxSpeed 来确定 Character 运动速度的上限，当获取的 MaxSpeed 增加，速度增加的幅度也变大，用以实现加速 float USTCharacterMovementComponent::GetMaxSpeed() const { const float MaxSpeed = Super::GetMaxSpeed(); ASTBaseCharacter *Player = Cast\u0026lt;ASTBaseCharacter\u0026gt;(GetPawnOwner()); return Player \u0026amp;\u0026amp; Player-\u0026gt;IsRunning() ? SpeedAcceleration * MaxSpeed : MaxSpeed; } 4. Character 使用自定义 CharacterMovementComponent # STBaseCharacter 包含头文件 源文件 #include \u0026#34;Components/STCharacterMovementComponent.h\u0026#34; 屏蔽默认构造函数 重新实现构造函数 自定义组件类型 ASTBaseCharacter::ASTBaseCharacter(const FObjectInitializer \u0026amp;ObjInit) : Super(ObjInit.SetDefaultSubobjectClass\u0026lt;USTCharacterMovementComponent\u0026gt;(ACharacter::CharacterMovementComponentName)) { // Set this character to call Tick() every frame. You can turn this off to improve performance if you don\u0026#39;t need it. PrimaryActorTick.bCanEverTick = true; // InitCameraComponent(); InitSpringArmAndCamera(); } "},{"id":10,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/","title":"基础课程","section":"虚幻引擎","content":""},{"id":11,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/","title":"角色和动画","section":"进阶课程","content":""},{"id":12,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.a%E6%B7%BB%E5%8A%A0%E8%BD%AC%E5%90%91%E5%8A%A8%E7%94%BB/","title":"添加转向动画","section":"角色和动画","content":" Overview # 当前实现了3种动作，走路，跑步和跳跃 走路这块，从静止到跑起来支持加速，使用 BS_Locomotion 本小节会重新实现走路动画，根据速度方向，加载转向和后退动画 之后还有 装弹 Reloading 、死亡 Death 、瞄准 Aiming 动画 Blend Space 2D混合空间 # 两个轴 Vertial Axis Horizontal Axis Part 1 建模 # 一、 ForwardVector 和 RightVector # Actor 有 ForwardVector 和 RightVector ， Character 前后左右移动有使用到这两个方向向量 若我们水平移动鼠标， ForwardVector 和 RightVector 随之发生改变 在视觉上， ForwardVector 一直向前， RightVector 一直向右，二者在水平面垂直 二、数学基础 # 1. 点乘 # 计算向量夹角 其中一个向量为 0向量 时，点乘结果为 0 ，而反余弦计算得到其夹角为 PI/2 2. 叉乘 # 用来将向量夹角从[0, PI]扩充到[-PI, PI] c.z 向量c的z坐标 其符号说明向量c的方向 theta 为 0 PI 和 -PI 时，叉乘结果为 0 无法通过向量确定平面，也就无法得到平面法向量 三、 VelocityVector # Actor 的速度是一个矢量，其表现是单位时间内的位移方向 当速度不为 0 ， VelocityVector 和 ForwardVector 的夹角与此时 Actor 应该展现的动画息息相关 四、计算夹角 # 坐标 ( Velocity , Angle ) VelocityVector 和 ForwardVector 夹角的计算通过反余弦结果和 sign(c.z) 的乘积实现，分析特殊情形 速度为 0 ，真实夹角应该为 0 计算夹角得到 PI/2 由于此时 Velocity 为 0 ，( 0, 任意 ) 对应 Idle ，可以显示正确动画 速度不为 0 ，夹角为 0 或 PI 叉乘结果为 0 ，即sign(c.z)为 0 ，即计算夹角得到 0 ，对应动画 RunFwd 夹角为 0 使用 RunFwd 正确，夹角为 PI 应该使用 RunBwd 夹角为 PI 时，不使用乘积，使用反余弦结果 夹角 反余弦结果 理论上的sign(c.z) 目的动画 使用乘积效果 0 0 0 Fwd o ( 0, PI/2 ) ( 0, PI/2 ) 1 Fwd \u0026gt; Right o PI/2 PI/2 1 Right o ( PI/2, PI ) ( PI/2, PI ) 1 Right \u0026gt; Bwd o PI PI 0 Bwd x -PI PI 0 Bwd x ( -PI, -PI/2 ) ( PI/2, PI ) -1 Left \u0026gt; Bwd o -PI/2 PI/2 -1 Left o ( -PI/2, 0 ) ( 0, PI/2 ) -1 Fwd \u0026gt; Left o 可以在蓝图中实现夹角的计算，也可以在C++中实现 Part 2 绘制 ForwardVector RightVector 和 VelocityVector # 虚幻编辑器 使用 DrawDebugArrow ， Duration 为 0 ，每帧都进行绘画 1. 绘制 ForwardVector # 起点 Actor 当前位置 偏移 放大的前进方向向量 终点 起点 + 偏移 2. 绘制 RightVector # 起点 Actor 当前位置 偏移 放大的向右方向向量 3. 绘制 VelocityVector # 起点 Actor 当前位置 偏移 放大的速度方向单位向量 4. 效果图 # 一直显示 ForwardVector 和 RightVector 有速度才会显示 VelocityVector 5. 优化显示 # 项目设置 \u0026gt; Engine \u0026gt; Rendering \u0026gt; Default Settings \u0026gt; Auto Exposure，取消勾选 旨在模拟人眼适应不同亮度 看不出区别 Part 3 使用 混合空间 实现Walk动画 # 虚幻编辑器 Blend Space 一、创建 BS_Locomotion_Walk # 设置轴 水平轴表示 速度 命名为 Velocity [ 0, 600 ] 垂直轴表示 ForwardVector 和 VelocityVector 的夹角 命名为 Direction [ -180, 180 ] 坐标 ( Velocity , Direction ) 动画资产 Idle Run_Fwd Run_Bwd Run_Rt Run_Lt 初始状态 Idle ( 0, 0 ) 满速前进 Run_Fwd ( 600, 0 ) 满速后退 Run_Bwd ( 600, -180 ) 和 ( 600, 180 ) 满速向右 Run_Rt ( 600, 90 ) 满速向左 Run_Lt ( 600, -90 ) 二、将 BS_Locomotion_Walk 用作走路动画 # ABP_BaseCharacter 添加变量 AngleBetweenForwardAndVelocity float类型 默认值为0 AngleBetweenForwardAndVelocity 作为 Direction 的输入 AnimGraph \u0026gt; 状态机 \u0026gt; Walk状态 Part 4 在蓝图计算 ForwardVector 和 VelocityVector 的夹角 # 虚幻编辑器 1. 在蓝图中计算夹角并设置变量 # 计算点乘时， ForwardVector 和 VelocityVector 都是单位向量 当前并未在夹角为PI时做处理，后退动画偶有闪动但看似正常 输出 DotProduct 结果，静止时输出 90 输出 CrossProduct 结果，静止、前进或后退时，坐标为 0 但是有正负 输出 Sign 结果，静止时为 0 ，前进或后退时，其结果或为 1 或为 -1 ，飘忽不定，但不为 0 ，所以后退动画看似正常 可以做出合理推测：显示为 0 但不意味着为 0 ，数值过于小了但是有正负 叉乘时传入未单位化的 Velocity 无改善 同时按下后退和向左，或者后退和向右，正负 3PI/4 的动画较为刻意 ( PI/2, PI ) 和 ( -PI, -PI/2 ) 时可以只显示 Run_Bwd 2. 绘制 ForwardVectr 和 VelocityVector 的叉乘结果 # 起点 Actor 当前位置 偏移 放大的叉乘结果 运动时才有向量显示 向前和向后运动时，偶有不明显的显示 3. 取消变量的设置 # 接下来在代码计算夹角 Part 5 在代码中计算 ForwardVector 和 VelocityVector 的夹角 # C++ 1. 计算夹角 # 函数成员 public 蓝图可调用 const函数 float ASTBaseCharacter::GetAngleBetweenForwardAndVelocity() const { if (GetVelocity().IsZero()) return 0.0f; const FVector ForwardVector = GetActorForwardVector(); const FVector VelocityNormalizedVector = GetVelocity().GetSafeNormal(); const float DotProductResult = FVector::DotProduct(ForwardVector, VelocityNormalizedVector); const float Theta = FMath::RadiansToDegrees(FMath::Acos(DotProductResult)); const FVector CrossProductResult = FVector::CrossProduct(ForwardVector, VelocityNormalizedVector); return (CrossProductResult.IsZero() ? Theta : FMath::Sign(CrossProductResult.Z) * Theta); } 速度为 0 时，夹角为 0 夹角为 PI 或 -PI 时，叉乘结果为0，返回反余弦结果 2. 代码优化 # 可选 实现前后左右移动回调函数 MoveForward 和 MoveRight 时，如果 Amount 为0，直接返回 Part 6 使用 C++ 函数设置夹角值 # 虚幻编辑器 1. 在蓝图中使用C++函数计算夹角 # ABP_BaseCharacter \u0026gt; EventGraph 2. 阻断动画蓝图无效状态 # 当我们打开动画蓝图时，其以standalone方式运行 即使未在虚幻编辑器中运行游戏，在蓝图编辑器打开ABP_BaseCharacter，其处于运行状态 可以看到动画蓝图视口的 Actor 是有动画的 从 EventBlueprintUpdateAnimation 出发， TryGetPawnOwner 得到空指针时，停在 CastToCharacter 添加打印名，验证动画蓝图运行 未在虚幻编辑器运行游戏，保持动画蓝图在前台，日志窗口一直有输出 未运行游戏时，阻断动画蓝图 从 EventBlueprintUpdateAnimation 出发，添加 IsValid 宏，检查 Pawn 有效性 "},{"id":13,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.b%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F/","title":"打包游戏","section":"角色和动画","content":" Overview # 打包游戏，从二进制文件运行 定期打包游戏，确保所做改动能正常运行 一、设置游戏首页 # 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 设置 GameDefaultMap 二、设置编译选项 # 项目设置 \u0026gt; Packaging \u0026gt; Project \u0026gt; Build Configuration 选择 发行 Shipping 三、设置玩家出发点 # 参考 LevelEditor \u0026gt; PlaceActors \u0026gt; Basic \u0026gt; PlayerStart 添加到关卡中 四、编译游戏 # 参考 可在日志窗口查看过程 创建文件夹 Projects/5.1.1/ShootTraining/Build 设置二进制文件保存路径 工具栏 \u0026gt; Platforms \u0026gt; Mac \u0026gt; Package Project 选择 Build 文件夹 1. metal-ar 报错 # 当前项目路径不包含空格，但包含汉字 打包项目 菜单栏 \u0026gt; File \u0026gt; Zip Project 移动到不含空格的英文路径 2. 打包成功 # 生成 Build/Mac/ShootTraining-Shipping.app 3. 尝试 Development 和 DebugGame 选项，均可 # 纯蓝图项目没有 DebugGame 选项 "},{"id":14,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.c%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/","title":"代码重构","section":"角色和动画","content":" 一、在5.2.0中编译ShooterGame # 不搞这个 二、项目结构 # 资产 Content/ ExternalContent/ Levels/ DefaultMap Player/ Animations/ ABP_BaseCharacter BS_Run BS_Walk BP_STBaseCharacter BP_STPlayerController BP_STGameModeBase C++ ShootTrainingSecond/ ShootTrainingSecondGameModeBase Public/ Components/ STCharacterMovementComponent Player/ STBaseCharacter STPlayerController 三、基础设置 # 载入 ExternalContent 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 四、任务 # 1. 三个蓝图类 # 虚幻编辑器 BP_STBaseCharacter BP_STPlayerController BP_STGameModeBase 使用 BP_STGameModeBase BP_STGameModeBase 使用 BP_STBaseCharacter 和 BP_STPlayerController 2. 添加组件 # C++ STBaseCharacter CameraComponent SpringArmComponent 3. 为Character绑定模型 # 虚幻编辑器 BP_STBaseCharacter 4. 绑定键位并给出函数描述 # 虚幻编辑器 项目设置 移动 轴映射 MoveRight APawn::AddMovementInput AActor::GetActorRightVector MoveForward APawn::AddMovementInput AActor::GetActorForwardVector 视角旋转 轴映射 TurnAround APawn::AddControllerYawInput 摄像机和Character一齐旋转 LookUp APawn::AddControllerPitchInput 需使能 SpringArmComponent::bUsePawnControlRotation 默认 PlayerController::InputPitchScale 是负数，所以 Scale 为 -1 CameraComponent 以 CameraComponent 为中心旋转， SpringArmComponent 以 Pawn 为中心旋转 动作 动作映射 Jump ACharacter::Jump Run 按下键位 速度不为0 Velocity和Forward夹角为0 可配置加速系数 通过覆写 CharacterMovementComponent::GetMaxSpeed 实现加速 5. 设置动画 # 虚幻编辑器 动画蓝图 ABP_BaseCharacter 状态 # 走路 BS_Walk 混合空间 横轴 Velocity [0, 600] 纵轴 Direction [-PI, PI] 动画资产 Idle Run_Fwd Run_Bwd Run_Rt Run_Lt 跑步 BS_Run 混合空间1D 横轴 Velocity [0, 600] 动画资产 Idle RoadieRun 跳跃 Jump 动画资产 JumpStart JumpLoop JumpEnd 状态迁移 # 跳跃的进入和结束使用 ACharacter::IsFalling 跳跃步骤的递进根据单次播放临近结束做判断 跑步和走路根据 ASTBaseCharacter::IsRuning 做判断 参数 # Velocity AActor::GetVelocity Direction ASTBaseCharacter::GetDirection [-PI, PI] ForwardVector 和 VelocityVector 的夹角使用反余弦计算，范围扩充使用叉乘结果Z坐标的正负 "},{"id":15,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/","title":"进阶课程","section":"虚幻引擎","content":""},{"id":16,"href":"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/","title":"健康系统","section":"进阶课程","content":""},{"id":17,"href":"/docs/","title":"Docs","section":"Introduction","content":""}]