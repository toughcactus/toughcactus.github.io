var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/%E5%88%86%E4%BA%AB/emacs/",title:"Emacs",description:"",content:""}),e.add({id:1,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E8%BF%90%E8%A1%8Cshootergame%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE/",title:"运行ShooterGame示例项目",description:"下载ShooterGame # Epic Games Launcher \u0026gt; Samples \u0026gt; Shooter Game 支持引擎版本 4.0 - 4.27 ，当前使用引擎版本 5.1.1 需要修改的地方 # UMatineeCameraShake 已被 ULegacyCameraShake 替代 PLATFORM_PS4 一个不合适的改法是在引擎代码中，紧接着 SWITCH 定义该宏 另一个麻烦但更合理的改法是，屏蔽该宏的出现 条件运算符的第二个和第三个操作数如果类型不一致，存在转换 参考 Source/ShooterGame/Private/Player/ShhoterCharacter.cpp:322 AController * 和 AActor * 可以相互转换，此处有歧义 运行效果 # ",content:"下载ShooterGame # Epic Games Launcher \u0026gt; Samples \u0026gt; Shooter Game 支持引擎版本 4.0 - 4.27 ，当前使用引擎版本 5.1.1 需要修改的地方 # UMatineeCameraShake 已被 ULegacyCameraShake 替代 PLATFORM_PS4 一个不合适的改法是在引擎代码中，紧接着 SWITCH 定义该宏 另一个麻烦但更合理的改法是，屏蔽该宏的出现 条件运算符的第二个和第三个操作数如果类型不一致，存在转换 参考 Source/ShooterGame/Private/Player/ShhoterCharacter.cpp:322 AController * 和 AActor * 可以相互转换，此处有歧义 运行效果 # "}),e.add({id:2,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%94%9F%E5%91%BD%E5%80%BC/",title:"实时显示游戏角色生命值",description:"Overview # 自定义健康组件 ActorComponent 纯逻辑 显示生命值 TextRenderComponent Part 1 创建健康组件 # 虚幻编辑器 ActorComponent 一、创建 Component/STHealthComponent # ActorComponent 公有类 Part 2 调整健康组件框架并给出初步实现 # C++ 一、调整框架 # 默认构造函数 将每帧调用TickComponent函数标志置为false PrimaryComponentTick.bCanEverTick = false; BeginPlay 屏蔽派生类 TickComponent 函数，使用基类实现 二、新增逻辑：实时生命值和最大生命值 # 数据成员 实时生命值 private float float Health = 0.0f; 最大生命值 protected 可设置类成员初始值 分组Health ( 0, 1000 ) UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Health\u0026quot;, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1000.0\u0026quot;)) float MaxHealth = 100.0f;	三、新增逻辑：获取生命值和初始化生命值 # 函数成员 获取生命值 public 蓝图可调用 const函数 隐式inline UFUNCTION(BlueprintCallable) float GetHealth() const { return Health; } 初始化生命值 private 在BeginPlay中调用 void USTHealthComponent::InitHealth() { Health = MaxHealth; } Part 3 为 Character 添加健康组件 # C++ STBaseCharacter 包含健康组件头文件 头文件 前向声明 class USTHealthComponent; 源文件 #include \u0026quot;Components/STHealthComponent.",content:"Overview # 自定义健康组件 ActorComponent 纯逻辑 显示生命值 TextRenderComponent Part 1 创建健康组件 # 虚幻编辑器 ActorComponent 一、创建 Component/STHealthComponent # ActorComponent 公有类 Part 2 调整健康组件框架并给出初步实现 # C++ 一、调整框架 # 默认构造函数 将每帧调用TickComponent函数标志置为false PrimaryComponentTick.bCanEverTick = false; BeginPlay 屏蔽派生类 TickComponent 函数，使用基类实现 二、新增逻辑：实时生命值和最大生命值 # 数据成员 实时生命值 private float float Health = 0.0f; 最大生命值 protected 可设置类成员初始值 分组Health ( 0, 1000 ) UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Health\u0026quot;, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1000.0\u0026quot;)) float MaxHealth = 100.0f;	三、新增逻辑：获取生命值和初始化生命值 # 函数成员 获取生命值 public 蓝图可调用 const函数 隐式inline UFUNCTION(BlueprintCallable) float GetHealth() const { return Health; } 初始化生命值 private 在BeginPlay中调用 void USTHealthComponent::InitHealth() { Health = MaxHealth; } Part 3 为 Character 添加健康组件 # C++ STBaseCharacter 包含健康组件头文件 头文件 前向声明 class USTHealthComponent; 源文件 #include \u0026quot;Components/STHealthComponent.h\u0026quot; 添加健康组件 数据成员 protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \u0026quot;Health\u0026quot;) USTHealthComponent *Health; 初始化组件 函数成员 private 在构造函数中调用 无表示，不用设置上级组件 void ASTBaseCharacter::InitHealthComponent() { Health = CreateDefaultSubobject\u0026lt;USTHealthComponent\u0026gt;(\u0026quot;HealthComponent\u0026quot;); } Part 4 为 Character 添加文本组件 # C++ STBaseCharacter 使用UTextRenderComponent 包含头文件 头文件 前向声明 class UTextRenderComponent; 源文件 #include \u0026quot;Components/TextRenderComponent.h\u0026quot; 添加TextRender组件 数据成员 protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \u0026quot;Health\u0026quot;) UTextRenderComponent *HealthText;	初始化组件 函数成员 private 在构造函数中调用 有视觉表示，挂到根组件下面 void ASTBaseCharacter::InitHealthTextComponent() { HealthText = CreateDefaultSubobject\u0026lt;UTextRenderComponent\u0026gt;(\u0026quot;HealthTextComponent\u0026quot;); HealthText-\u0026gt;SetupAttachment(GetRootComponent()); } 每帧更新显示文本 函数成员 private 在Tick函数中调用 void ASTBaseCharacter::DisplayHealthText() { HealthText-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), Health-\u0026gt;GetHealth()))); } 检查组件是否成功初始化 函数成员 private 在BeginPlay中调用 使用IDE编译时，若运行游戏崩溃，可在IDE中查看断点 void ASTBaseCharacter::CheckHealth() { check(Health); check(HealthText); } Part 5 调整文本组件 # 虚幻编辑器 BP_STBaseCharacter 一、查看无表示的组件 # Health 组件和 CharacterMovementComponent 无层级： 二者均无表示，纯逻辑 创建后无需挂在其他组件下面 二、查看Health组件 # 三、调整TextRender组件 # 设置属性 默认值 Text 水平对齐 Horizontal Alignment 文本颜色 Text Render Color 0 Center 天青色 将文本组件移动到 Character 上方 Location 因为运行时摄像机对着 Character 背面，旋转 RenderText Rotation 四、效果图 # "}),e.add({id:3,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E5%BF%AB%E6%8D%B7%E9%94%AE/",title:"快捷键",description:"导航 # 字符 操作 快捷键 函数 左移 C-b backward-char 右移 C-f forward-char 上移 C-p previous-line 下移 C-n next-line 行首 C-a move-beginning-of-line 行尾 C-e move-end-of-line 文件头 M-\u0026lt; beginning-of-buffer 文件尾 M-\u0026gt; 所在行居中 C-l recenter-top-bottom 向前翻页 M-v 向后翻页 C-v 语义 操作 快捷键 函数 句首 M-a 句尾 M-e 下一个单词 M-f 上一个单词 M-b 调整段落换行 M-q ",content:"导航 # 字符 操作 快捷键 函数 左移 C-b backward-char 右移 C-f forward-char 上移 C-p previous-line 下移 C-n next-line 行首 C-a move-beginning-of-line 行尾 C-e move-end-of-line 文件头 M-\u0026lt; beginning-of-buffer 文件尾 M-\u0026gt; 所在行居中 C-l recenter-top-bottom 向前翻页 M-v 向后翻页 C-v 语义 操作 快捷键 函数 句首 M-a 句尾 M-e 下一个单词 M-f 上一个单词 M-b 调整段落换行 M-q "}),e.add({id:4,href:"/docs/%E5%88%86%E4%BA%AB/macos/%E7%BB%88%E7%AB%AF/",title:"终端",description:"Part 1 iTerm2 # 官网下载 参考 窗口管理 # 快捷键 操作 Command-w 关闭窗口 分屏 快捷键 操作 Command-d 左右分屏 Command-Shift-d 上下分屏 Command-[ 标签页内切换窗口 Command-] Option-Command-UP 根据方向键切换窗口 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 快捷键 操作 Command-t 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right status bar # Preferences \u0026gt; Profiles \u0026gt; Session 勾选Status bar enabled，点击Configure Status Bar Preferences \u0026gt; Appearence \u0026gt; General \u0026gt; Status bar location Bottom 配色 # 官方提供的配色 常用配色 Dracula lovelace , lovelace文本 导入配色 Preferences Profiles Color \u0026gt; Color Presets \u0026gt; Import 窗口大小 # Preferences \u0026gt; Profiles \u0026gt; Window 设置 Columns 和 Rows 透明度 # Preferences \u0026gt; Profiles \u0026gt; Window \u0026gt; Transparency 3 字体 # Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Font Victor Mono 14 consolas下载指南 victor mono Part 2 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 安装 # /bin/bash -c \u0026quot;$(curl -fsSL https://mirrors.",content:"Part 1 iTerm2 # 官网下载 参考 窗口管理 # 快捷键 操作 Command-w 关闭窗口 分屏 快捷键 操作 Command-d 左右分屏 Command-Shift-d 上下分屏 Command-[ 标签页内切换窗口 Command-] Option-Command-UP 根据方向键切换窗口 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 快捷键 操作 Command-t 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right status bar # Preferences \u0026gt; Profiles \u0026gt; Session 勾选Status bar enabled，点击Configure Status Bar Preferences \u0026gt; Appearence \u0026gt; General \u0026gt; Status bar location Bottom 配色 # 官方提供的配色 常用配色 Dracula lovelace , lovelace文本 导入配色 Preferences Profiles Color \u0026gt; Color Presets \u0026gt; Import 窗口大小 # Preferences \u0026gt; Profiles \u0026gt; Window 设置 Columns 和 Rows 透明度 # Preferences \u0026gt; Profiles \u0026gt; Window \u0026gt; Transparency 3 字体 # Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Font Victor Mono 14 consolas下载指南 victor mono Part 2 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 安装 # /bin/bash -c \u0026quot;$(curl -fsSL https://mirrors.ustc.edu.cn/misc/brew-install.sh)\u0026quot; 设置源 # vi ～/.zshrc source ～/.zshrc 源代码仓库 export HOMEBREW_BREW_GIT_REMOTE=\u0026quot;https://mirrors.ustc.edu.cn/brew.git\u0026quot; 预编译二进制软件包与软件包元数据文件 export HOMEBREW_BOTTLE_DOMAIN=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-bottles\u0026quot; export HOMEBREW_API_DOMAIN=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-bottles/api\u0026quot; 核心软件仓库 export HOMEBREW_CORE_GIT_REMOTE=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026quot; 管理软件 # brew install --cask emacs # 安装 brew uninstall --cask emacs # 卸载 brew list # 当前管理的程序 使用cask选项则安装编译好的软件包，通常是一些带界面的软件；默认下载源码在本地编译安装，通常是不带界面的命令行工具和第三方库 Part 3 代理 Privoxy # 使用Homebrew安装 依赖pcre 设置iTerm2走代理 终端下Github走代理 要求本地已有代理软件，还有一种方法SS 参考 安装 brew install privoxy 配置 Privoxy使用端口号8118 vi /usr/local/etc/privoxy/config # 在文件末尾添加以下代码 listen-address 0.0.0.0:8118 forward-socks5 / localhost:1080 . 手动启动Privoxy sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config # 查看端口是否被监听 netstat -na | grep 8118 查询本地代理使用端口 系统偏好设置 \u0026gt; 网络 \u0026gt; Wi-Fi \u0026gt; 高级 \u0026gt; 代理 \u0026gt; 网页代理 / 安全网页代理 配置环境变量 vi ~/.zshrc # 添加以下内容 # 端口信息需查询，替换1949 export http_proxy='http://localhost:1949' export https_proxy=$http_proxy # 重载配置文件 source ~/.zshrc Part 4 oh-my-zsh # 官网 sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; 配置文件 vi .zshrc # 配置文件 source ~/.zshrc # 载入配置 下载Dracula主题 ln -s Dracula/zsh/dracula.zsh-theme ~/.oh-my-zsh/themes/ 设置主题 官方提供的主题已下载到本地 官方主题展示 ZSH_THEME=\u0026quot;robbyrussell\u0026quot; # 默认 ZSH_THEME=\u0026quot;random\u0026quot; # 随机 ZSH_THEME=\u0026quot;dracula\u0026quot; "}),e.add({id:5,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/bash/",title:"Shell脚本",description:"花括号的使用 # 资料 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，可以将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这么玩，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 tr命令 # runoob 去除引号 # tr -d '\u0026quot;' 使用sed sed 's/\\\u0026quot;//g' sed命令 # MacOS安装gsed runoob 1. 匹配行打印 # p gsed -n \u0026quot;/abc/p\u0026quot; file 2.",content:"花括号的使用 # 资料 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，可以将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这么玩，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 tr命令 # runoob 去除引号 # tr -d '\u0026quot;' 使用sed sed 's/\\\u0026quot;//g' sed命令 # MacOS安装gsed runoob 1. 匹配行打印 # p gsed -n \u0026quot;/abc/p\u0026quot; file 2. 修改源文件 匹配行删除 # -i d gsed -i \u0026quot;/abc/d\u0026quot; file 3. 修改源文件 匹配行文本替换 # 首个匹配项 gsed -i \u0026quot;s/abc/edf/\u0026quot; file 所有匹配项 gsed -i \u0026quot;s/abc/edf/g\u0026quot; file awk命令 # 指定分隔符，打印第3个参数 # awk -F ',' '{print $3}' file命令 # 查看文件编码 # file FILE echo命令 # 输出单行 # var=\u0026quot;hello world!\u0026quot; echo $var 输出多行 # echo -e \u0026quot;\\nhello world!\\n\u0026quot; "}),e.add({id:6,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/",title:"Git",description:"安装与配置 # 安装 方法 官网下载git-2.40.0 make install xcode自带 本地配置git账户 git -v # 配置账户信息 git config --global user.name \u0026quot;USERNAME\u0026quot; git config --global user.email \u0026quot;EMAIL-ADDRESS\u0026quot; 配置ssh # 生成秘钥 | 拷贝公钥到github ssh-keygen cat /Users/USERNAME/.ssh/id_rsa.pub 本地初始化，设置上游 # git init git remote add cute git@github.com:xxx/xx.git # cute为上游别名 git remote -v git fetch cute # 拉取上游内容，和Github项目同步 创建分支与切换 # git branch -a # 查看当前分支 git checkout main # 切换到分支main git branch master # 创建新分支master git checkout master 首次提交，需关联上游分支 # # 提交 git add -A git commit -m \u0026quot;Commit public and set-up-blog.",content:"安装与配置 # 安装 方法 官网下载git-2.40.0 make install xcode自带 本地配置git账户 git -v # 配置账户信息 git config --global user.name \u0026quot;USERNAME\u0026quot; git config --global user.email \u0026quot;EMAIL-ADDRESS\u0026quot; 配置ssh # 生成秘钥 | 拷贝公钥到github ssh-keygen cat /Users/USERNAME/.ssh/id_rsa.pub 本地初始化，设置上游 # git init git remote add cute git@github.com:xxx/xx.git # cute为上游别名 git remote -v git fetch cute # 拉取上游内容，和Github项目同步 创建分支与切换 # git branch -a # 查看当前分支 git checkout main # 切换到分支main git branch master # 创建新分支master git checkout master 首次提交，需关联上游分支 # # 提交 git add -A git commit -m \u0026quot;Commit public and set-up-blog.\u0026quot; git push --set-upstream cute master # 上游cute 分支master 删除commit记录 # git log # 最新提交 F E D C B，要删除F和E，记录D git rebase -i D # 将F E的pick改为drop git log # 查看当前提交 D C B git push cute master --force # 上游cute 分支master 存在多个文件添加/删除/修改，在上次提交的基础上再次提交 # 不建议如此操作，风险较大 项目文件夹一式两份，A和A_BAK 删除文件夹A内所有代码 不会删除.git文件夹，提交和同步记录均保留 rm -rf A/* 将A_BAK内的所有文件拷贝到A 不会拷贝.git cp -r A_BAK/* A/ 再次提交 git add -A git commit -m \u0026quot;Comments.\u0026quot; git push 设置代理 # # 查看配置 git config --list # 使用代理端口替换1949 git config --global https.proxy https://localhost:1949 git config --global http.proxy http://localhost:1949 # 取消设置 git config --global --unset http.proxy git config --global --unset https.proxy 设置项目同步链接 # SSH git remote set-url cute git@github.com:xxx/xx.git HTTPS push时需要验证，Github不再支持用户名和密码 git remote set-url cute https://github.com/xx.git "}),e.add({id:7,href:"/docs/brick/%E7%BB%88%E7%AB%AF/",title:"终端",description:"Overview # 介绍CLI，Terminal，Shell和Prompt视频 shell概念 # 接口 shell，和core相区分，是操作系统的外层。通过shell程序，可以使用系统服务或其他程序提供的功能。 根据操作系统类别和操作类型，shell可以分为图形shell（GUI）和命令行shell（CLI）。通常说的shell，指的命令行shell。 CLI Command-Line Interface 命令行界面 通过文本命令和计算机交互 GUI Graphical User Interface 图形用户界面 终端程序 # Terminal Wrapper Program 在终端输入文本命令 GUI或者程序提供的用于键入命令的窗口 终端程序 说明 iTerm MacOS Windows Terminal Windows Gnome Terminal 使用Gnome作为桌面的Linux自带的终端程序 Hyper Warp 目前MacOS；自动补全，鼠标交互，内置工作流，AI功能 Alacrity 命令解释器 # Shell 程序 终端中运行的程序。接受命令，然后解释并执行。 Shell启动时自动读取配置文件。 Shell 说明 sh Bourne Shell UNIX上的标准shell bash Bourne-Again Shell GNU开发；Linux默认；MacOS之前默认 不完全兼容sh shell，对一些命令和参数进行了扩展 配置文件 ~/.bash_profile zsh 19年起MacOS默认 配置文件 ~/zshrc 第三方框架oh-my-zsh提供其他功能 phish 脚本语言 # 需要解释器，每次运行时都需要解释。 脚本语言 JavaScript PHP Lua Python C# Shell脚本 # 开发语言 Shell Script 由一连串shell命令组成，可以指定用来解释脚本的shell程序 命令提示符 # Prompt 命令解释器提供并在终端显示，如当前路径和git信息。 类别 第三方提示 Powerline Starship Power Level 10K Spaceship 第三方框架 oh-my-zsh 提供各种promots，configuration options，aliases，plugins。支持自定义prompt，调整shell行为 查看Shell信息 # 命令解释器 当前使用的shell echo $SHELL echo $0 已安装shell cat /etc/shells Shell操作 # 切换shell程序 重新打开终端生效 chsh -s /bin/bash 不修改SHELL环境变量 zsh 手动读取配置文件 zsh source ~/.",content:"Overview # 介绍CLI，Terminal，Shell和Prompt视频 shell概念 # 接口 shell，和core相区分，是操作系统的外层。通过shell程序，可以使用系统服务或其他程序提供的功能。 根据操作系统类别和操作类型，shell可以分为图形shell（GUI）和命令行shell（CLI）。通常说的shell，指的命令行shell。 CLI Command-Line Interface 命令行界面 通过文本命令和计算机交互 GUI Graphical User Interface 图形用户界面 终端程序 # Terminal Wrapper Program 在终端输入文本命令 GUI或者程序提供的用于键入命令的窗口 终端程序 说明 iTerm MacOS Windows Terminal Windows Gnome Terminal 使用Gnome作为桌面的Linux自带的终端程序 Hyper Warp 目前MacOS；自动补全，鼠标交互，内置工作流，AI功能 Alacrity 命令解释器 # Shell 程序 终端中运行的程序。接受命令，然后解释并执行。 Shell启动时自动读取配置文件。 Shell 说明 sh Bourne Shell UNIX上的标准shell bash Bourne-Again Shell GNU开发；Linux默认；MacOS之前默认 不完全兼容sh shell，对一些命令和参数进行了扩展 配置文件 ~/.bash_profile zsh 19年起MacOS默认 配置文件 ~/zshrc 第三方框架oh-my-zsh提供其他功能 phish 脚本语言 # 需要解释器，每次运行时都需要解释。 脚本语言 JavaScript PHP Lua Python C# Shell脚本 # 开发语言 Shell Script 由一连串shell命令组成，可以指定用来解释脚本的shell程序 命令提示符 # Prompt 命令解释器提供并在终端显示，如当前路径和git信息。 类别 第三方提示 Powerline Starship Power Level 10K Spaceship 第三方框架 oh-my-zsh 提供各种promots，configuration options，aliases，plugins。支持自定义prompt，调整shell行为 查看Shell信息 # 命令解释器 当前使用的shell echo $SHELL echo $0 已安装shell cat /etc/shells Shell操作 # 切换shell程序 重新打开终端生效 chsh -s /bin/bash 不修改SHELL环境变量 zsh 手动读取配置文件 zsh source ~/.zshrc 指定shell脚本的命令解释器 #!/bin/bash "}),e.add({id:8,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/",title:"搭建个人博客",description:"Overview # 环境 说明 Github Page 部署服务器 Hugo 构建静态网页 anubis 主题 安装依赖 # Hugo 1. 使用go安装 # Windows系统 安装go 官网下载 环境变量 # go export PATH=/usr/local/go/bin:$PATH export GOROOT=/usr/local/go export GOPATH=/Users/USERNAME/go export GOBIN=/Users/USERNAME/go/bin # go安装的软件 export PATH=$GOBIN:$PATH 生效 vi ~/.zshrc source ~/.zshrc 安装hugo 如若遇上网络不佳 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off 安装，验证 go install github.com/gohugoio/hugo@latest hugo env -v 如果需要使用hugo扩展功能，替换hugo文件 2. 使用homebrew安装 # MacOS brew install hugo 初始化项目 # 初始化项目 hugo new site /site/path 通用项目结构 文件 说明 config.",content:"Overview # 环境 说明 Github Page 部署服务器 Hugo 构建静态网页 anubis 主题 安装依赖 # Hugo 1. 使用go安装 # Windows系统 安装go 官网下载 环境变量 # go export PATH=/usr/local/go/bin:$PATH export GOROOT=/usr/local/go export GOPATH=/Users/USERNAME/go export GOBIN=/Users/USERNAME/go/bin # go安装的软件 export PATH=$GOBIN:$PATH 生效 vi ~/.zshrc source ~/.zshrc 安装hugo 如若遇上网络不佳 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off 安装，验证 go install github.com/gohugoio/hugo@latest hugo env -v 如果需要使用hugo扩展功能，替换hugo文件 2. 使用homebrew安装 # MacOS brew install hugo 初始化项目 # 初始化项目 hugo new site /site/path 通用项目结构 文件 说明 config.toml 配置文件；yaml格式也可以 content 存放blog；支持md和org theme 存放主题 public 生成的静态页面；同步到Github项目 archetypes 文章模版 创建页面 保存到 ./content/post hugo new post/first-blog.org 使用主题anubis # 下载主题 anubis on hugo anubis on github 如果使用git管理静态网页项目 git init git submodule add https://github.com/mitrichius/hugo-theme-anubis.git themes/anubis 或者直接下载，并存放到./theme目录下 使用anubis提供的模板 ./themes/anubis/exampleSite cp themes/anubis/exampleSite/config.toml . cp themes/anubis/exampleSite/content/. content config.toml 说明 menu 有三项，about，tags和archives tags 按tag统计后的文章分类；还可以进入到categories archives 存放所有blog content 说明 tags 对blog进行tag categories 对blog进行分类 post 所有blog存放在post；会统计post路径下blog的tag和categories，并遍历到对应menu项 about about.md；about-subpage.md和about-subpage2.md是about的两个子页 文章模板 yaml \u0026mdash; author: \u0026ldquo;author\u0026rdquo; title: \u0026ldquo;article title\u0026rdquo; date: \u0026ldquo;2023-03-17\u0026rdquo; description: \u0026ldquo;article description\u0026rdquo; tags: [ \u0026ldquo;tag-1\u0026rdquo;, \u0026ldquo;tag-2\u0026rdquo;, ] categories: [ \u0026ldquo;category\u0026rdquo;, ] \u0026mdash; 简单介绍 \u0026lt;!\u0026ndash;more\u0026ndash;\u0026gt; 正文 使用hugo构建静态网页 # 选项 说明 \u0026ndash;theme=anubis 设置主题； -t anubis both --watch 修改文件后自动刷新浏览器； -w server --buildDrafts 包括标记为draft的笔记； -D both --buildFuture 包括新发布笔记；检查date选项； -F both \u0026ndash;baseUrl=\u0026quot;http://toughcactus.github.io/\u0026quot; 编译时不包含，GithubPage部署会丢失样式 both --cleanDestinationDir 将public文件夹中不再使用的文件删除 hugo 1. 运行服务器 # 查询server选项 参考 hugo help server 本地测试，访问 http://localhost:1313/ hugo server --theme=anubis --watch # hugo server 2. 生成静态页面 # 生成文件在 ./public hugo --theme=anubis --baseUrl=\u0026quot;https://toughcactus.github.io/\u0026quot; # hugo 在Github创建项目 # 创建repository toughcactus.github.io 为github设置主题 创建_config.yml文件 remote_theme: pages-themes/midnight@v0.2.0 将public内容提交到repository "}),e.add({id:9,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%88%9D%E5%A7%8B%E5%8C%96shoottraining%E9%A1%B9%E7%9B%AE/",title:"初始化ShootTraining项目",description:"Overview # 将 ShooterGame 作为内容包，基于此开发 ShootTraining 。如有室内设计师提供游戏资料，我们基于此开发游戏。 虚幻编辑器 一、创建 ShootTraining 项目 # Blank Blueprint 二、配置 ShootTraining # 添加 Copyright 项目设置 \u0026gt; Project \u0026gt; Description \u0026gt; Legal \u0026gt; Copyright Notice Shoot Training Game, All Rights Reserved. 关卡设置 添加关卡文件夹 Content/Levels 创建关卡 Content/Levels/DefaultMap Basic 设置 EditorStartupMap 和 GameDefaultMap 使用 DefaultMap 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 不使用预编译头文件 ShootTraining.Build.cs // PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PCHUsage = PCHUsageMode.NoPCHs; 添加外部资产文件夹 Content/ExternalContent 三、从 ShooterGame 导入资产 # 打开ShooterGame项目 \u0026gt; 在内容浏览器选中Content/Animations/TTP_Animations，右键 \u0026gt; Migrate 取消Sounds勾选 默认勾选的文件夹里的内容都与 TTP_Animations 相关 保存到 Content 目录下 不能直接迁移到 ExternalContent ，虚幻引擎会检查目录，要求这些资产的上级目录是 Content ，即使根目录是 Content 也无法通过检查 通过虚幻编辑器，将 Content 目录下的 Animations Characters Environment 移动到 ExternalContent 目录下 不能直接将三个文件夹移动到 ExternalContent 中，会导致资产之间的相互引用路径出错 打开 ShootTraining 项目，为 ExternalContent 设置文件夹颜色 选中Content/ExternalContent，右键 \u0026gt; Set Color 效果图 外部资产结构 四、基于蓝图创建C++项目 # 添加C++类即可。创建蓝图项目的时间开销明显小于创建C++项目的时间开销。 创建 GameModeBase STGameModeBase 不设置类类型 Content同级目录出现C++ Classes文件夹 设置关卡使用 STGameModeBase 五、脚本 # 编译项目 build.",content:"Overview # 将 ShooterGame 作为内容包，基于此开发 ShootTraining 。如有室内设计师提供游戏资料，我们基于此开发游戏。 虚幻编辑器 一、创建 ShootTraining 项目 # Blank Blueprint 二、配置 ShootTraining # 添加 Copyright 项目设置 \u0026gt; Project \u0026gt; Description \u0026gt; Legal \u0026gt; Copyright Notice Shoot Training Game, All Rights Reserved. 关卡设置 添加关卡文件夹 Content/Levels 创建关卡 Content/Levels/DefaultMap Basic 设置 EditorStartupMap 和 GameDefaultMap 使用 DefaultMap 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 不使用预编译头文件 ShootTraining.Build.cs // PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PCHUsage = PCHUsageMode.NoPCHs; 添加外部资产文件夹 Content/ExternalContent 三、从 ShooterGame 导入资产 # 打开ShooterGame项目 \u0026gt; 在内容浏览器选中Content/Animations/TTP_Animations，右键 \u0026gt; Migrate 取消Sounds勾选 默认勾选的文件夹里的内容都与 TTP_Animations 相关 保存到 Content 目录下 不能直接迁移到 ExternalContent ，虚幻引擎会检查目录，要求这些资产的上级目录是 Content ，即使根目录是 Content 也无法通过检查 通过虚幻编辑器，将 Content 目录下的 Animations Characters Environment 移动到 ExternalContent 目录下 不能直接将三个文件夹移动到 ExternalContent 中，会导致资产之间的相互引用路径出错 打开 ShootTraining 项目，为 ExternalContent 设置文件夹颜色 选中Content/ExternalContent，右键 \u0026gt; Set Color 效果图 外部资产结构 四、基于蓝图创建C++项目 # 添加C++类即可。创建蓝图项目的时间开销明显小于创建C++项目的时间开销。 创建 GameModeBase STGameModeBase 不设置类类型 Content同级目录出现C++ Classes文件夹 设置关卡使用 STGameModeBase 五、脚本 # 编译项目 build.sh #!/bin/bash BuildScript=\u0026quot;EpicGames/UE_5.1/Engine/Build/BatchFiles/Mac/Build.sh\u0026quot; ProjectName=\u0026quot;ShootTraining\u0026quot; Project=\u0026quot;Projects/5.1.1/$ProjectName/$ProjectName.uproject\u0026quot; Target=$ProjectName\u0026quot;Editor\u0026quot; $BuildScript $Target Mac Development \u0026quot;$Project\u0026quot; -waitmutex -NoHotReload 打开虚幻编辑器 open_editor.sh #!/bin/bash UnrealEditor=\u0026quot;EpicGames/UE_5.1/Engine/Binaries/Mac/UnrealEditor.app\u0026quot; ProjectName=\u0026quot;ShootTraining\u0026quot; Project=\u0026quot;Projects/5.1.1/$ProjectName/$ProjectName.uproject\u0026quot; open -a $UnrealEditor $Project 生成项目文件 generate_project_files.sh #!/bin/bash GenerateProjectFilesScript=\u0026quot;EpicGames/UE_5.1/Engine/Build/BatchFiles/Mac/GenerateProjectFiles.sh\u0026quot; ProjectName=\u0026quot;ShootTraining\u0026quot; Project=\u0026quot;Projects/5.1.1/$ProjectName/$ProjectName.uproject\u0026quot; $GenerateProjectFilesScript -projectfiles -project=$Project -game -rocket -progress -VSCode # $GenerateProjectFilesScript -projectfiles -project=$Project -game -rocket -progress -XCodeProjectFiles EngineCCDst=\u0026quot;EpicGames/UE_5.1/compile_commands.json\u0026quot; EngineCCSrc=\u0026quot;EpicGames/UE_5.1/.vscode/compileCommands_Default.json\u0026quot; ProjectCCDst=\u0026quot;Projects/5.1.1/\u0026quot;$ProjectName\u0026quot;/compile_commands.json\u0026quot; ProjectCCSrc=\u0026quot;Projects/5.1.1/\u0026quot;$ProjectName\u0026quot;/.vscode/compileCommands_\u0026quot;$ProjectName\u0026quot;.json\u0026quot; cp $EngineCCSrc $EngineCCDst cp $ProjectCCSrc $ProjectCCDst 六、查看项目源码中的版权信息 # "}),e.add({id:10,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E4%BC%A4%E5%AE%B3/",title:"计算伤害",description:"Overview # 虚幻引擎提供一组函数，用来对Actor造成伤害 在Tick函数中，持续对游戏角色造成伤害；每次造成伤害，委托机制触发处理函数，更新角色生命值 一、每帧对 Character 造成伤害 # STBaseCharacter 函数成员 private 在Tick中调用 伤害来源是自己 void ASTBaseCharacter::CharacterTakeDamage() { TakeDamage(0.1f, FDamageEvent{}, GetController(), this); } 二、定义空的伤害委托处理函数，并注册到 Character # USTHealthComponent 包含头文件 源文件 #include \u0026quot;GameFramework/Actor.h\u0026quot; 定义日志类型 源文件 DEFINE_LOG_CATEGORY_STATIC(LogHealthComponent, All, All) 搭建处理函数框架 函数成员 private 委托类型FTakeAnyDamageSignature：从委托类型的定义获取处理函数签名；委托属性多播，支持蓝图，需要UFUNCTION宏 UFUNCTION() void OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 注册处理函数 函数成员 private 在BeginPlay中调用 void USTHealthComponent::RegisterDamageHandler() { AActor *ThisActor = GetOwner(); if (ThisActor) { ThisActor-\u0026gt;OnTakeAnyDamage.AddDynamic(this, \u0026amp;USTHealthComponent::OnTakeAnyDamage); } } 实现伤害委托处理函数 Health减为0，作为负数仍在减；差不多一秒10帧，即1s调用十次处理函数 触发处理函数时，不会传入整个FDamageEvent变量，而是传入UDamageType void USTHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) { Health -= Damage; } ",content:"Overview # 虚幻引擎提供一组函数，用来对Actor造成伤害 在Tick函数中，持续对游戏角色造成伤害；每次造成伤害，委托机制触发处理函数，更新角色生命值 一、每帧对 Character 造成伤害 # STBaseCharacter 函数成员 private 在Tick中调用 伤害来源是自己 void ASTBaseCharacter::CharacterTakeDamage() { TakeDamage(0.1f, FDamageEvent{}, GetController(), this); } 二、定义空的伤害委托处理函数，并注册到 Character # USTHealthComponent 包含头文件 源文件 #include \u0026quot;GameFramework/Actor.h\u0026quot; 定义日志类型 源文件 DEFINE_LOG_CATEGORY_STATIC(LogHealthComponent, All, All) 搭建处理函数框架 函数成员 private 委托类型FTakeAnyDamageSignature：从委托类型的定义获取处理函数签名；委托属性多播，支持蓝图，需要UFUNCTION宏 UFUNCTION() void OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 注册处理函数 函数成员 private 在BeginPlay中调用 void USTHealthComponent::RegisterDamageHandler() { AActor *ThisActor = GetOwner(); if (ThisActor) { ThisActor-\u0026gt;OnTakeAnyDamage.AddDynamic(this, \u0026amp;USTHealthComponent::OnTakeAnyDamage); } } 实现伤害委托处理函数 Health减为0，作为负数仍在减；差不多一秒10帧，即1s调用十次处理函数 触发处理函数时，不会传入整个FDamageEvent变量，而是传入UDamageType void USTHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) { Health -= Damage; } "}),e.add({id:11,href:"/docs/%E5%88%86%E4%BA%AB/emacs/org-mode/",title:"org-mode",description:"Overview # The Org Manual 样式 # 删除线 +Content+ 下划线 ox-hugo转markdown存在问题 _Content_ 文本块 =test= ~test~ 斜体 /test/ 加粗 *test* 选项设置 # 关闭toc Table of Contents #+OPTIONS: toc:nil 指定toc显示层级 #+TOC: headlines 2 上标和下标 a_b a^b 关闭 #+OPTIONS: ^:nil 需要使用{}转义 #+OPTIONS ^:{} a_{b} a^{b} 自动为标题添加标号 关闭 #+OPTIONS num:nil 选项合并 #+OPTIONS: toc:nil ^:{} #+STARTUP: showall hidestars 显示所有内容 #+STARTUP: showall 只显示一级标题 #+STARTUP: overview 隐藏星号 #+STARTUP: hidestars 模板 # Structure Templates C-c C-, org-insert-structure-template 代码框 填写编程语言 // C++样式 #+begin_src LANGUAGE #+end_src 文本框 文本框样式 #+begin_example #+end_example quote quote样式 #+begin_quote #+end_quote ",content:"Overview # The Org Manual 样式 # 删除线 +Content+ 下划线 ox-hugo转markdown存在问题 _Content_ 文本块 =test= ~test~ 斜体 /test/ 加粗 *test* 选项设置 # 关闭toc Table of Contents #+OPTIONS: toc:nil 指定toc显示层级 #+TOC: headlines 2 上标和下标 a_b a^b 关闭 #+OPTIONS: ^:nil 需要使用{}转义 #+OPTIONS ^:{} a_{b} a^{b} 自动为标题添加标号 关闭 #+OPTIONS num:nil 选项合并 #+OPTIONS: toc:nil ^:{} #+STARTUP: showall hidestars 显示所有内容 #+STARTUP: showall 只显示一级标题 #+STARTUP: overview 隐藏星号 #+STARTUP: hidestars 模板 # Structure Templates C-c C-, org-insert-structure-template 代码框 填写编程语言 // C++样式 #+begin_src LANGUAGE #+end_src 文本框 文本框样式 #+begin_example #+end_example quote quote样式 #+begin_quote #+end_quote "}),e.add({id:12,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/elisp/",title:"Elisp",description:"执行shell命令 # (shell-command \u0026quot;ps\u0026quot;) 当前文件路径+文件名 # (buffer-file-name) ",content:"执行shell命令 # (shell-command \u0026quot;ps\u0026quot;) 当前文件路径+文件名 # (buffer-file-name) "}),e.add({id:13,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/chrome/",title:"Chrome",description:"开发者工具 # F12 设置页面布局 查看日志 查看元素信息 跟踪事件 # 开始Record 停止 页面滚动事件 文章目录滚动 ",content:"开发者工具 # F12 设置页面布局 查看日志 查看元素信息 跟踪事件 # 开始Record 停止 页面滚动事件 文章目录滚动 "}),e.add({id:14,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E4%BD%BF%E7%94%A8ox-hugo%E8%AE%BE%E7%BD%AE%E9%80%89%E9%A1%B9/",title:"使用ox-hugo设置选项",description:"Overview # ox-hugo manual 根目录 # 如果使能 org-hugo-external-file-extensions-allowed-for-copying，要求根目录下必须有static文件夹，默认创建ox-hugo文件夹，并将图片拷贝到ox-hugo 分区对应 根目录/content/分区，默认创建content文件夹 #+HUGO_BASE_DIR: ../ 生成博文方式 # manual 子树 每个org子树作为一篇博文 ​* 每棵子树作为一篇博文 :PROPERTIES: :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true :weight 2 :END: ** 第一篇博文 ** 第二篇博文 org文件作为博文 #+HUGO_CUSTOM_FRONT_MATTER: :bookCollapseSection true :weight 20 #+HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true :weight 2 配置自定义选项 # 如果同时在子树和文件配置，根据子树导出时，只有子树定义项 子树 :PROPERTIES: :EXPROT_HUGO_CUSTOM_FRONT_MATTER: :foo bar :baz zoo :END: 文件 #+HUGO_CUSTOM_FRONT_MATTER: :foo bar :baz zoo 分区 + 样式 + 权重 # 子树 :PROPERTIES: :EXPORT_HUGO_SECTION: ./ :EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml :EXPORT_HUGO_WEIGHT: 4 :END: 文件 #+HUGO_SECTION: .",content:"Overview # ox-hugo manual 根目录 # 如果使能 org-hugo-external-file-extensions-allowed-for-copying，要求根目录下必须有static文件夹，默认创建ox-hugo文件夹，并将图片拷贝到ox-hugo 分区对应 根目录/content/分区，默认创建content文件夹 #+HUGO_BASE_DIR: ../ 生成博文方式 # manual 子树 每个org子树作为一篇博文 ​* 每棵子树作为一篇博文 :PROPERTIES: :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true :weight 2 :END: ** 第一篇博文 ** 第二篇博文 org文件作为博文 #+HUGO_CUSTOM_FRONT_MATTER: :bookCollapseSection true :weight 20 #+HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true :weight 2 配置自定义选项 # 如果同时在子树和文件配置，根据子树导出时，只有子树定义项 子树 :PROPERTIES: :EXPROT_HUGO_CUSTOM_FRONT_MATTER: :foo bar :baz zoo :END: 文件 #+HUGO_CUSTOM_FRONT_MATTER: :foo bar :baz zoo 分区 + 样式 + 权重 # 子树 :PROPERTIES: :EXPORT_HUGO_SECTION: ./ :EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml :EXPORT_HUGO_WEIGHT: 4 :END: 文件 #+HUGO_SECTION: ./ #+TITLE: Doks主题 #+HUGO_FRONT_MATTER_FORMAT: toml #+HUGO_WEIGHT: 10 文件 最后修改 # #+HUGO_AUTO_SET_LASTMOD: t 文件 草稿+分类+tag+日期 # 日期格式 yyyy-mm-dd，发布时会检查时区 #+HUGO_DRAFT: true #+HUGO_CATEGORIES: emacs #+HUGO_TAGS: hugo #+DATE: 2021-09-10 子树 分类+tag+日期+导出文件名 # * CATEGORY :@emacs: ** Doks主题 :hugo:org: :PROPERTIES: :EXPORT_DATE: 2023-06-07 :EXPORT_FILE_NAME: Doks主题 :END: 导出子树 # 参考 C-c C-e H A (org-hugo-export-wim-to-md :all-subtrees) 炫技 # title = \u0026quot;`(cdr (assoc \u0026quot;ITEM\u0026quot; (org-entry-properties)))`\u0026quot; date = \u0026quot;`(format-time-string \u0026quot;%Y-%m-%dT%H:%M:%S\u0026quot;)`\u0026quot; "}),e.add({id:15,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/",title:"代码规范",description:"Overview # .clang-format .gitignore 参考 按个人习惯来，非建议 大括号 放在新行 缩进 使用制表符，缩进宽度和制表符宽度一致 虚幻引擎建议使用制表符，也可以使用空格 缩进、制表符和空格 # 缩进 indent 编写代码时，按下tab键，即按格式留出空位，用以控制格式 默认使用制表符 tab 因为制表符的宽度可设置，不同平台制表符的宽度不一，视觉上，查看代码会有不习惯的感觉；可在本地设置使用空格，即用空格替换制表符 制表符宽度和缩进宽度 若缩进使用空格，制表符宽度参数无效，缩进对应的空格个数和缩进宽度一致 TabWidth参数无效；一次缩进对应7个空格 IndentWidth: '7' TabWidth: '9' UseTab: 'Never' 若缩进使用制表符，当缩进对应的空格个数不小于制表符宽度，使用制表符替换对应个数个空格 一次缩进对应7个空格，不会被替换为制表符；两个缩进对应14个空格，会被替换为1个制表符加5个空格 IndentWidth: '7' TabWidth: '9' UseTab: 'Always' 一、定义格式化代码规则 # .clang-format 参考 YAML标记文件 作为项目的一部分，描述管理代码文件的统一格式 每行遵循格式 key: value 1. 设置受约束的开发语言 # Language: Cpp 如果项目中只一种开发语言，或者所有开发语言使用相同规范，可忽略该配置 2. 通用样式 # Google 一个制表符对应2个空格，大括号不在新行 BasedOnStyle: Google Microsoft 一个制表符对应4个空格，大括号在新行 BasedOnStyle: Microsoft 3. 缩进宽度 # IndentWidth: '4' 4. 缩进样式 # 空格 UseTab: Never 制表符 源文件中既有空格又有制表符 UseTab: Always 5.",content:"Overview # .clang-format .gitignore 参考 按个人习惯来，非建议 大括号 放在新行 缩进 使用制表符，缩进宽度和制表符宽度一致 虚幻引擎建议使用制表符，也可以使用空格 缩进、制表符和空格 # 缩进 indent 编写代码时，按下tab键，即按格式留出空位，用以控制格式 默认使用制表符 tab 因为制表符的宽度可设置，不同平台制表符的宽度不一，视觉上，查看代码会有不习惯的感觉；可在本地设置使用空格，即用空格替换制表符 制表符宽度和缩进宽度 若缩进使用空格，制表符宽度参数无效，缩进对应的空格个数和缩进宽度一致 TabWidth参数无效；一次缩进对应7个空格 IndentWidth: '7' TabWidth: '9' UseTab: 'Never' 若缩进使用制表符，当缩进对应的空格个数不小于制表符宽度，使用制表符替换对应个数个空格 一次缩进对应7个空格，不会被替换为制表符；两个缩进对应14个空格，会被替换为1个制表符加5个空格 IndentWidth: '7' TabWidth: '9' UseTab: 'Always' 一、定义格式化代码规则 # .clang-format 参考 YAML标记文件 作为项目的一部分，描述管理代码文件的统一格式 每行遵循格式 key: value 1. 设置受约束的开发语言 # Language: Cpp 如果项目中只一种开发语言，或者所有开发语言使用相同规范，可忽略该配置 2. 通用样式 # Google 一个制表符对应2个空格，大括号不在新行 BasedOnStyle: Google Microsoft 一个制表符对应4个空格，大括号在新行 BasedOnStyle: Microsoft 3. 缩进宽度 # IndentWidth: '4' 4. 缩进样式 # 空格 UseTab: Never 制表符 源文件中既有空格又有制表符 UseTab: Always 5. 制表符宽度 # 若缩进使用制表符，每6个空格替换一个制表符；当缩进宽度和制表符宽度不一致时，效果有点糟糕 TabWidth: '6' 6. 设置大括号位置 # 行尾 BreakBeforeBraces: Attach 新行 BreakBeforeBraces: Allman 7. 换行条件 # 为0时，按输入的实际情况显示 ColumnLimit: '140' 8. 向前缩进 # 控制访问说明符的缩进 AccessModifierOffset: '-4' 9. 头文件排序 # SortIncludes: false 10. 当语句较短时，是否允许写在单行 # AllowShortBlocksOnASingleLine: false 条件语句的执行部分为空，或只有一行语句时，可认为语句较短；为false则如下输出 while (true) { } while (true) { continue; } 11. 括号换行时，参数的对齐方式 # AlignAfterOpenBracket: Align 不对齐 DontAlign someLongFunction(argument1, argument2); Align someLongFunction(argument1, argument2); 12. 当函数语句较短时，是否允许写在单行 # AllowShortFunctionsOnASingleLine: Inline Inline 若函数体为空，允许；若函数在类内定义，允许。 InlineOnly 只允许一种情况：函数在类内定义。 Empty 只允许一种情况：函数体为空。 13. 指针和引用的对齐方式 # PointerAlignment: Right Right int *a; Left int* a; 二、Git仓库同步 # .gitignore 参考 告诉Git，同步时忽略的文件和文件夹 三、命名约定 # 虚幻编辑器 参考 虚幻编辑器 首 材质 M_ 材质实例 MI_ 基于C++的蓝图类 BP_ 动画蓝图 ABP_ 混合空间(1D) BS_ "}),e.add({id:16,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E6%8B%9F%E6%A6%B4%E5%BC%B9%E7%88%86%E7%82%B8/",title:"模拟榴弹爆炸",description:"Part 1 建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 Part 2 创建伤害来源 Dev/STDevDamageActor # 虚幻编辑器 STDevDamageActor，模拟榴弹爆炸 Actor 公有类 Part 3 准备工作 # C++ 屏蔽 ASTBaseCharacter::Tick中调用CharacterTakeDamage 添加头文件路径 ShootTraining/Source/ShootTraining/ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootTraining/Public/Player\u0026quot;, \u0026quot;ShootTraining/Public/Components\u0026quot;, \u0026quot;ShootTraining/Public/Dev\u0026quot; }); Part 4 实现 STDevDamageActor # C++ STDevDamageActor 一、添加可视化组件，使得伤害源可变换 # 添加 SceneComponent 数据成员 protected 蓝图可设置 UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent;	初始化 SceneComponent 函数成员 private 在构造函数中调用 void ASTDevDamageActor::InitSceneComponent() { SceneComponent = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(\u0026quot;SceneComponent\u0026quot;); SetRootComponent(SceneComponent); } 二、绘制球体，爆炸范围可视化 # 包含头文件 源文件 #include \u0026quot;DrawDebugHelpers.h\u0026quot; 球体半径和颜色 数据成员 protected 蓝图可设置 UPROPERTY(EditAnywhere) float Radius = 300.",content:"Part 1 建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 Part 2 创建伤害来源 Dev/STDevDamageActor # 虚幻编辑器 STDevDamageActor，模拟榴弹爆炸 Actor 公有类 Part 3 准备工作 # C++ 屏蔽 ASTBaseCharacter::Tick中调用CharacterTakeDamage 添加头文件路径 ShootTraining/Source/ShootTraining/ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootTraining/Public/Player\u0026quot;, \u0026quot;ShootTraining/Public/Components\u0026quot;, \u0026quot;ShootTraining/Public/Dev\u0026quot; }); Part 4 实现 STDevDamageActor # C++ STDevDamageActor 一、添加可视化组件，使得伤害源可变换 # 添加 SceneComponent 数据成员 protected 蓝图可设置 UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent;	初始化 SceneComponent 函数成员 private 在构造函数中调用 void ASTDevDamageActor::InitSceneComponent() { SceneComponent = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(\u0026quot;SceneComponent\u0026quot;); SetRootComponent(SceneComponent); } 二、绘制球体，爆炸范围可视化 # 包含头文件 源文件 #include \u0026quot;DrawDebugHelpers.h\u0026quot; 球体半径和颜色 数据成员 protected 蓝图可设置 UPROPERTY(EditAnywhere) float Radius = 300.0f; UPROPERTY(EditAnywhere) FColor SphereColor = FColor::Red; 绘制球体 函数成员 private 在Tick中调用，每帧都绘制球体 DrawDebugSphere 的第一个参数类型为 UWorld ，所以不用包含 UWorld 的头文件 void ASTDevDamageActor::DrawSphere() { DrawDebugSphere(GetWorld(), GetActorLocation(), Radius, 24, SphereColor); } 三、对伤害范围内 Actor 造成半径伤害 # 包含头文件 源文件 #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;Kismet/GameplayStatics.h\u0026quot; 伤害数值特征和半径伤害计算选项 数据成员 protected 蓝图可设置 UPROPERTY(EditAnywhere) float Damage = 10.0f; UPROPERTY(EditAnywhere) bool DoFullDamage = false; 对伤害范围内 Actor 造成半径伤害 函数成员 private 在Tick中调用 ApplyRadialDamage 的第一个参数类型为 UObject ，此时传入 UWorld ，需包含 UWorld 头文件 void ASTDevDamageActor::DevTakeDamage() { UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); } 在伤害处理函数 USTHealthComponent::OnTakeAnyDamage 中输出伤害值，验证 DoFullDamage 机制 UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;Damage: %.0f\u0026quot;), Damage); Part 5 在关卡中添加伤害源 # 虚幻编辑器 一、调整 BP_STBaseCharacter 的 Camera 组件位置 # 向上，向后 二、在关卡中添加 STDevDamageActor # 一个使用默认设置，根据 Character 到球心的距离计算伤害 另一个设置半径和颜色，处在伤害范围内受到伤害数值恒定（开销小） 调整 STDevDamageActor 的位置，效果图 三、验证 DoFullDamage # 处于蓝色球内，伤害值一致 处于红色球内，离球心越近，伤害值越大 球心在空中，跳跃也会缩短到球心的距离 四、伤害球内的所有Actor都会受到伤害 # "}),e.add({id:17,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6%E7%AF%87-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/",title:"插件篇 | 文件管理",description:"Overview # speedbar Emacs内置功能，可以浏览文件内符号 neotree 文件管理 treemacs 工作区管理，和tags文件协作时，亦支持浏览文件内符号 speedbar # (semantic-mode) ;; 使能mode，进行语义分析 (speedbar) ;; 打开文件目录 neotree # 安装 (use-package neotree :ensure t :config (global-set-key [f8] 'neotree-toggle) (setq neo-theme 'icons) ;; 无需安装all-the-icons ) 使用 操作 快捷键 上级目录 U 将光标所在目录设为根目录 C-c C-c 显示 / 隐藏 H 上一行 / 下一行 p / n 打开文件 SPC / RET 打开 / 关闭 目录 TAB 刷新目录 g 最大化 / 最小化 窗口 A 删除文件 C-c C-d treemacs # 安装 (use-package treemacs :ensure t :defer t :init (with-eval-after-load 'winum (define-key winum-keymap (kbd \u0026quot;M-0\u0026quot;) #'treemacs-select-window)) :config (progn ;;	(setq treemacs-show-cursor -1) (treemacs-resize-icons 15) (with-eval-after-load 'treemacs (define-key treemacs-mode-map [mouse-1] #'treemacs-single-click-expand-action)) ;; 单击打开文件 ) :bind (:map global-map (\u0026quot;M-0\u0026quot; .",content:"Overview # speedbar Emacs内置功能，可以浏览文件内符号 neotree 文件管理 treemacs 工作区管理，和tags文件协作时，亦支持浏览文件内符号 speedbar # (semantic-mode) ;; 使能mode，进行语义分析 (speedbar) ;; 打开文件目录 neotree # 安装 (use-package neotree :ensure t :config (global-set-key [f8] 'neotree-toggle) (setq neo-theme 'icons) ;; 无需安装all-the-icons ) 使用 操作 快捷键 上级目录 U 将光标所在目录设为根目录 C-c C-c 显示 / 隐藏 H 上一行 / 下一行 p / n 打开文件 SPC / RET 打开 / 关闭 目录 TAB 刷新目录 g 最大化 / 最小化 窗口 A 删除文件 C-c C-d treemacs # 安装 (use-package treemacs :ensure t :defer t :init (with-eval-after-load 'winum (define-key winum-keymap (kbd \u0026quot;M-0\u0026quot;) #'treemacs-select-window)) :config (progn ;;	(setq treemacs-show-cursor -1) (treemacs-resize-icons 15) (with-eval-after-load 'treemacs (define-key treemacs-mode-map [mouse-1] #'treemacs-single-click-expand-action)) ;; 单击打开文件 ) :bind (:map global-map (\u0026quot;M-0\u0026quot; . treemacs-select-window) (\u0026quot;C-x t 1\u0026quot; . treemacs-delete-other-windows) (\u0026quot;C-x t t\u0026quot; . treemacs) (\u0026quot;C-x t d\u0026quot; . treemacs-select-directory) (\u0026quot;C-x t B\u0026quot; . treemacs-bookmark) (\u0026quot;C-x t C-t\u0026quot; . treemacs-find-file) )) 1. 使用 # 创建工作区，以及设置工作区内项目 M-x 操作 函数 创建工作区 treemacs-create-workspace 添加项目 treemacs-add-project-to-workspace 切换工作区 treemacs-switch-workspace 配置主题 treemacs-load-theme 创建主题 treemacs-create-theme 修改主题 treemacs-modify-theme 操作 快捷键 操作 t h 显示/隐藏 隐藏文件 RET 在固定窗口打开文件 双击 在前一个窗口打开文件 2. 主题 # 安装 (use-package treemacs-all-the-icons :ensure t :config (treemacs-load-theme \u0026quot;all-the-icons\u0026quot;) ) 需要安装all-the-icons字体，无需安装all-the-icons 3. 自定义主题图标 # 图标使用all-the-icons或icons-in-terminal-re 查看文件类型的名称 (treemacs-icons-catalogue) 给出文件后缀，设置该类型文件图标 (defvar treemacs-custom-org-icon (all-the-icons-fileicon \u0026quot;org\u0026quot;)) ;;(defvar treemacs-custom-org-icon (all-the-icons-icon-for-file \u0026quot;name.org\u0026quot;)) (treemacs-define-custom-icon treemacs-custom-org-icon \u0026quot;org\u0026quot; \u0026quot;org_archive\u0026quot;) (defvar treemacs-custom-elisp-icon (all-the-icons-fileicon \u0026quot;elisp\u0026quot;)) ;;(defvar treemacs-custom-elisp-icon (all-the-icons-icon-for-file \u0026quot;name.el\u0026quot;)) (treemacs-define-custom-icon treemacs-custom-elisp-icon \u0026quot;el\u0026quot; \u0026quot;eln\u0026quot; \u0026quot;elc\u0026quot;) 通过文件类型名称设置图标 使用treemacs-all-the-icons-tab控制缩进 (treemacs-create-icon :icon (all-the-icons-octicon \u0026quot;file-directory\u0026quot;) :extensions (dir-closed)) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-directory\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (dir-closed dir-open) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot;%s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-directory\u0026quot; :v-adjust 0) treemacs-all-the-icons-tab) :extensions (root-closed root-open) :fallback 'same-as-icon) 创建主题 必须设置 root-open root-closed 的图标，其他类型未设置则无图标 使用all-the-icons (treemacs-create-theme \u0026quot;Use-all-the-icons\u0026quot; :config (progn (treemacs-create-icon :icon (format \u0026quot;%s%s\u0026quot; (all-the-icons-icon-for-file \u0026quot;name.org\u0026quot; :v-adjust 0) treemacs-all-the-icons-tab) :extensions (\u0026quot;org\u0026quot;)) (treemacs-create-icon :icon (format \u0026quot;%s%s\u0026quot; (all-the-icons-icon-for-file \u0026quot;name.el\u0026quot; :v-adjust 0) treemacs-all-the-icons-tab) :extensions (\u0026quot;el\u0026quot;)) (treemacs-create-icon :icon (format \u0026quot;%s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-directory\u0026quot; :v-adjust 0) treemacs-all-the-icons-tab) :extensions (dir-closed dir-open root-open root-closed)) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-fileicon \u0026quot;go\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;go\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-fileicon \u0026quot;markdownlint\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;markdown\u0026quot; \u0026quot;md\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-alltheicon \u0026quot;python\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;py\u0026quot; \u0026quot;pyc\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-code\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (fallback) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-code\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;png\u0026quot; \u0026quot;gif\u0026quot; \u0026quot;jpg\u0026quot; \u0026quot;jpeg\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-code\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;.gitignore\u0026quot; \u0026quot;cache\u0026quot; \u0026quot;apk\u0026quot; \u0026quot;pptx\u0026quot; \u0026quot;ppt\u0026quot; \u0026quot;xls\u0026quot; \u0026quot;xlsx\u0026quot; \u0026quot;pl\u0026quot; \u0026quot;dmg\u0026quot; \u0026quot;xmind\u0026quot; \u0026quot;desktop\u0026quot; \u0026quot;eld\u0026quot; \u0026quot;dap-breakpoints\u0026quot; ) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-code\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;.lsp-session-v1\u0026quot; \u0026quot;amx-items\u0026quot; \u0026quot;recentf\u0026quot; ) :fallback 'same-as-icon) )) (treemacs-load-theme \u0026quot;Use-all-the-icons\u0026quot;) 使用icons-in-terminal (treemacs-create-theme \u0026quot;Use-icons-in-terminal\u0026quot; :config (progn (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-fileicon \u0026quot;org\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;org\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-octicon \u0026quot;file-directory\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (root-open root-closed) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-faicon \u0026quot;folder-open\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (dir-open) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-faicon \u0026quot;folder\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (dir-closed) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-octicon \u0026quot;file\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;note\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-octicon \u0026quot;markdown\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;markdown\u0026quot; \u0026quot;md\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-fileicon \u0026quot;elisp\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;el\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-fileicon \u0026quot;python\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;py\u0026quot; \u0026quot;pyc\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-faicon \u0026quot;file-text\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (fallback) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-faicon \u0026quot;image\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;png\u0026quot; \u0026quot;gif\u0026quot; \u0026quot;jpg\u0026quot; \u0026quot;jpeg\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-octicon \u0026quot;file-text\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;.gitignore\u0026quot; \u0026quot;cache\u0026quot; \u0026quot;apk\u0026quot; \u0026quot;pptx\u0026quot; \u0026quot;ppt\u0026quot; \u0026quot;xls\u0026quot; \u0026quot;xlsx\u0026quot; \u0026quot;pl\u0026quot; \u0026quot;dmg\u0026quot; \u0026quot;xmind\u0026quot; \u0026quot;desktop\u0026quot; \u0026quot;eld\u0026quot; \u0026quot;dap-breakpoints\u0026quot; ) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-faicon \u0026quot;book\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;.lsp-session-v1\u0026quot; \u0026quot;amx-items\u0026quot; \u0026quot;recentf\u0026quot; ) :fallback 'same-as-icon) )) (treemacs-load-theme \u0026quot;Use-icons-in-terminal\u0026quot;) "}),e.add({id:18,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/markdown/",title:"Markdown",description:"代码框 # ```elisp ``` 插入图片 # ![img](/pic/在本地运行ShooterGame示例项目/运行效果.png) 插入连接 # [参考](https://learn.microsoft.com/zh-cn/cpp/cpp/conditional-operator-q?view=msvc-170) 下划线 # \u0026lt;u\u0026gt;ddd\u0026lt;/u\u0026gt; 换行 # \u0026lt;br\u0026gt; 分隔线 # --- 注释 # \u0026lt;!--哈哈我是注释，不会在浏览器中显示。--\u0026gt; ",content:"代码框 # ```elisp ``` 插入图片 # ![img](/pic/在本地运行ShooterGame示例项目/运行效果.png) 插入连接 # [参考](https://learn.microsoft.com/zh-cn/cpp/cpp/conditional-operator-q?view=msvc-170) 下划线 # \u0026lt;u\u0026gt;ddd\u0026lt;/u\u0026gt; 换行 # \u0026lt;br\u0026gt; 分隔线 # --- 注释 # \u0026lt;!--哈哈我是注释，不会在浏览器中显示。--\u0026gt; "}),e.add({id:19,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/vscode/",title:"VSCode",description:"快捷键 # 操作 快捷键 减小字体 Command\u0026ndash; 放大字体 Command-+ 文件内查找 Command-F 注释代码 Command-K Command-C 去注释 Command-K Command-U 使用clang-format # 参考 安装扩展C/C++，自动安装clang-format 首选项 \u0026gt; Text Editor \u0026gt; Formatting，勾选 Format On Save 保存文件时，应用格式 插件 # 类别 C++ C/C++ C/C++ Extension Pack C/C++ Themes C# C# 项目编译 CMake CMakeTools 代码调试 CodeLLDB 主题 Dracula Official SynthWave '84 其他 file-picker Mono Debug Emacs 自定义快捷键无法使用 ",content:"快捷键 # 操作 快捷键 减小字体 Command\u0026ndash; 放大字体 Command-+ 文件内查找 Command-F 注释代码 Command-K Command-C 去注释 Command-K Command-U 使用clang-format # 参考 安装扩展C/C++，自动安装clang-format 首选项 \u0026gt; Text Editor \u0026gt; Formatting，勾选 Format On Save 保存文件时，应用格式 插件 # 类别 C++ C/C++ C/C++ Extension Pack C/C++ Themes C# C# 项目编译 CMake CMakeTools 代码调试 CodeLLDB 主题 Dracula Official SynthWave '84 其他 file-picker Mono Debug Emacs 自定义快捷键无法使用 "}),e.add({id:20,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%B8%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%9E%8B/",title:"为游戏角色绑定模型",description:"Overview # 玩家控制的游戏角色 Character 游戏角色上级 PlayerController 关卡设置 GameModeBase DefaultPawnClass PlayerControllerClass 第三视角 Camera组件 Part 1 创建 Character 和 PlayController # 虚幻编辑器 一、创建 Player/STBaseCharacter # ACharacter 公有类 二、创建 Player/STPlayerController # APlayerController 公有类 Part 2 使用 Character 和 PlayController # C++ 一、查看头文件包含路径 # 源文件路径中有指明上级文件夹 Player 设置头文件搜索路径，之后可以不指明上级文件夹 ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootTraining/Public/Player\u0026quot; }); 二、使用 STBaseCharacter 和 STPlayerController # STGameModeBase 包含头文件 源文件 #include \u0026quot;STBaseCharacter.h\u0026quot; #include \u0026quot;STPlayerController.h\u0026quot; 设置使用类 函数成员 private 在默认构造函数中调用 void ASTGameModeBase::InitCharacterAndPlayerController() { DefaultPawnClass = ASTBaseCharacter::StaticClass(); PlayerControllerClass = ASTPlayerController::StaticClass(); } 实现默认构造函数 public ASTGameModeBase::ASTGameModeBase() { InitCharacterAndPlayerController(); } 三、添加 Camera 组件 # STBaseCharacter 前向声明 头文件 class UCameraComponent; 包含头文件 源文件 #include \u0026quot;Camera/CameraComponent.",content:"Overview # 玩家控制的游戏角色 Character 游戏角色上级 PlayerController 关卡设置 GameModeBase DefaultPawnClass PlayerControllerClass 第三视角 Camera组件 Part 1 创建 Character 和 PlayController # 虚幻编辑器 一、创建 Player/STBaseCharacter # ACharacter 公有类 二、创建 Player/STPlayerController # APlayerController 公有类 Part 2 使用 Character 和 PlayController # C++ 一、查看头文件包含路径 # 源文件路径中有指明上级文件夹 Player 设置头文件搜索路径，之后可以不指明上级文件夹 ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootTraining/Public/Player\u0026quot; }); 二、使用 STBaseCharacter 和 STPlayerController # STGameModeBase 包含头文件 源文件 #include \u0026quot;STBaseCharacter.h\u0026quot; #include \u0026quot;STPlayerController.h\u0026quot; 设置使用类 函数成员 private 在默认构造函数中调用 void ASTGameModeBase::InitCharacterAndPlayerController() { DefaultPawnClass = ASTBaseCharacter::StaticClass(); PlayerControllerClass = ASTPlayerController::StaticClass(); } 实现默认构造函数 public ASTGameModeBase::ASTGameModeBase() { InitCharacterAndPlayerController(); } 三、添加 Camera 组件 # STBaseCharacter 前向声明 头文件 class UCameraComponent; 包含头文件 源文件 #include \u0026quot;Camera/CameraComponent.h\u0026quot; 添加 Camera 组件 数据成员 protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \u0026quot;Components\u0026quot;) UCameraComponent *Camera; 初始化 Camera 组件 函数成员 private 在构造函数中调用 void ASTBaseCharacter::InitCameraComponent() { Camera = CreateDefaultSubobject\u0026lt;UCameraComponent\u0026gt;(\u0026quot;CameraComponent\u0026quot;); Camera-\u0026gt;SetupAttachment(GetRootComponent()); } Part 3 创建蓝图类 # 虚幻编辑器 一、查看 STGameModeBase 设置 # 二、创建 Content/Player/BP_STGameModeBase # 三、创建 Content/Player/BP_STBaseCharacter 和 Content/Player/BP_STPlayerController # 四、设置 BP_STGameModeBase # Part 4 绑定模型 # 虚幻编辑器 BP_STBaseCharacter 一、查看组件信息 # Capsule 组件 根组件，实现碰撞检测 Arrow 组件 角色的前进方向 Camera 组件 第三视角 Mesh 组件 骨骼网格体(Skeletal Mesh) Character Movement 组件 纯逻辑组件，负责游戏角色运动 二、为Mesh组件绑定骨骼网格体 # Mesh 绑定 HeroTPP 材质自动应用 HeroTPP 移动模型到合适位置，旋转模型与前进方向一致 三、实现第三视角 # 分离 Camera 组件和 Mesh 组件 运行效果图 "}),e.add({id:21,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E4%BC%A4%E5%AE%B3%E7%B1%BB%E5%9E%8B/",title:"使用伤害类型",description:"Part 1 创建伤害类型 # C++ 1. 创建 Dev/STFireDamageType # UDamageType 公有类 2. 创建 Dev/STIceDamageType # UDamageType 公有类 Part 2 为伤害来源添加伤害类型属性 # C++ Dev/STDevDamageActor 添加 DamamgeType 属性 protected 蓝图可设置 UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UDamageType\u0026gt; DamageType; 造成伤害时，传入 DamageType 函数成员 private 在Tick中调用 取消在Tick中调用DevTakeDamage void ASTDevDamageActor::DevTakeDamageWithDamageType() { UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); } Part 3 在 HealthComponent 输出伤害来源信息 # C++ STHealthComponent 在处理函数中，根据 DamageType 的具体类型，做出相应处理 包含头文件 #include \u0026quot;Dev/STFireDamageType.h\u0026quot; #include \u0026quot;Dev/STIceDamageType.h\u0026quot; 输出伤害来源信息 函数成员 private 在OnTakeAnyDamage中调用 void USTHealthComponent::HandleDamage(const UDamageType *DamageType) { if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !",content:"Part 1 创建伤害类型 # C++ 1. 创建 Dev/STFireDamageType # UDamageType 公有类 2. 创建 Dev/STIceDamageType # UDamageType 公有类 Part 2 为伤害来源添加伤害类型属性 # C++ Dev/STDevDamageActor 添加 DamamgeType 属性 protected 蓝图可设置 UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UDamageType\u0026gt; DamageType; 造成伤害时，传入 DamageType 函数成员 private 在Tick中调用 取消在Tick中调用DevTakeDamage void ASTDevDamageActor::DevTakeDamageWithDamageType() { UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); } Part 3 在 HealthComponent 输出伤害来源信息 # C++ STHealthComponent 在处理函数中，根据 DamageType 的具体类型，做出相应处理 包含头文件 #include \u0026quot;Dev/STFireDamageType.h\u0026quot; #include \u0026quot;Dev/STIceDamageType.h\u0026quot; 输出伤害来源信息 函数成员 private 在OnTakeAnyDamage中调用 void USTHealthComponent::HandleDamage(const UDamageType *DamageType) { if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !!!\u0026quot;)); } } } Part 4 查看 # 虚幻编辑器 一、为伤害来源设置 DamageType 属性 # DamageSphere-Red 选择 STFireDamageType DamageSphere-Blue 选择 STIceDamageType 二、查看日志 # 角色进入到 DamageSphere-Red ，去到处理函数 STFireDamageType 分支 角色进入到 DamageSphere-Blue ，去到处理函数 STIceDamageType 分支 "}),e.add({id:22,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/makefile/",title:"Makefile",description:"求C(n, k) = n! / (k! * (n - k)!) # 说明 combo(n, k) = C(n, k) fact(n) = n! fact.h // fact.h int fact(int); fact.cpp // fact.cpp #include \u0026quot;fact.h\u0026quot; int fact(int n) { int p = 1; for (int i = 1; i \u0026lt;= n; ++i) { p *= i; } return p; } combination.h // combination.h int combo(int n, int k); combination.cpp // combination.cpp #include \u0026quot;combination.h\u0026quot; #include \u0026quot;fact.h\u0026quot; int combo(int n, int k) { return fact(n) / fact(n-k) / fact(k); } main.",content:"求C(n, k) = n! / (k! * (n - k)!) # 说明 combo(n, k) = C(n, k) fact(n) = n! fact.h // fact.h int fact(int); fact.cpp // fact.cpp #include \u0026quot;fact.h\u0026quot; int fact(int n) { int p = 1; for (int i = 1; i \u0026lt;= n; ++i) { p *= i; } return p; } combination.h // combination.h int combo(int n, int k); combination.cpp // combination.cpp #include \u0026quot;combination.h\u0026quot; #include \u0026quot;fact.h\u0026quot; int combo(int n, int k) { return fact(n) / fact(n-k) / fact(k); } main.cpp // main.cpp #include \u0026lt;iostream\u0026gt; #include \u0026quot;combination.h\u0026quot; #include \u0026quot;fact.h\u0026quot; using std::cout; using std::endl; int main() { for (int i = 1; i \u0026lt; 10; ++i) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;:\u0026quot; \u0026lt;\u0026lt; fact(i) \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; combo(10, 3) \u0026lt;\u0026lt; endl; return 0; } 编写makefile # g++ 查询单个文件依赖 g++ -MM main.cpp 批量查询依赖 g++ -MM *cpp makefile main: main.o fact.o combination.o g++ -o main main.o fact.o combination.o combination.o: combination.cpp combination.h fact.h g++ -c combination.cpp fact.o: fact.cpp fact.h g++ -c fact.cpp main.o: main.cpp combination.h fact.h g++ -c main.cpp Emacs 编译命令 # (compile) 命令 make -p # g++ main.cpp fact.cpp combination.cpp "}),e.add({id:23,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/javascrpit/",title:"JavaScrpit",description:"foreach # 中断foreach循环不能使用break 获取窗口和显示器屏幕参数 # 参考 窗口 # 浏览器窗口可以改变大小 验证情况 内部高度 window.innerHeight o 内部宽度 window.innerWidth 外部高度 window.outerheight 外部宽度 window.outerwidth 显示器屏幕 # 验证情况 显示器屏幕高度，除windows任务栏以外 screen.availHeight 显示器屏幕宽度，除windows任务栏以外 screen.availWidth 显示器屏幕高度 screen.height 显示器屏幕宽度 screen.width 传参 # runoob 不需要给出参数类型 function myFunction(x, y = 10) { // y is 10 if not passed or undefined return x + y; } myFunction(0, 2) // 输出 2 myFunction(5); // 输出 15, y 参数的默认值 处理滚动 # 参考 注册 # 添加监听事件 滚动 window 所有滚动都会触发 window.",content:"foreach # 中断foreach循环不能使用break 获取窗口和显示器屏幕参数 # 参考 窗口 # 浏览器窗口可以改变大小 验证情况 内部高度 window.innerHeight o 内部宽度 window.innerWidth 外部高度 window.outerheight 外部宽度 window.outerwidth 显示器屏幕 # 验证情况 显示器屏幕高度，除windows任务栏以外 screen.availHeight 显示器屏幕宽度，除windows任务栏以外 screen.availWidth 显示器屏幕高度 screen.height 显示器屏幕宽度 screen.width 传参 # runoob 不需要给出参数类型 function myFunction(x, y = 10) { // y is 10 if not passed or undefined return x + y; } myFunction(0, 2) // 输出 2 myFunction(5); // 输出 15, y 参数的默认值 处理滚动 # 参考 注册 # 添加监听事件 滚动 window 所有滚动都会触发 window.addEventListener('scroll', () =\u0026gt; { // 处理滚动事件 }); Element 需要检查元素有效性；只在元素滚动时触发 let fullToc = document.querySelector('.docs-toc'); if (fullToc != null) { fullToc.addEventListener('scroll', () =\u0026gt; { // 处理滚动事件 }); } 给目标元素的onscroll属性绑定事件处理函数 页面滚动触发 window.onscroll = function () { // 处理滚动事件 }; [未验证] document.body.onscroll同window.onscroll [待验证] document.document.Element和document.body的区别，其scrollTop、clientHeight、scrollHeight参数 出处 设置元素滚动偏移 # 参数 说明 scrollLeft 和左侧偏移量 scrollTop 和顶部偏移量 滚动结束后处理 # 定时器 参考1 参考2 let timer = null; let fullToc = document.querySelector('.docs-toc'); if (fullToc != null) { fullToc.addEventListener('scroll', () =\u0026gt; { clearTimeout(timer); timer = setTimeout(function () { // 处理 }, 400); }); } 周期性处理滚动事件 [未验证] 节流 let scrolling = false; window.onscroll = () =\u0026gt; { scrolling = true; }; setInterval(() =\u0026gt; { if (scrolling) { scrolling = false; // 处理逻辑 } },300); .和# # class=\u0026quot;a\u0026quot; .a id=\u0026quot;b\u0026quot; #b querySelectorAll # runoob 返回NodeList类型对象 elementList = document.querySelectorAll('.my-toc a.active'); // .my-toc中，a标签，其包含类active elementList = document.querySelectorAll('.my-toc a'); // .my-toc中，a标签 subItem = document.querySelector(`.my-toc a[href=\u0026quot;#${id}\u0026quot;]`); //.my-toc中，href属性为${id}的a标签 document.querySelectorAll('h0[id],h1[id],h2[id],h3[id]'); // 所有有id属性的h0,h1,h2,h3标题 NodeList类型 # 获取元素个数 let count = document.querySelectorAll('.my-toc a').length; 按索引访问元素 参考 let res = document.querySelectorAll('.my-toc a'); if (res.length \u0026gt;= 1) { let active_heading = res.item(0); } 遍历元素 let count = 0, current = 0; document.querySelectorAll('.my-toc a').forEach((a) =\u0026gt; { if (a == active_heading) { current = count; // console.log(\u0026quot;current heading\u0026quot;, a); } ++count; }); "}),e.add({id:24,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%89%8D%E5%90%8E%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8/",title:"实现游戏角色前后左右移动",description:"Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 1. 轴映射 # 连续 如 前后左右移动 2. 动作映射 # 离散 如 跳跃，装弹，更换武器 Part 2 实现前后左右移动逻辑 # C++ STBaseCharacter 添加头文件 源文件 #include \u0026quot;Components/InputComponent.h\u0026quot; 实现回调函数 函数成员 private void ASTBaseCharacter::MoveForward(float Amount) { AddMovementInput(GetActorForwardVector(), Amount); } void ASTBaseCharacter::MoveRight(float Amount) { AddMovementInput(GetActorRightVector(), Amount); } 绑定函数描述和回调函数 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::BindMoveHandler(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;MoveForward\u0026quot;, this, \u0026amp;ASTBaseCharacter::MoveForward); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;MoveRight\u0026quot;, this, \u0026amp;ASTBaseCharacter::MoveRight); } ",content:"Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 1. 轴映射 # 连续 如 前后左右移动 2. 动作映射 # 离散 如 跳跃，装弹，更换武器 Part 2 实现前后左右移动逻辑 # C++ STBaseCharacter 添加头文件 源文件 #include \u0026quot;Components/InputComponent.h\u0026quot; 实现回调函数 函数成员 private void ASTBaseCharacter::MoveForward(float Amount) { AddMovementInput(GetActorForwardVector(), Amount); } void ASTBaseCharacter::MoveRight(float Amount) { AddMovementInput(GetActorRightVector(), Amount); } 绑定函数描述和回调函数 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::BindMoveHandler(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;MoveForward\u0026quot;, this, \u0026amp;ASTBaseCharacter::MoveForward); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;MoveRight\u0026quot;, this, \u0026amp;ASTBaseCharacter::MoveRight); } "}),e.add({id:25,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%B7%BB%E5%8A%A0%E6%AD%BB%E4%BA%A1%E9%80%BB%E8%BE%91/",title:"为游戏角色添加死亡逻辑",description:"Part 1 使用委托：当生命值发生改变时，更新 TextRender 文本 # C++ 一、屏蔽当前 HealthText 的设置 # 之前，每帧都会根据生命值设置 TextRender 组件 ASTBaseCharacter::Tick中，屏蔽DisplayHealthText 在ASTBaseCharacter::BeginPlay中，调用DisplayHealthText初始化设置 先调用Component的BeginPlay，而后调用Character的BeginPlay 当前委托机制中，Character在BeginPlay中注册服务。如果由HealthComponent的BeginPlay中初始化生命值并广播，此时Character还未注册服务，广播在前，注册在后，则Character无法收到通知并初始化 TextRender 组件文本 二、使用委托修改HealthText，服务端修改 # Components/STHealthComponent OnTakeAnyDamage中，屏蔽HandleDamage 伤害类型仅做示例 定义委托类型 头文件 多播 仅C++ DECLARE_MULTICAST_DELEGATE(FOnHealthChanged) 添加委托类型成员 数据成员 public FOnHealthChanged OnHealthChanged; 生命值改变时，通知客户端 OnTakeAnyDamage OnHealthChanged.Broadcast(); 三、使用委托修改HealthText，客户端修改 # STBaseCharacter 处理函数 函数成员 private void ASTBaseCharacter::OnHealthChanged() { DisplayHealthText(); } 注册处理函数 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::BindOnHealthChanged() { Health-\u0026gt;OnHealthChanged.AddUObject(this, \u0026amp;ASTBaseCharacter::OnHealthChanged); } Part 2 若Character死亡，不再造成伤害 # C++ 一、判断Character死亡 # 函数成员 public 蓝图可调用，const函数 UFUNCTION(BlueprintCallable) bool IsDead() const { return Health \u0026lt;= 0.",content:"Part 1 使用委托：当生命值发生改变时，更新 TextRender 文本 # C++ 一、屏蔽当前 HealthText 的设置 # 之前，每帧都会根据生命值设置 TextRender 组件 ASTBaseCharacter::Tick中，屏蔽DisplayHealthText 在ASTBaseCharacter::BeginPlay中，调用DisplayHealthText初始化设置 先调用Component的BeginPlay，而后调用Character的BeginPlay 当前委托机制中，Character在BeginPlay中注册服务。如果由HealthComponent的BeginPlay中初始化生命值并广播，此时Character还未注册服务，广播在前，注册在后，则Character无法收到通知并初始化 TextRender 组件文本 二、使用委托修改HealthText，服务端修改 # Components/STHealthComponent OnTakeAnyDamage中，屏蔽HandleDamage 伤害类型仅做示例 定义委托类型 头文件 多播 仅C++ DECLARE_MULTICAST_DELEGATE(FOnHealthChanged) 添加委托类型成员 数据成员 public FOnHealthChanged OnHealthChanged; 生命值改变时，通知客户端 OnTakeAnyDamage OnHealthChanged.Broadcast(); 三、使用委托修改HealthText，客户端修改 # STBaseCharacter 处理函数 函数成员 private void ASTBaseCharacter::OnHealthChanged() { DisplayHealthText(); } 注册处理函数 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::BindOnHealthChanged() { Health-\u0026gt;OnHealthChanged.AddUObject(this, \u0026amp;ASTBaseCharacter::OnHealthChanged); } Part 2 若Character死亡，不再造成伤害 # C++ 一、判断Character死亡 # 函数成员 public 蓝图可调用，const函数 UFUNCTION(BlueprintCallable) bool IsDead() const { return Health \u0026lt;= 0.0f; } 二、重新实现的OnTakeAnyDamage # Character生命值不会小于0：OnTakeAnyDamage中，若伤害的数量特征不大于0，或者当前生命值不大于0，无法继续对Character造成伤害 void USTHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) { if (Damage \u0026lt;= 0.0f || IsDead()) return; // UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;Damage: %.0f\u0026quot;), Damage); // Health -= Damage; Health = FMath::Clamp(Health - Damage, 0.0f, MaxHealth); // HandleDamage(DamageType); OnHealthChanged.Broadcast(); } Part 3 若Character死亡，销毁Character # C++ 使用委托完成。当生命值发生改变时修改HealthText文本，当生命值变为0时销毁Character，一码归一码 一、服务端设置 # STHealthComponent 定义委托类型 DECLARE_MULTICAST_DELEGATE(FOnDeath) 添加委托类型数据成员 public FOnDeath OnDeath; 如Character死亡，通知客户端 函数成员 private 在OnTakeAnyDamage中调用 void USTHealthComponent::InformClientOnDeath() { if (IsDead()) { OnDeath.Broadcast(); } }	二、设置客户端 # STBaseCharacter 判断CharacterMovementComponent有效性 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::CheckCharacterMovement() { check(GetCharacterMovement()); } 实现处理函数：玩家失去对游戏角色的控制，定时销毁Character 函数成员 private void ASTBaseCharacter::OnDeath() { GetCharacterMovement()-\u0026gt;DisableMovement(); SetLifeSpan(5.0f); } 注册服务 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::BindOnDeath() { Health-\u0026gt;OnDeath.AddUObject(this, \u0026amp;ASTBaseCharacter::OnDeath); } Part 4 创建死亡动画剪辑 # 虚幻编辑器 参考之前的跳跃动画，跑步动画，转向动画，均对应状态机中的一个状态。如果当事件发生时，每个状态都可迁移到死亡状态，想想都觉得麻烦。 动画剪辑 AnimMontage 可以将多个动画组合播放。我们可以把希望连续播放的动画添加到时间线 timeline ，在代码或蓝图中播放动画剪辑。 使用动画剪辑 AnimMontage 资产，当事件发生时，播放死亡动画。 Slot 若此时有动画剪辑正在播放，输出输入动画和动画剪辑的拼接；若无动画剪辑在播放，输出输入动画 一、创建AnimMontage资产 # 命名参考 跑步动画资产 路径 ExternalContent/Animations/TTP_Animations/Death 选中跑步动画资产，右键 \u0026gt; Create \u0026gt; Create AnimMontage \u0026gt; 命名为AM_Death 移动到Content/Player/Animations/路径下 二、设置动画蓝图的输入 # ABP_BaseCharacter \u0026gt; AnimGraph 在Locomotion和OutputPose之间添加Slot 注意，Slot和AM_Death中分组应该一致 SlotName DefaultGroup.DefaultSlot Montage 三、设置动画剪辑 # AM_Death 死亡动画结束后，不再播放其他动画 Asset Details \u0026gt; BlendOptions \u0026gt; EnableAutoBlendOut，取消勾选 Part 5 Character死亡时，播放动画剪辑 # C++ STBaseCharacter 动画剪辑(AnimMontage)在C++中的类型为UAnimMontage 一、添加可配置动画剪辑属性 # 数据成员 protected 原型可设置 UPROPERTY(EditDefaultsOnly) UAnimMontage *DeathAnimMontage; 二、在Character死亡时，播放动画剪辑 # 在OnDeath开始处添加如下语句 PlayAnimMontage(DeathAnimMontage); Part 6 查看 # 虚幻编辑器 一、设置游戏角色死亡时播放的动画剪辑 # BP_STBaseCharacter AM_Death 二、效果图 # 禁止移动Character之后，销毁Character之前，仍可以移动摄像机；即，可以旋转Character(TurnAround) "}),e.add({id:26,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/sublime/",title:"Sublime",description:"快捷键 # 操作 分屏 View \u0026gt; Layout \u0026gt; 默认Single，选择Columns: 2 右侧分屏 Option-Command-N；2-4 下方分屏 Option-Command-Shift-N；2-3 右侧分屏和下方分屏不能同时进行 分屏复原 Option-Command-1 Grid分屏 田字型；Option-Command-5 打开命令面板 Windows Control-P MacOS Command-P 行号跳转 Control-G ",content:"快捷键 # 操作 分屏 View \u0026gt; Layout \u0026gt; 默认Single，选择Columns: 2 右侧分屏 Option-Command-N；2-4 下方分屏 Option-Command-Shift-N；2-3 右侧分屏和下方分屏不能同时进行 分屏复原 Option-Command-1 Grid分屏 田字型；Option-Command-5 打开命令面板 Windows Control-P MacOS Command-P 行号跳转 Control-G "}),e.add({id:27,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A7%86%E8%A7%92%E6%97%8B%E8%BD%AC/",title:"实现游戏角色视角旋转",description:"Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 1. 抬头，低头 # 鼠标垂直方向的移动决定抬头角度，绕Y轴旋转 函数描述 键位 LookUp MouseY 2. 环顾四周 # 鼠标水平方向的移动决定身体旋转角度，绕Z轴旋转 函数描述 键位 TurnAround MouseX Part 2 实现视角旋转逻辑1 # C++ 一、搭建框架 # 添加空函数并绑定函数描述和回调函数，之后再实现函数逻辑 添加空函数 函数成员 函数体为空 private void LookUp(float Amount); void TurnAround(float Amount); 绑定函数描述和回调函数 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::InitCameraRotate(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTBaseCharacter::TurnAround); } 二、添加静态日志类型 # DEFINE_LOG_CATEGORY_STATIC(LogBaseCharacter, All, All) 三、实现回调函数 # void ASTBaseCharacter::LookUp(float Amount) { AddControllerPitchInput(Amount); UE_LOG(LogBaseCharacter, Log, TEXT(\u0026quot;LookUp Amount: %f\u0026quot;), Amount); } void ASTBaseCharacter::TurnAround(float Amount) { AddControllerYawInput(Amount); } Part 3 配置 Camera 组件在垂直方向上移动 # 虚幻编辑器 水平移动鼠标时，游戏角色和摄像机一齐左右旋转 垂直移动鼠标时，游戏角色无旋转 一、使 Camera 组件跟随 Pawn 旋转 # BP_STBaseCharacter 选中Camera组件 \u0026gt; 细节面板 \u0026gt; CameraOptions \u0026gt; 使能UsePawnControlRotation 保存并编译 此时向下移动鼠标时，摄像机向上旋转，向上移动鼠标时，摄像机向下旋转 查看日志，鼠标向上移动时，Amount的确是正数 二、调试 InputPitchScale # BP_PlayerController 参考 引擎版本 5.",content:"Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 1. 抬头，低头 # 鼠标垂直方向的移动决定抬头角度，绕Y轴旋转 函数描述 键位 LookUp MouseY 2. 环顾四周 # 鼠标水平方向的移动决定身体旋转角度，绕Z轴旋转 函数描述 键位 TurnAround MouseX Part 2 实现视角旋转逻辑1 # C++ 一、搭建框架 # 添加空函数并绑定函数描述和回调函数，之后再实现函数逻辑 添加空函数 函数成员 函数体为空 private void LookUp(float Amount); void TurnAround(float Amount); 绑定函数描述和回调函数 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::InitCameraRotate(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTBaseCharacter::TurnAround); } 二、添加静态日志类型 # DEFINE_LOG_CATEGORY_STATIC(LogBaseCharacter, All, All) 三、实现回调函数 # void ASTBaseCharacter::LookUp(float Amount) { AddControllerPitchInput(Amount); UE_LOG(LogBaseCharacter, Log, TEXT(\u0026quot;LookUp Amount: %f\u0026quot;), Amount); } void ASTBaseCharacter::TurnAround(float Amount) { AddControllerYawInput(Amount); } Part 3 配置 Camera 组件在垂直方向上移动 # 虚幻编辑器 水平移动鼠标时，游戏角色和摄像机一齐左右旋转 垂直移动鼠标时，游戏角色无旋转 一、使 Camera 组件跟随 Pawn 旋转 # BP_STBaseCharacter 选中Camera组件 \u0026gt; 细节面板 \u0026gt; CameraOptions \u0026gt; 使能UsePawnControlRotation 保存并编译 此时向下移动鼠标时，摄像机向上旋转，向上移动鼠标时，摄像机向下旋转 查看日志，鼠标向上移动时，Amount的确是正数 二、调试 InputPitchScale # BP_PlayerController 参考 引擎版本 5.1 之前，可以在 PlayerController蓝图类 的细节面板查看 InputPitchScale 打印 InputPitchScale 为负数，解释为何向上移动鼠标， Camera组件 向下旋转 尝试设置 InputPitchScale 为正数 向上移动鼠标， Camera 组件向上旋转 InputPitchScale InputYawScale InputRollScale 的绝对值对应旋转速度 去除 BP_STPlayerController 中的打印和设置 去除C++中 LookUp 中的日志打印 三、将 LookUp 的 Scale 改为-1 # 此时，向上移动鼠标， Camera 组件向上旋转 可以注意到，垂直方向移动鼠标时，旋转的中心点是 Camera 组件 Part 4 添加 SpringArm 组件 # C++ STBaseCharacter 前向声明 头文件 class USpringArmComponent; 包含头文件 源文件 #include \u0026quot;GameFrameWork/SpringArmComponent.h\u0026quot; 添加 SpringArm 组件 数据成员 protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \u0026quot;Components\u0026quot;) USpringArmComponent *SpringArm; 初始化 SpringArm 组件 函数成员 private 在默认构造函数中调用 设置原型默认值 void ASTBaseCharacter::InitSpringArmAndCamera() { SpringArm = CreateDefaultSubobject\u0026lt;USpringArmComponent\u0026gt;(\u0026quot;SpringArmComponent\u0026quot;); SpringArm-\u0026gt;SetupAttachment(GetRootComponent());	SpringArm-\u0026gt;bUsePawnControlRotation = true; Camera = CreateDefaultSubobject\u0026lt;UCameraComponent\u0026gt;(\u0026quot;CameraComponent\u0026quot;); Camera-\u0026gt;SetupAttachment(SpringArm); Camera-\u0026gt;bUsePawnControlRotation = false; } 不再在默认构造函数中调用InitCameraComponent Part 5 配置 SpringArm 组件 # 虚幻编辑器 BP_STBaseCharacter 一、查看 SpringArm 组件 # 二、关于 bUsePawnControlRotation # UCameraComponent 和 USpringArmComponent 均有该数据成员 在代码中设置 bUsePawnControlRotation ，设置的是类数据成员初始值 在蓝图编辑器中，对基于C++类的蓝图类数据成员恢复默认值，得到类数据成员初始值 已设置不会恢复默认值 当前， BP_BaseCharacter 中， SpringArm 组件的 bUsePawnControlRotation 使用默认值，而 Camera 组件的 bUsePawnControlRotation 仍使用我们之前设置的值 三、设置 SpringArm 组件和 Camera 组件的相对变换 # 清除 Camera 组件的相对变换 设置 SpringArm 组件 臂长 偏移 四、 Camera 组件和 SpringArm 组件的 bUsePawnControlRotation 生效问题 # 二者均为 true 时， SpringArm 组件的生效， Camera 组件以 Character 为中心绕Y轴旋转 二者均为 false ， Camera 组件不可绕Y轴旋转 仅 Camera 组件的为true，摄像机以 Camera 组件为中心绕Y轴旋转 去除 Camera 组件的 bUsePawnControlRotation 使能 Part 6 为 Character 绑定动画 # 虚幻编辑器 BP_STBaseCharacter 一、绑定动画 # 选中Mesh组件 \u0026gt; Details \u0026gt; Animation 设置AnimationMode为UseAnimationAsset 设置为AnimToPlay为Run_Fwd 编译并保存 二、效果图 # Part 7 实现视角旋转逻辑2 # C++ 一、比对 LookUp TurnAround AddControllerPitchInput 和 AddControllerYawInput # 函数签名一致 void ASTBaseCharacter::LookUp(float Amount) { AddControllerPitchInput(Amount); //	UE_LOG(LogBaseCharacter, Log, TEXT(\u0026quot;LookUp Amount: %f\u0026quot;), Amount); } void ASTBaseCharacter::TurnAround(float Amount) { AddControllerYawInput(Amount); } void ASTBaseCharacter::InitCameraRotate(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;Lookup\u0026quot;, this, \u0026amp;ASTBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTBaseCharacter::TurnAround); } 二、函数描述直接绑定 AddControllerPitchInput 和 AddControllerYawInput # 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::InitCameraRotateFinal(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;Lookup\u0026quot;, this, \u0026amp;ASTBaseCharacter::AddControllerPitchInput); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTBaseCharacter::AddControllerYawInput); } 不再在SetupPlayerInputComponent中调用InitCameraRotate "}),e.add({id:28,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E8%A7%82%E5%AF%9F%E8%A7%86%E8%A7%92/",title:"添加观察视角",description:"Overview # 观察视角的实现，对应一个APawn派生类，ASpectatorPawn。关卡的默认类型里，观察者类即使用ASpectatorPawn。 场景中的SpectatorPawn，即漂浮的摄像机，可以前后左右上下移动，键位控制，可以旋转，由鼠标控制。 观察视角的存在，使得玩家死亡后，仍能继续观看游戏。当Character死亡并销毁，Controller无其他Pawn可控制。当Character死亡后，使Controller切换到ASpectatorPawn对象。 本小节使用默认的观察者类，所做的修改在STBaseCharacter中。 Part 1 Character死亡后，切换到观察视角 # C++ STBaseCharacter 添加头文件 先前我们已设置STBaseCharacter使用STPlayerController类。 APawn::Controller成员和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STPlayerController的 #include \u0026quot;GameFramework/Controller.h\u0026quot; Character死亡时，使用观察视角 private 在Character死亡处理函数OnDeath中调用 void ASTBaseCharacter::SwitchToSpectatorPawn() { if (Controller) { Controller-\u0026gt;ChangeState(NAME_Spectating); } } Part 2 查看 # 虚幻编辑器 查看WorldSetting中，GameMode使用的Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 Character死亡后，世界大纲新增SpectatorPawn1 因为Character死亡的处理函数中，立即切换到SpectatorPawn，在Character销毁之前，无法继续操作Character，也就无法旋转Character的Camera ",content:"Overview # 观察视角的实现，对应一个APawn派生类，ASpectatorPawn。关卡的默认类型里，观察者类即使用ASpectatorPawn。 场景中的SpectatorPawn，即漂浮的摄像机，可以前后左右上下移动，键位控制，可以旋转，由鼠标控制。 观察视角的存在，使得玩家死亡后，仍能继续观看游戏。当Character死亡并销毁，Controller无其他Pawn可控制。当Character死亡后，使Controller切换到ASpectatorPawn对象。 本小节使用默认的观察者类，所做的修改在STBaseCharacter中。 Part 1 Character死亡后，切换到观察视角 # C++ STBaseCharacter 添加头文件 先前我们已设置STBaseCharacter使用STPlayerController类。 APawn::Controller成员和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STPlayerController的 #include \u0026quot;GameFramework/Controller.h\u0026quot; Character死亡时，使用观察视角 private 在Character死亡处理函数OnDeath中调用 void ASTBaseCharacter::SwitchToSpectatorPawn() { if (Controller) { Controller-\u0026gt;ChangeState(NAME_Spectating); } } Part 2 查看 # 虚幻编辑器 查看WorldSetting中，GameMode使用的Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 Character死亡后，世界大纲新增SpectatorPawn1 因为Character死亡的处理函数中，立即切换到SpectatorPawn，在Character销毁之前，无法继续操作Character，也就无法旋转Character的Camera "}),e.add({id:29,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%B8%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%B7%BB%E5%8A%A0%E5%90%91%E5%89%8D%E8%B7%91%E6%AD%A5%E5%8A%A8%E7%94%BB/",title:"为游戏角色添加向前跑步动画",description:"Overview # 虚幻编辑器 动画随着 Character 运动速度变化。 brush 最简单的可编辑几何体，我们可以修改其顶点位置，调整其他参数，然后将其转换成静态网格体 CharacterMovementComponent 负责 Character 运动，其各种属性均和 Character 运动有关 一、重新设置平台 # 从场景中移除Floor 添加 Geometry/Box 恢复默认位置，设置 brush 长宽高 二、Character运动速度上限 # BP_STBaseCharacter CharacterMovementComponent 选择CharacterMovement组件 \u0026gt; 细节面板 \u0026gt; Character Movement: Walking \u0026gt; MaxWalkSpeed MaxWalkSpeed 即 Character 的最大运动速度，单位 cm/s 虚幻引擎里的步长使用 cm 修改 MaxWalkSpeed ，当速度改为 1600 时，可以看到单位时间内移动的距离增加，而跑步动画没有对应的加速过程 三、打印实时速度 # BP_STBaseCharacter EventGraph 获得Character速度 GetVelocity函数 获得Actor各个方向上的速度，保存在FVector中 获得速度标量 FVector::VectorLength 在屏幕上输出实时速度 PrintString 使用 AddOnScreenDebugMessage 移除打印 四、创建动画蓝图 # Animation Blueprint 动画蓝图和 Skeleton Mesh 有关 创建文件夹 Content/Players/Animations 动画蓝图命名：ABP_打头 方法一：基于 Skeleton Mesh 创建动画蓝图 # 选中ExternalContent/Characters/HeroTPP/HeroTPP \u0026gt; 右键 \u0026gt; Create \u0026gt; AnimBlueprint 方法二：在指定位置创建动画蓝图 # 去到 Content/Player/Animations ，右键 \u0026gt; Animation \u0026gt; 选择Animation Blueprint 选择 HeroTPP_Skeleton ，命名为 ABP_BaseCharacter 五、在蓝图编辑器中查看动画蓝图 # ABP_BaseCharacter 1.",content:"Overview # 虚幻编辑器 动画随着 Character 运动速度变化。 brush 最简单的可编辑几何体，我们可以修改其顶点位置，调整其他参数，然后将其转换成静态网格体 CharacterMovementComponent 负责 Character 运动，其各种属性均和 Character 运动有关 一、重新设置平台 # 从场景中移除Floor 添加 Geometry/Box 恢复默认位置，设置 brush 长宽高 二、Character运动速度上限 # BP_STBaseCharacter CharacterMovementComponent 选择CharacterMovement组件 \u0026gt; 细节面板 \u0026gt; Character Movement: Walking \u0026gt; MaxWalkSpeed MaxWalkSpeed 即 Character 的最大运动速度，单位 cm/s 虚幻引擎里的步长使用 cm 修改 MaxWalkSpeed ，当速度改为 1600 时，可以看到单位时间内移动的距离增加，而跑步动画没有对应的加速过程 三、打印实时速度 # BP_STBaseCharacter EventGraph 获得Character速度 GetVelocity函数 获得Actor各个方向上的速度，保存在FVector中 获得速度标量 FVector::VectorLength 在屏幕上输出实时速度 PrintString 使用 AddOnScreenDebugMessage 移除打印 四、创建动画蓝图 # Animation Blueprint 动画蓝图和 Skeleton Mesh 有关 创建文件夹 Content/Players/Animations 动画蓝图命名：ABP_打头 方法一：基于 Skeleton Mesh 创建动画蓝图 # 选中ExternalContent/Characters/HeroTPP/HeroTPP \u0026gt; 右键 \u0026gt; Create \u0026gt; AnimBlueprint 方法二：在指定位置创建动画蓝图 # 去到 Content/Player/Animations ，右键 \u0026gt; Animation \u0026gt; 选择Animation Blueprint 选择 HeroTPP_Skeleton ，命名为 ABP_BaseCharacter 五、在蓝图编辑器中查看动画蓝图 # ABP_BaseCharacter 1. 事件图表 # EventGraph 处理各种动画事件 像使用 Tick 一样使用 EventBlueprintUpdateAnimation 2. 动画图表 # AnimGraph 处理所有动画 可以将动画资产作为 OutputPose 的输入 将 Run_Fwd 作为 OutputPose 的输入 设置 Run_Fwd 重复播放 选中Run_Fwd \u0026gt; Details \u0026gt; Settings \u0026gt; 使能 LoopAnimation 3. 动画资产窗口 # AssetBrowser 可以从 Window \u0026gt; AssetBrowser 打开，罗列了 SkeletonMesh 所有相关动画 六、让Character使用动画蓝图 # BP_STBaseCharacter ABP_BaseCharacter 之前 AnimationMode 的设置是 UseAnimationAsset ，而后选择 Run_Fwd 设置 AnimationMode 为 UseAnimationBlueprint BP_STBaseCharacter \u0026gt; Details \u0026gt; Animation \u0026gt; AnimationMode，选择 UseAnimationBlueprint 使用 ABP_BaseCharacter Animation \u0026gt; AnimClass，选择ABP_BaseCharacter 七、查看动画资产 # Run_Fwd 去到Content/ExternalContent/Animations/TTP_Animations 双击 Run_Fwd 可在 AssetBrowser 中选择其他动画 八、创建 混合空间 资产 # Blend Space 目标是，速度从 0 - 600 ，动画从 Idle 过渡到 Run_Fwd 动画混合 Animation Blend 流畅地从一个动画切入到另一个动画 混合空间 能在两个骨骼动画之间创建过渡动画 使用插值来得到动画姿势的中间值 和 Skeleton Mesh 有关 一维混合空间 Blend Space 1D 命名 混合空间 和 混合空间1D 均以BS_打头 1. 创建 BS_Locomotion # 去到Content/Player/Animations，右键 选择 HeroTPP_Skeleton ，命名为 BS_Locomotion 2. 配置 BS_Locomotion # 双击打开 BS_Locomotion 配置轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis 参数 值 说明 名字 Name Velocity 轴最大值 Maximum Axis Value 600 过渡区间 Grid Divisions 4 使用默认值；和可以添加的动画个数有关 配置动画 起点 Idle 终点 Run_Fwd 查看插值 系统 键位 Windows Control MacOS Command 水平移动鼠标，绿色X随之在起点和终点间移动，视口展示过渡动画 九、将混合空间作为动画蓝图输入 # ABP_BaseCharacter BS_Locomotion 1. 获取实时速度 velocity # 事件图表 EventGraph 添加变量 Velocity Float 在细节面板进行设置 在 事件图表 中使用变量 Velocity ，选择设置变量值 在 EventBlueprintUpdateAnimation 之后，执行 SetVelocity 变量 Velocity 的输入是 Actor 实时速度 使用 GetPawnOwner 获得 Pawn 实例的引用 2. 设置动画蓝图输入 # 动画图表 AnimGraph 将BS_Locomotion作为OutputPose的输入，并将变量Velocity作为BS_Locomotion的输入 将 BS_Locomotion 设做 OutputPose 输入 在 动画图表 中使用变量 Velocity ，此处只能获取变量值，我们要的就是获取变量值 将变量 Velocity 作为 BS_Locomotion 的输入 "}),e.add({id:30,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%8A%A8%E6%B2%BB%E7%96%97/",title:"自动治疗",description:"Overview # 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现。获取定时器管理对象有两种方式 UActorComponent::GetOwner \u0026gt; AActor::GetWorldTimerManager UActorComponent::GetWorld \u0026gt; UWorld::GetTimerManager 修改HealthComponent逻辑 C++ 一、封装更新生命值逻辑 # 之前在处理函数OnTakeAnyDamage中，更新生命值并广播。现在会有两个地方改变生命值，新增自动治疗，所以封装改变生命值逻辑。 受到伤害和自动治疗均会修改生命值，随之通知客户端(STBaseCharacter)修改HealthText。 函数成员 private 在OnTakeAnyDamage计算伤害时，改为调用SetHealth void USTHealthComponent::SetHealth(float NewHealth) { Health = FMath::Clamp(NewHealth, 0.0f, MaxHealth); OnHealthChanged.Broadcast(); } 二、添加治疗参数 # 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealDelay = 3.",content:"Overview # 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现。获取定时器管理对象有两种方式 UActorComponent::GetOwner \u0026gt; AActor::GetWorldTimerManager UActorComponent::GetWorld \u0026gt; UWorld::GetTimerManager 修改HealthComponent逻辑 C++ 一、封装更新生命值逻辑 # 之前在处理函数OnTakeAnyDamage中，更新生命值并广播。现在会有两个地方改变生命值，新增自动治疗，所以封装改变生命值逻辑。 受到伤害和自动治疗均会修改生命值，随之通知客户端(STBaseCharacter)修改HealthText。 函数成员 private 在OnTakeAnyDamage计算伤害时，改为调用SetHealth void USTHealthComponent::SetHealth(float NewHealth) { Health = FMath::Clamp(NewHealth, 0.0f, MaxHealth); OnHealthChanged.Broadcast(); } 二、添加治疗参数 # 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealDelay = 3.0f; UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealModifier = 5.0f; 三、添加定时器 # 添加定时器 数据成员 private FTimerHandle HealTimer; 包含头文件 源文件 #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;TimerManager.h\u0026quot; 生命值满格时关闭定时器；收到伤害时关闭定时器 添加函数 private OnTakeAnyDamage中调用 恢复到满生命值时调用 void USTHealthComponent::StopHealTimer() { if (AutoHeal \u0026amp;\u0026amp; GetWorld()) { GetWorld()-\u0026gt;GetTimerManager().ClearTimer(HealTimer); } } 定时器回调函数 函数成员 private void USTHealthComponent::HealUpdate() { SetHealth(Health + HealModifier); if (FMath::IsNearlyEqual(Health, MaxHealth)) { StopHealTimer(); } } 初始化定时器 函数成员 private OnTakeAnyDamage最后调用，受到伤害后，延后开始自动治疗 void USTHealthComponent::InitHealTimer() { if (!IsDead() \u0026amp;\u0026amp; AutoHeal \u0026amp;\u0026amp; GetWorld()) { GetWorld()-\u0026gt;GetTimerManager().SetTimer(HealTimer, this, \u0026amp;USTHealthComponent::HealUpdate, HealRate, true, HealDelay); } } 四、重写IsDead # bool IsDead() const { return FMath::IsNearlyZero(Health); } "}),e.add({id:31,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%B7%B3%E8%B7%83/",title:"实现游戏角色跳跃",description:"Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Jump SpaceBar Part 2 实现跳跃逻辑 # C++ 使用虚幻引擎提供的跳跃回调函数 绑定函数描述和回调函数 # 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::InitJump(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Jump\u0026quot;, IE_Pressed, this, \u0026amp;ASTBaseCharacter::Jump); } Part 3 添加跳跃动画 # 虚幻编辑器 ABP_BaseCharacter 跳跃动画资产 JumpStart JumpLoop JumpEnd 跳跃动画切换条件 使用 ACharacter::IsFalling 来设置变量 IsFalling ；true则Character在空中，false则说明Character在地面上。 上一小节中，变量 Velocity 横跨 ABP_BaseCharacter 的 EventGraph 和 AnimGraph ，这里，布尔类型变量 IsFalling 也一样 在 EventGraph 设置变量值，在 AnimGraph 中使用变量 使用状态机 在一个动画蓝图中管理多个动画，并定义动画之间的转换条件 一、设置布尔型变量 IsFalling # EventGraph ACharacter::IsFalling 需要 Pawn 到 Character 的转换 不能同时从 EventBlueprintUpdateAnimation 出发， SetVelocity 之后，执行转换 输入是 Character 的 MovementComponent ，从 AsCharacter 到 Target ，自动添加提取数据成员， IsFalling 函数的返回类型是布尔，作为 SetIsFalling 的输入 完整 EventGraph 二、实现 状态机 # AnimGraph 添加 状态机 ，命名为 Locomotion ，作为 OutputPose 的输入 StateMechine 双击 Locomotion ，进入 状态机 仅一个入口 Entry 为 Entry 添加 State ，命名为 Walk 双击 Walk 为 Walk 设置输入动画 BS_Locomotion 即之前 AnimGraph 中， OutputPose 的输入 到此， Character 的运动动画和上一小节一致 直接从 AssetBrowser 把 Jump 的三个动画拖入 Locomotion 动画自动被封装为 State ，和之前 AddState ，再将动画作为输入达到的效果一样 添加状态转换路径 添加转换条件 双击转换图标 Walk \u0026gt; JumpStart IsFalling 为 true JumpStart \u0026gt; JumpLoop JumpStart 将近结束 JumpStart 只播放一次 JumpLoop \u0026gt; JumpEnd IsFalling 为 false JumpLoop 循环播放 JumpEnd \u0026gt; Walk JumpEnd 将近结束 JumpEnd 只播放一次 三、设置 State 输入动画 # 拿 JumpStart 状态举例 选中JumpStart动画 \u0026gt; Details \u0026gt; Settings \u0026gt; LoopAnimation 默认循环播放动画 设置 JumpStart JumpEnd JumpLoop 的 LoopAnimation 设计 Jump 动画时， JumpStart 和 JumpEnd 只播放一次， JumpLoop 可循环。 如此设置还可修复Character跳跃时的卡顿 四、添加楼梯，查看 Jump 三阶段是否正常显示 # 添加楼梯 PlaceActors \u0026gt; Geometry \u0026gt; LinearStair 设置阶数 选中LinearStairBrush \u0026gt; Details \u0026gt; BrushSettings \u0026gt; NumSteps Character 从楼梯跳到平面时，一直保持 JumpLoop 五、跑步时跳跃，落地平滑 # 可以减少 JumpEnd \u0026gt; Walk 的 TimeRemaining 来缩短平滑 六、跳跃高度 # BP_STBaseCharacter JumpZVelocity 和 JumpStart 的时长有关 JumpLoop 动画更适合从临界点落下 ",content:"Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Jump SpaceBar Part 2 实现跳跃逻辑 # C++ 使用虚幻引擎提供的跳跃回调函数 绑定函数描述和回调函数 # 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::InitJump(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Jump\u0026quot;, IE_Pressed, this, \u0026amp;ASTBaseCharacter::Jump); } Part 3 添加跳跃动画 # 虚幻编辑器 ABP_BaseCharacter 跳跃动画资产 JumpStart JumpLoop JumpEnd 跳跃动画切换条件 使用 ACharacter::IsFalling 来设置变量 IsFalling ；true则Character在空中，false则说明Character在地面上。 上一小节中，变量 Velocity 横跨 ABP_BaseCharacter 的 EventGraph 和 AnimGraph ，这里，布尔类型变量 IsFalling 也一样 在 EventGraph 设置变量值，在 AnimGraph 中使用变量 使用状态机 在一个动画蓝图中管理多个动画，并定义动画之间的转换条件 一、设置布尔型变量 IsFalling # EventGraph ACharacter::IsFalling 需要 Pawn 到 Character 的转换 不能同时从 EventBlueprintUpdateAnimation 出发， SetVelocity 之后，执行转换 输入是 Character 的 MovementComponent ，从 AsCharacter 到 Target ，自动添加提取数据成员， IsFalling 函数的返回类型是布尔，作为 SetIsFalling 的输入 完整 EventGraph 二、实现 状态机 # AnimGraph 添加 状态机 ，命名为 Locomotion ，作为 OutputPose 的输入 StateMechine 双击 Locomotion ，进入 状态机 仅一个入口 Entry 为 Entry 添加 State ，命名为 Walk 双击 Walk 为 Walk 设置输入动画 BS_Locomotion 即之前 AnimGraph 中， OutputPose 的输入 到此， Character 的运动动画和上一小节一致 直接从 AssetBrowser 把 Jump 的三个动画拖入 Locomotion 动画自动被封装为 State ，和之前 AddState ，再将动画作为输入达到的效果一样 添加状态转换路径 添加转换条件 双击转换图标 Walk \u0026gt; JumpStart IsFalling 为 true JumpStart \u0026gt; JumpLoop JumpStart 将近结束 JumpStart 只播放一次 JumpLoop \u0026gt; JumpEnd IsFalling 为 false JumpLoop 循环播放 JumpEnd \u0026gt; Walk JumpEnd 将近结束 JumpEnd 只播放一次 三、设置 State 输入动画 # 拿 JumpStart 状态举例 选中JumpStart动画 \u0026gt; Details \u0026gt; Settings \u0026gt; LoopAnimation 默认循环播放动画 设置 JumpStart JumpEnd JumpLoop 的 LoopAnimation 设计 Jump 动画时， JumpStart 和 JumpEnd 只播放一次， JumpLoop 可循环。 如此设置还可修复Character跳跃时的卡顿 四、添加楼梯，查看 Jump 三阶段是否正常显示 # 添加楼梯 PlaceActors \u0026gt; Geometry \u0026gt; LinearStair 设置阶数 选中LinearStairBrush \u0026gt; Details \u0026gt; BrushSettings \u0026gt; NumSteps Character 从楼梯跳到平面时，一直保持 JumpLoop 五、跑步时跳跃，落地平滑 # 可以减少 JumpEnd \u0026gt; Walk 的 TimeRemaining 来缩短平滑 六、跳跃高度 # BP_STBaseCharacter JumpZVelocity 和 JumpStart 的时长有关 JumpLoop 动画更适合从临界点落下 "}),e.add({id:32,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E9%AB%98%E5%A4%84%E5%9D%A0%E8%90%BD%E4%BC%A4%E5%AE%B3/",title:"高处坠落伤害",description:"Overview # STBaseCharacter逻辑 C++ 落地时获取Z方向的速度，其和坠落高度相关，速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落伤害范围 LandedDamageRange [c, d] 落地时速度范围 LandedDamageVelocityRange [a, b] 速度小于a无伤； 在[a, b]范围内，对应伤害[c, d] c + (Velocity - a) (d - c) / (b - a) 速度大于b，伤害为d 在Character中获取速度的方式有两种： APawn::GetVelocity ACharacter:: GetCharacterMovement \u0026gt; UCharacterMovementComponent::Velocity 一、添加属性 # 原型可设置 参数 名称 LandedDamageRange 伤害范围 LandedDamageVelocityRange 落地受伤的速度范围 UPROPERTY(EditDefaultsOnly) FVector2D LandedDamageVelocityRange = {900.0f, 1200.0f}; UPROPERTY(EditDefaultsOnly)	FVector2D LandedDamageRange = {10.0f, 100.0f}; 二、订阅委托 # 委托处理函数 函数成员 private 委托支持蓝图 声明 UFUNCTION() void OnGroundLanded(const FHitResult\u0026amp; Hit); OnLanded已被使用 实现 坠落伤害属于环境伤害，无伤害源(Actor)和阵营(Controller) void ASTBaseCharacter::OnGroundLanded(const FHitResult\u0026amp; Hit) { float Velocity = -GetVelocity().",content:"Overview # STBaseCharacter逻辑 C++ 落地时获取Z方向的速度，其和坠落高度相关，速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落伤害范围 LandedDamageRange [c, d] 落地时速度范围 LandedDamageVelocityRange [a, b] 速度小于a无伤； 在[a, b]范围内，对应伤害[c, d] c + (Velocity - a) (d - c) / (b - a) 速度大于b，伤害为d 在Character中获取速度的方式有两种： APawn::GetVelocity ACharacter:: GetCharacterMovement \u0026gt; UCharacterMovementComponent::Velocity 一、添加属性 # 原型可设置 参数 名称 LandedDamageRange 伤害范围 LandedDamageVelocityRange 落地受伤的速度范围 UPROPERTY(EditDefaultsOnly) FVector2D LandedDamageVelocityRange = {900.0f, 1200.0f}; UPROPERTY(EditDefaultsOnly)	FVector2D LandedDamageRange = {10.0f, 100.0f}; 二、订阅委托 # 委托处理函数 函数成员 private 委托支持蓝图 声明 UFUNCTION() void OnGroundLanded(const FHitResult\u0026amp; Hit); OnLanded已被使用 实现 坠落伤害属于环境伤害，无伤害源(Actor)和阵营(Controller) void ASTBaseCharacter::OnGroundLanded(const FHitResult\u0026amp; Hit) { float Velocity = -GetVelocity().Z; UE_LOG(LogBaseCharacter, Log, TEXT(\u0026quot;Velocity: %0.f\u0026quot;), Velocity); if (Velocity \u0026lt; LandedDamageVelocityRange.X) return; float LandedDamage = FMath::GetMappedRangeValueClamped(LandedDamageVelocityRange, LandedDamageRange, Velocity); UE_LOG(LogBaseCharacter, Log, TEXT(\u0026quot;Damage: %0.f\u0026quot;), LandedDamage); TakeDamage(LandedDamage, FDamageEvent{}, nullptr, nullptr); } 注册委托 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::BindOnLanded() { LandedDelegate.AddDynamic(this, \u0026amp;ASTBaseCharacter::OnGroundLanded); } "}),e.add({id:33,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%B7%91%E6%AD%A5/",title:"实现游戏角色跑步",description:"Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Run LeftShift 虽然是跑步键位，但是限制方向为向前 要求同时按下 W 或 Up 要求速度不为0 前方有障碍物时，不应该由走路转换成跑步动画 动作映射的回调函数参数列表为空 判断是否为前进方向时，还可根据速度矢量和朝向的夹角 Part 2 实现跑步逻辑 # C++ 一、判断跑步键位是否按下，方向是否为前进 # 数据成员 private bool IsForward = false; bool AbleRun = false; 二、实现键位按下逻辑，绑定函数描述和回调函数 # 函数成员 private 在SetupPlayerInputComponent中调用InitRun void ASTBaseCharacter::RunEnable() { AbleRun = true; } void ASTBaseCharacter::RunDisable() { AbleRun = false; } void ASTBaseCharacter::InitRun(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Pressed, this, \u0026amp;ASTBaseCharacter::RunEnable); PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Released, this, \u0026amp;ASTBaseCharacter::RunDisable);	} 三、判断方向是否为前进 # 函数成员 private 在MoveForward中调用 void ASTBaseCharacter::SetIsForward(float Amount) { IsForward = Amount \u0026gt; 0.",content:"Part 1 绑定键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Run LeftShift 虽然是跑步键位，但是限制方向为向前 要求同时按下 W 或 Up 要求速度不为0 前方有障碍物时，不应该由走路转换成跑步动画 动作映射的回调函数参数列表为空 判断是否为前进方向时，还可根据速度矢量和朝向的夹角 Part 2 实现跑步逻辑 # C++ 一、判断跑步键位是否按下，方向是否为前进 # 数据成员 private bool IsForward = false; bool AbleRun = false; 二、实现键位按下逻辑，绑定函数描述和回调函数 # 函数成员 private 在SetupPlayerInputComponent中调用InitRun void ASTBaseCharacter::RunEnable() { AbleRun = true; } void ASTBaseCharacter::RunDisable() { AbleRun = false; } void ASTBaseCharacter::InitRun(UInputComponent* PlayerInputComponent) { PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Pressed, this, \u0026amp;ASTBaseCharacter::RunEnable); PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Released, this, \u0026amp;ASTBaseCharacter::RunDisable);	} 三、判断方向是否为前进 # 函数成员 private 在MoveForward中调用 void ASTBaseCharacter::SetIsForward(float Amount) { IsForward = Amount \u0026gt; 0.0f; } 四、判断当前是否满足跑步条件 # 函数成员 public 供其他类使用 跑步加速 const函数 可在蓝图中调用 UFUNCTION(BlueprintCallable) bool IsRunning() const; bool ASTBaseCharacter::IsRunning() const { return AbleRun \u0026amp;\u0026amp; IsForward \u0026amp;\u0026amp; !GetVelocity().IsZero(); } Part 3 添加跑步动画 # 虚幻编辑器 一、实现跑步动画 # 一维混合空间 BS_Run 设置轴 Name MaxinumAxisValue Velocity 600 设置动画 起点 终点 Idle RoadieRun_Fwd 二、修改 状态机 # ABP_STBaseCharacter 1. 添加变量 IsRunning 用作状态迁移条件 # EventGraph 使用 STBaseCharacter::IsRunning 需要 Pawn 到 STBaseCharacter 的转换 设置变量 IsRunning 完整 EventGraph 可以合并 Pawn 到 Character 和 STBaseCharacter 的转换 2. 添加转向动画 # AnimGraph 添加状态 Run ，使用 BS_Run 作为输入 BS_Run 的输入为 Velocity 当 IsRunning 为 true 时，从 Walk 迁移到 Run ，否则，从 Run 迁移到 Walk Run 和 Jump 的转换 初稿 第二稿 从 JumpEnd 回到 Walk 时，如果 IsRunning 为 true ，会立即切换到 Run 可以省略 JumpEnd 到 Run 的转换，降低状态机复杂度 3. 复用转换条件 # AnimGraph Run 到 JumpStart 的转换复用 Walk 到 JumpStart 的转换条件 选中Walk到JumpStart的条件 \u0026gt; Details \u0026gt; Transiton \u0026gt; Transition Rule Sharing \u0026gt; Promote To Share 命名为 IsFalling 共享条件显示为红色 选中Run到JumpStart的条件 \u0026gt; Details \u0026gt; Transition \u0026gt; Transition Rule Sharing \u0026gt; Use Shared \u0026gt; 选择IsFalling 完整状态机 三、阶段性总结 # 运行游戏，跑步动画正常切换，但跑步和走路的速度一样 下一步，实现跑步时提升速度 Part 4 创建 Components/STCharacterMovementComponent # 虚幻编辑器 CharacterMovementComponent 公有类 Part 5 实现跑步加速 # C++ 1. 添加头文件路径 # ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootTraining/Public/Player\u0026quot;, \u0026quot;ShootTraining/Public/Components\u0026quot; }); 2. 可配置 加速系数 # STCharacterMovementComponent 数据成员 public 可设置类成员初始值 范围 1.5 - 10 UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;1.5\u0026quot;, ClampMax = \u0026quot;10.0\u0026quot;)) float SpeedAcceleration = 2.0f; 3. 当 Character 跑步时，增加最大速度 # STCharacterMovementComponent 使用 STBaseCharacter::IsRunning 判断当前是否满足跑步条件 包含头文件 源文件 #include \u0026quot;Player/STBaseCharacter.h\u0026quot; 覆写 UCharacterMovementComponent::GetMaxSpeed 当 Character 满足跑步条件时，增加最大速度 并不直接修改 MaxWalkSpeed 某个地方会调用 GetMaxSpeed 来确定 Character 运动速度的上限，当获取的 MaxSpeed 增加，速度增加的幅度也变大，用以实现加速 float USTCharacterMovementComponent::GetMaxSpeed() const { const float MaxSpeed = Super::GetMaxSpeed(); ASTBaseCharacter *Player = Cast\u0026lt;ASTBaseCharacter\u0026gt;(GetPawnOwner()); return Player \u0026amp;\u0026amp; Player-\u0026gt;IsRunning() ? SpeedAcceleration * MaxSpeed : MaxSpeed; } 4. Character 使用自定义 CharacterMovementComponent # STBaseCharacter 包含头文件 源文件 #include \u0026quot;Components/STCharacterMovementComponent.h\u0026quot; 屏蔽默认构造函数 重新实现构造函数，设置要使用组件类型 ASTBaseCharacter::ASTBaseCharacter(const FObjectInitializer \u0026amp;ObjInit) : Super(ObjInit.SetDefaultSubobjectClass\u0026lt;USTCharacterMovementComponent\u0026gt;(ACharacter::CharacterMovementComponentName)) { // Set this character to call Tick() every frame. You can turn this off to improve performance if you don't need it. PrimaryActorTick.bCanEverTick = true; // InitCameraComponent(); InitSpringArmAndCamera(); } "}),e.add({id:34,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F%E5%92%8C%E6%94%B6%E5%B0%BE/",title:"打包游戏和收尾",description:"一、打包游戏 # Shipping看不到Debug球 二、优化 # 定义委托类型之后，使用分号 定义委托类型时，类型名以F打头，以Signature结尾 建议 类定义顺序 public 构造函数 \u0026gt; 委托类型变量 \u0026gt; UFUNCTION \u0026gt; 其他函数 添加LifeSpanOnDeath属性 蓝图可设置 在SetupPlayerInputComponent中检查PlayInputComponent ",content:"一、打包游戏 # Shipping看不到Debug球 二、优化 # 定义委托类型之后，使用分号 定义委托类型时，类型名以F打头，以Signature结尾 建议 类定义顺序 public 构造函数 \u0026gt; 委托类型变量 \u0026gt; UFUNCTION \u0026gt; 其他函数 添加LifeSpanOnDeath属性 蓝图可设置 在SetupPlayerInputComponent中检查PlayInputComponent "}),e.add({id:35,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E6%B7%BB%E5%8A%A0%E8%B5%B0%E8%B7%AF%E6%97%B6%E8%BD%AC%E5%90%91%E5%8A%A8%E7%94%BB/",title:"添加走路时转向动画",description:"Overview # 当前实现了3种动作，走路，跑步和跳跃 走路这块，从静止到跑起来支持加速，使用 BS_Locomotion 本小节会重新实现走路动画，根据速度方向，加载转向和后退动画 之后还有 装弹 Reloading 、死亡 Death 、瞄准 Aiming 动画 Blend Space 2D混合空间 拥有两个轴： Vertial Axis Horizontal Axis Part 1 建模 # 一、 ForwardVector 和 RightVector # Actor 有 ForwardVector 和 RightVector ， Character 前后左右移动有使用到这两个方向向量 若我们水平移动鼠标， ForwardVector 和 RightVector 随之发生改变 在视觉上， ForwardVector 一直向前， RightVector 一直向右，二者在水平面垂直 二、数学基础 # 1. 点乘 # 计算向量夹角 其中一个向量为 0向量 时，点乘结果为 0 ，而反余弦计算得到其夹角为 PI/2 2. 叉乘 # 用来将向量夹角从[0, PI]扩充到[-PI, PI] c.z 向量c的z坐标 其符号说明向量c的方向 theta 为 0 PI 和 -PI 时，叉乘结果为 0 无法通过向量确定平面，也就无法得到平面法向量 三、 VelocityVector # Actor 的速度是一个矢量，其表现是单位时间内的位移方向 当速度不为 0 ， VelocityVector 和 ForwardVector 的夹角与此时 Actor 应该展现的动画有关 四、计算夹角 # 坐标 ( Velocity , Angle ) VelocityVector 和 ForwardVector 夹角的计算通过反余弦结果和 sign(c.",content:"Overview # 当前实现了3种动作，走路，跑步和跳跃 走路这块，从静止到跑起来支持加速，使用 BS_Locomotion 本小节会重新实现走路动画，根据速度方向，加载转向和后退动画 之后还有 装弹 Reloading 、死亡 Death 、瞄准 Aiming 动画 Blend Space 2D混合空间 拥有两个轴： Vertial Axis Horizontal Axis Part 1 建模 # 一、 ForwardVector 和 RightVector # Actor 有 ForwardVector 和 RightVector ， Character 前后左右移动有使用到这两个方向向量 若我们水平移动鼠标， ForwardVector 和 RightVector 随之发生改变 在视觉上， ForwardVector 一直向前， RightVector 一直向右，二者在水平面垂直 二、数学基础 # 1. 点乘 # 计算向量夹角 其中一个向量为 0向量 时，点乘结果为 0 ，而反余弦计算得到其夹角为 PI/2 2. 叉乘 # 用来将向量夹角从[0, PI]扩充到[-PI, PI] c.z 向量c的z坐标 其符号说明向量c的方向 theta 为 0 PI 和 -PI 时，叉乘结果为 0 无法通过向量确定平面，也就无法得到平面法向量 三、 VelocityVector # Actor 的速度是一个矢量，其表现是单位时间内的位移方向 当速度不为 0 ， VelocityVector 和 ForwardVector 的夹角与此时 Actor 应该展现的动画有关 四、计算夹角 # 坐标 ( Velocity , Angle ) VelocityVector 和 ForwardVector 夹角的计算通过反余弦结果和 sign(c.z) 的乘积实现，分析特殊情形 速度为 0 ，真实夹角应该为 0 由于此时 Velocity 为 0 ，( 0, 任意 ) 对应 Idle ，可以显示正确动画 速度不为 0 ，夹角为 0 或 PI 叉乘结果为 0 ，即sign(c.z)为 0 ，即计算夹角得到 0 ，对应动画 RunFwd 夹角为 0 使用 RunFwd 正确，夹角为 PI 应该使用 RunBwd 夹角为 PI 时，不使用乘积，使用反余弦结果 夹角 反余弦结果 理论上的sign(c.z) 目的动画 使用乘积效果 0 0 0 Fwd o ( 0, PI/2 ) ( 0, PI/2 ) 1 Fwd \u0026gt; Right o PI/2 PI/2 1 Right o ( PI/2, PI ) ( PI/2, PI ) 1 Right \u0026gt; Bwd o PI PI 0 Bwd x -PI PI 0 Bwd x ( -PI, -PI/2 ) ( PI/2, PI ) -1 Left \u0026gt; Bwd o -PI/2 PI/2 -1 Left o ( -PI/2, 0 ) ( 0, PI/2 ) -1 Fwd \u0026gt; Left o 可以在蓝图中实现夹角的计算，也可以在C++中实现 Part 2 绘制 ForwardVector RightVector 和 VelocityVector # 虚幻编辑器 使用 DrawDebugArrow ， Duration 为 0 ，每帧都进行绘画 1. 绘制 ForwardVector # 起点 偏移 终点 Actor 当前位置 放大的前进方向向量 起点 + 偏移 2. 绘制 RightVector # 起点 偏移 终点 Actor 当前位置 放大的向右方向向量 起点 + 偏移 3. 绘制 VelocityVector # 起点 偏移 终点 Actor 当前位置 放大的速度方向单位向量 起点 + 偏移 4. 效果图 # 一直显示 ForwardVector 和 RightVector 有速度才会显示 VelocityVector 5. 优化显示 # 项目设置 \u0026gt; Engine \u0026gt; Rendering \u0026gt; Default Settings \u0026gt; Auto Exposure，取消勾选 旨在模拟人眼适应不同亮度 看不出区别 Part 3 使用 混合空间 实现Walk动画 # 虚幻编辑器 Blend Space 一、创建 BS_Locomotion_Walk # 设置轴 轴 Name 范围 说明 水平轴 Velocity [ 0, 600 ] 速度 垂直轴 Direction [ -180, 180 ] ForwardVector 和 VelocityVector 的夹角 坐标 ( Velocity , Direction ) 坐标 动画资产 说明 ( 0, 0 ) Idle 初始状态 ( 600, 0 ) Run_Fwd 满速前进 ( 600, -180 ) 和 ( 600, 180 ) Run_Bwd 满速后退 ( 600, 90 ) Run_Rt 满速向右 ( 600, -90 ) Run_Lt 满速向左 二、将 BS_Locomotion_Walk 用作走路动画 # ABP_BaseCharacter 添加变量 AngleBetweenForwardAndVelocity float类型 默认值为0 AngleBetweenForwardAndVelocity 作为 Direction 的输入 AnimGraph \u0026gt; 状态机 \u0026gt; Walk状态 Part 4 在蓝图中计算 ForwardVector 和 VelocityVector 的夹角 # 虚幻编辑器 1. 在蓝图中计算夹角并设置变量 # 计算点乘时， ForwardVector 和 VelocityVector 都是单位向量 当前并未在夹角为PI时做处理，后退动画偶有闪动但看似正常 输出 DotProduct 结果，静止时输出 90 输出 CrossProduct 结果，静止、前进或后退时，坐标为 0 但是有正负 输出 Sign 结果，静止时为 0 ，前进或后退时，其结果或为 1 或为 -1 ，飘忽不定，但不为 0 ，所以后退动画看似正常 可以做出合理推测：显示为 0 但不意味着为 0 ，数值过于小了但是有正负 叉乘时传入未单位化的 Velocity 无改善 同时按下后退和向左，或者后退和向右，正负 3PI/4 的动画较为刻意 ( PI/2, PI ) 和 ( -PI, -PI/2 ) 时可以只显示 Run_Bwd 2. 绘制 ForwardVectr 和 VelocityVector 的叉乘结果 # 起点 偏移 终点 Actor 当前位置 放大的叉乘结果 起点 + 偏移 运动时才有向量显示 向前和向后运动时，偶有不明显的显示 3. 取消变量的设置 # 接下来在代码计算夹角 Part 5 在代码中计算 ForwardVector 和 VelocityVector 的夹角 # C++ 1. 计算夹角 # 函数成员 public 蓝图可调用 const函数 float ASTBaseCharacter::GetAngleBetweenForwardAndVelocity() const { if (GetVelocity().IsZero()) return 0.0f; const FVector ForwardVector = GetActorForwardVector(); const FVector VelocityNormalizedVector = GetVelocity().GetSafeNormal(); const float DotProductResult = FVector::DotProduct(ForwardVector, VelocityNormalizedVector); const float Theta = FMath::RadiansToDegrees(FMath::Acos(DotProductResult)); const FVector CrossProductResult = FVector::CrossProduct(ForwardVector, VelocityNormalizedVector); return (CrossProductResult.IsZero() ? Theta : FMath::Sign(CrossProductResult.Z) * Theta); } 速度为 0 时，夹角为 0 夹角为 PI 或 -PI 时，叉乘结果为0，返回反余弦结果 2. 代码优化 # 可选 实现前后左右移动回调函数 MoveForward 和 MoveRight 时，如果 Amount 为0，直接返回；MoveFoward中，设置IsForward逻辑保留 Part 6 使用 C++ 函数设置夹角值 # 虚幻编辑器 1. 在蓝图中使用C++函数计算夹角 # ABP_BaseCharacter \u0026gt; EventGraph 2. 阻断动画蓝图无效状态 # 当我们打开动画蓝图时，其以standalone方式运行。即使未在虚幻编辑器中运行游戏，在蓝图编辑器打开ABP_BaseCharacter，其处于运行状态。可以看到动画蓝图视口的 Actor 是有动画的。 从 EventBlueprintUpdateAnimation 出发， TryGetPawnOwner 得到空指针时，停在 CastToCharacter 添加打印名，验证动画蓝图运行 未在虚幻编辑器运行游戏，保持动画蓝图在前台，日志窗口一直有输出 未运行游戏时，阻断动画蓝图 从 EventBlueprintUpdateAnimation 出发，添加 IsValid 宏，检查 Pawn 有效性 "}),e.add({id:36,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/",title:"代码重构",description:"Part 1 新增 Components/STHealthComponent # C++ STHEalthComponent 当前生命值和最大生命值 数据成员 Health MaxHealth 提供 public 接口，可以获取当前生命值 函数成员 GetHealth 提供 public 接口，判断角色是否死亡 函数成员 IsDead 定义委托类型并添加数据成员，生命值改变时通知 FOnHealthChangedSignature 定义委托类型并添加数据成员，生命值为0时通知 FOnDeathSignature 提供 private 接口，更新生命值并通知 SetHealth 添加定时器，受到伤害后延后治疗 数据成员 参数 名称 使能自动治疗 AutoHeal 治疗量 HealModifier 治疗频率 HealRate 延后治疗时长 HealDelay 函数成员 函数 名称 回调函数 OnHealTrigger 开启定时器 StartHealTimer 关闭定时器 StopHealTimer 注册受伤处理函数，更新生命值，死亡时广播 函数成员 OnTakeAnyDamage Part 2 为Character添加HealthComponent和TextRender组件 # C++ STBaseCharacter 添加组件并初始化 添加函数，修改HealthText组件文本；初始化和生命值改变时调用 注册HealthComponent的OnHealthChanged 添加数据成员，蓝图可设置死亡动画剪辑 添加数据成员，蓝图可设置角色死亡销毁延时 注册HealthComponent的OnDeath 角色死亡时，播放死亡动画剪辑，禁止控制游戏角色，定时销毁，并切换到观察者视角 添加数据成员，坠落伤害范围和受到伤害时落地速度范围 添加函数成员，坠落时委托处理函数，并注册委托服务 Part 3 新增 Dev/STDevDamageActor # C++ STDevDamageActor 添加SceneComponent，使能变换 添加数据成员，设置球体颜色和半径 绘制球体，显示爆炸伤害范围 添加数据成员，设置伤害数值特征和计算伤害选项 对伤害半径内的角色造成伤害 Part 4 相关设置 # 虚幻编辑器 调整TextRender组件 创建死亡动画剪辑 AM_Death，并设置AM_Death播放完结束 在动画蓝图中，通过Slot，连接状态机动画和OutputPose ABP_BaseCharacter \u0026gt; AnimGraph 设置DeathAnimMontage属性 AM_Death BP_STBaseCharacter 在场景中添加伤害源 Part 5 项目结构更新 # 资产 Content/ ExternalContent/ Levels/ DefaultMap Player/ Animations/ ABP_BaseCharacter BS_Run BS_Walk AM_Death BP_STBaseCharacter [-] BP_STPlayerController BP_STGameModeBase C++ ShootTrainingSecond/ ShootTrainingSecondGameModeBase Public/ Components/ STCharacterMovementComponent STHealthComponent Player/ STBaseCharacter [-] STPlayerController Dev/ STDevDamageActor Part 6 阶段性总结 # 一、游戏角色 # C++ Player/STBaseCharacter Blueprint Player/BP_STBaseCharacter Player/Animations/ABP_BaseCharacter 其他 Player/Animations Blueprint BS_Run BS_Walk AM_Death 1.",content:"Part 1 新增 Components/STHealthComponent # C++ STHEalthComponent 当前生命值和最大生命值 数据成员 Health MaxHealth 提供 public 接口，可以获取当前生命值 函数成员 GetHealth 提供 public 接口，判断角色是否死亡 函数成员 IsDead 定义委托类型并添加数据成员，生命值改变时通知 FOnHealthChangedSignature 定义委托类型并添加数据成员，生命值为0时通知 FOnDeathSignature 提供 private 接口，更新生命值并通知 SetHealth 添加定时器，受到伤害后延后治疗 数据成员 参数 名称 使能自动治疗 AutoHeal 治疗量 HealModifier 治疗频率 HealRate 延后治疗时长 HealDelay 函数成员 函数 名称 回调函数 OnHealTrigger 开启定时器 StartHealTimer 关闭定时器 StopHealTimer 注册受伤处理函数，更新生命值，死亡时广播 函数成员 OnTakeAnyDamage Part 2 为Character添加HealthComponent和TextRender组件 # C++ STBaseCharacter 添加组件并初始化 添加函数，修改HealthText组件文本；初始化和生命值改变时调用 注册HealthComponent的OnHealthChanged 添加数据成员，蓝图可设置死亡动画剪辑 添加数据成员，蓝图可设置角色死亡销毁延时 注册HealthComponent的OnDeath 角色死亡时，播放死亡动画剪辑，禁止控制游戏角色，定时销毁，并切换到观察者视角 添加数据成员，坠落伤害范围和受到伤害时落地速度范围 添加函数成员，坠落时委托处理函数，并注册委托服务 Part 3 新增 Dev/STDevDamageActor # C++ STDevDamageActor 添加SceneComponent，使能变换 添加数据成员，设置球体颜色和半径 绘制球体，显示爆炸伤害范围 添加数据成员，设置伤害数值特征和计算伤害选项 对伤害半径内的角色造成伤害 Part 4 相关设置 # 虚幻编辑器 调整TextRender组件 创建死亡动画剪辑 AM_Death，并设置AM_Death播放完结束 在动画蓝图中，通过Slot，连接状态机动画和OutputPose ABP_BaseCharacter \u0026gt; AnimGraph 设置DeathAnimMontage属性 AM_Death BP_STBaseCharacter 在场景中添加伤害源 Part 5 项目结构更新 # 资产 Content/ ExternalContent/ Levels/ DefaultMap Player/ Animations/ ABP_BaseCharacter BS_Run BS_Walk AM_Death BP_STBaseCharacter [-] BP_STPlayerController BP_STGameModeBase C++ ShootTrainingSecond/ ShootTrainingSecondGameModeBase Public/ Components/ STCharacterMovementComponent STHealthComponent Player/ STBaseCharacter [-] STPlayerController Dev/ STDevDamageActor Part 6 阶段性总结 # 一、游戏角色 # C++ Player/STBaseCharacter Blueprint Player/BP_STBaseCharacter Player/Animations/ABP_BaseCharacter 其他 Player/Animations Blueprint BS_Run BS_Walk AM_Death 1. C++ STBaseCharacter # 函数成员 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 委托 委托成员 作用 处理函数 操作 HealthComponent::OnHealthChanged 修改显示生命值 OnHealthChanged 调用DisplayHealthText HealthComponent::OnDeath 游戏角色死亡处理 OnDeath 播放死亡动画剪辑；禁止操作Character；定时销毁；切换到观察视角 ACharacter::LandedDelegate 计算落地伤害 OnGroundLanded 计算落地伤害；对Character调用TakeDamage 键位绑定 回调函数 键位 相关函数 MoveRight 左右移动 AddMovementInput；GetActorRightVector MoveForward 前后移动 AddMovementInput；GetActorForwardVector 左右旋转 ACharacter::AddControllerYawInput 上下旋转 ACharacter::AddControllerPitchInput 跳跃 ACharacter::Jump RunEnable，RunDisable 跑步 功能函数 函数 操作 相关函数 DisplayHealthText 设置TextRender文本 HealthTextComponent UTextRenderComponent::SetText 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STCharacterMovementComponent使用；供ABP_STBaseCharacter使用 数据成员 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 HealthComponent 生命值系统 HealthTextComponent 显示生命值 CharacterMovementComponent 运动组件 标志位 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 游戏角色死亡逻辑 DeathAnimMontage 死亡动画剪辑 LifeSpanOnDeath 销毁角色定时间隔 落地伤害逻辑 LandedDamageRange 伤害范围 LandedDamageVelocityRange 造成伤害的速度范围 2. Blueprint Player/BP_STBaseCharacter # CapsuleComponent HealthTextComponent Horizontal Alignment Center SpringArmComponent UsePawnControlRotation true MeshComponent Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter 3. Blueprint Player/Animations/ABP_BaseCharacter # AnimGraph Locomotion \u0026gt; Slot \u0026gt; OutputPose 状态 状态 说明 走路 Walk BS_Walk；混合空间 跑步 Run BS_Run；混合空间1D 跳跃 JumpStart JumpLoop JumpEnd 死亡 AM_Death；动画剪辑 动画输入 速度 Velocity 速度和前进方向的夹角 Directon 转换条件 IsRunning C++ 满足3个条件：按下Shift；速度和前进方向夹角为0（按下W）；速度不为0 IsFalling CharacterMovementComponent::IsFalling 返回true，意味着游戏角色跳起；接着返回false，意味着游戏角色回到地面 EventGraph 设置变量 Velocity Directon IsRunning IsFalling 二、组件 # C++ 1. STCharacterMovementComponent # 满足跑步判断时，增加最大速度 SpeedAcceleration 可设置类数据成员初始值；速度系数 2. STHealthCompoennt # 函数成员 基本函数 操作 构造函数 每帧调用Tick标志位置为false BeginPlay 初始化生命值；注册Actor::OnTakeAnyDamage TickComponent 屏蔽 接口 接口函数 操作 GetHealth 获取当前生命值；STBaseCharacter调用 内部逻辑 IsDead 判断角色是否死亡 SetHealth 修改生命值；受到伤害或治疗时调用，随之广播 治疗 OnHealTrigger 定时器回调函数；治疗；满生命值停止定时器 StartHealTimer 受到伤害则开启定时器 StopHealTimer 收到伤害会关闭之前开启的定时器；满生命值时停止定时器 受伤处理函数 OnTakeAnyDamage 进入条件：伤害为正数，当前角色存活；受伤后，停止已开启的治疗定时器；更新生命值；若角色死亡，广播，否则，开启治疗定时器 数据成员 Health 生命值 MaxHealth 最大生命值 委托成员 OnHealthChanged 修改生命值(SetHealth)时广播 OnDeath 受到伤害时，若死亡，广播 治疗 HealTimer 定时器 AutoHeal 使能治疗 HealModifier 治疗量 HealRate 治疗频率 HealDelay 治疗延时 三、伤害源 # 函数成员 基本函数 操作 构造函数 初始化组件 BeginPlay Tick 绘制球体模拟爆炸范围；对球体内以及相交Actor造成伤害 数据成员 SceneComponent 变换属性 Radius 球体半径 SphereColor 球体颜色 Damage 伤害的数值特征 DoFullDamage 计算伤害机制标志位 "}),e.add({id:37,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F/",title:"打包游戏",description:"Overview # 打包游戏，从二进制文件运行 定期打包游戏，确保所做改动能正常运行 一、设置游戏首页 # 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 设置 GameDefaultMap 二、设置编译选项 # 项目设置 \u0026gt; Packaging \u0026gt; Project \u0026gt; Build Configuration 选择 发行 Shipping 三、设置玩家出发点 # 参考 LevelEditor \u0026gt; PlaceActors \u0026gt; Basic \u0026gt; PlayerStart，添加到关卡中 四、编译游戏 # 参考 可在日志窗口查看过程 创建文件夹 Projects/5.1.1/ShootTraining/Build 设置二进制文件保存路径 工具栏 \u0026gt; Platforms \u0026gt; Mac \u0026gt; Package Project，选择 Build 文件夹 1. metal-ar 报错 # 当前项目路径不包含空格，但包含汉字 打包项目 菜单栏 \u0026gt; File \u0026gt; Zip Project 移动到不含空格的英文路径 2. 打包成功 # 生成 Build/Mac/ShootTraining-Shipping.",content:"Overview # 打包游戏，从二进制文件运行 定期打包游戏，确保所做改动能正常运行 一、设置游戏首页 # 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 设置 GameDefaultMap 二、设置编译选项 # 项目设置 \u0026gt; Packaging \u0026gt; Project \u0026gt; Build Configuration 选择 发行 Shipping 三、设置玩家出发点 # 参考 LevelEditor \u0026gt; PlaceActors \u0026gt; Basic \u0026gt; PlayerStart，添加到关卡中 四、编译游戏 # 参考 可在日志窗口查看过程 创建文件夹 Projects/5.1.1/ShootTraining/Build 设置二进制文件保存路径 工具栏 \u0026gt; Platforms \u0026gt; Mac \u0026gt; Package Project，选择 Build 文件夹 1. metal-ar 报错 # 当前项目路径不包含空格，但包含汉字 打包项目 菜单栏 \u0026gt; File \u0026gt; Zip Project 移动到不含空格的英文路径 2. 打包成功 # 生成 Build/Mac/ShootTraining-Shipping.app 3. 尝试 Development 和 DebugGame 选项，均可 # 纯蓝图项目没有 DebugGame 选项 "}),e.add({id:38,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/",title:"代码重构",description:"一、在5.2.0中编译ShooterGame # 不搞这个 二、项目结构 # 资产 Content/ ExternalContent/ Levels/ DefaultMap Player/ Animations/ ABP_BaseCharacter BS_Run BS_Walk BP_STBaseCharacter BP_STPlayerController BP_STGameModeBase C++ ShootTrainingSecond/ ShootTrainingSecondGameModeBase Public/ Components/ STCharacterMovementComponent Player/ STBaseCharacter STPlayerController 三、基础设置 # 载入 ExternalContent 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 四、任务 # 1. 三个蓝图类 # 虚幻编辑器 BP_STBaseCharacter BP_STPlayerController BP_STGameModeBase 使用 BP_STGameModeBase BP_STGameModeBase 使用 BP_STBaseCharacter 和 BP_STPlayerController 2. 添加组件 # C++ STBaseCharacter CameraComponent SpringArmComponent 3. 为Character绑定模型 # 虚幻编辑器 BP_STBaseCharacter 4. 绑定键位并给出函数描述 # 虚幻编辑器 项目设置 移动 轴映射 MoveRight APawn::AddMovementInput AActor::GetActorRightVector MoveForward APawn::AddMovementInput AActor::GetActorForwardVector 视角旋转 轴映射 TurnAround APawn::AddControllerYawInput Camera 组件和 Character 一齐旋转 LookUp APawn::AddControllerPitchInput 需使能 SpringArmComponent::bUsePawnControlRotation 默认 PlayerController::InputPitchScale 是负数，所以 Scale 为 -1 CameraComponent 以 CameraComponent 为中心旋转， SpringArmComponent 以 Pawn 为中心旋转 动作 动作映射 Jump ACharacter::Jump Run 按下键位 速度不为0 Velocity和Forward夹角为0 可配置加速系数 通过覆写 CharacterMovementComponent::GetMaxSpeed 实现加速 5.",content:"一、在5.2.0中编译ShooterGame # 不搞这个 二、项目结构 # 资产 Content/ ExternalContent/ Levels/ DefaultMap Player/ Animations/ ABP_BaseCharacter BS_Run BS_Walk BP_STBaseCharacter BP_STPlayerController BP_STGameModeBase C++ ShootTrainingSecond/ ShootTrainingSecondGameModeBase Public/ Components/ STCharacterMovementComponent Player/ STBaseCharacter STPlayerController 三、基础设置 # 载入 ExternalContent 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 四、任务 # 1. 三个蓝图类 # 虚幻编辑器 BP_STBaseCharacter BP_STPlayerController BP_STGameModeBase 使用 BP_STGameModeBase BP_STGameModeBase 使用 BP_STBaseCharacter 和 BP_STPlayerController 2. 添加组件 # C++ STBaseCharacter CameraComponent SpringArmComponent 3. 为Character绑定模型 # 虚幻编辑器 BP_STBaseCharacter 4. 绑定键位并给出函数描述 # 虚幻编辑器 项目设置 移动 轴映射 MoveRight APawn::AddMovementInput AActor::GetActorRightVector MoveForward APawn::AddMovementInput AActor::GetActorForwardVector 视角旋转 轴映射 TurnAround APawn::AddControllerYawInput Camera 组件和 Character 一齐旋转 LookUp APawn::AddControllerPitchInput 需使能 SpringArmComponent::bUsePawnControlRotation 默认 PlayerController::InputPitchScale 是负数，所以 Scale 为 -1 CameraComponent 以 CameraComponent 为中心旋转， SpringArmComponent 以 Pawn 为中心旋转 动作 动作映射 Jump ACharacter::Jump Run 按下键位 速度不为0 Velocity和Forward夹角为0 可配置加速系数 通过覆写 CharacterMovementComponent::GetMaxSpeed 实现加速 5. 设置动画 # 虚幻编辑器 动画蓝图 ABP_BaseCharacter 状态 # 走路 BS_Walk 混合空间 横轴 Velocity [0, 600] 纵轴 Direction [-PI, PI] 动画资产 Idle Run_Fwd Run_Bwd Run_Rt Run_Lt 跑步 BS_Run 混合空间1D 横轴 Velocity [0, 600] 动画资产 Idle RoadieRun 跳跃 Jump 动画资产 JumpStart JumpLoop JumpEnd 状态迁移 # 跳跃的进入和结束使用 ACharacter::IsFalling 跳跃步骤的递进根据单次播放临近结束做判断 跑步和走路根据 ASTBaseCharacter::IsRuning 做判断 参数 # Velocity AActor::GetVelocity Direction ASTBaseCharacter::GetDirection [-PI, PI] ForwardVector 和 VelocityVector 的夹角使用反余弦计算，范围扩充使用叉乘结果Z坐标的正负 "}),e.add({id:39,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/",title:"角色和动画",description:"",content:""}),e.add({id:40,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/",title:"基础课程",description:"",content:""}),e.add({id:41,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/",title:"虚幻引擎",description:"",content:""}),e.add({id:42,href:"/docs/%E5%88%86%E4%BA%AB/hugo/doks%E4%B8%BB%E9%A2%98/",title:"Doks主题",description:"Overview # demo github 依赖 说明 Git 并不知道为什么会依赖Git Node.js 前端插件 环境 Github Node.js Doks Hugo 安装依赖 # Git git --version Node.js 官网下载 18.16.0 LTS node --version npm --version npm config list # 查看配置 # 设置代理 npm config set proxy http://localhost:15236 npm config set https-proxy http://localhost:15236 # 如果代理不支持https npm config set registry \u0026quot;http://registry.npmjs.org\u0026quot; 初始化项目 # 下载到本地 和之前的hugo theme不同，不放到theme/，而是直接作为项目 官网提供两个项目，Child theme适合新手 git clone https://github.com/h-enk/doks.git doks 安装node modules npm install 本地部署服务器 不建议，会删除./public文件夹 npm run start 访问 http://localhost:1313/ 项目结构 # 基础结构 基础结构 说明 package.",content:"Overview # demo github 依赖 说明 Git 并不知道为什么会依赖Git Node.js 前端插件 环境 Github Node.js Doks Hugo 安装依赖 # Git git --version Node.js 官网下载 18.16.0 LTS node --version npm --version npm config list # 查看配置 # 设置代理 npm config set proxy http://localhost:15236 npm config set https-proxy http://localhost:15236 # 如果代理不支持https npm config set registry \u0026quot;http://registry.npmjs.org\u0026quot; 初始化项目 # 下载到本地 和之前的hugo theme不同，不放到theme/，而是直接作为项目 官网提供两个项目，Child theme适合新手 git clone https://github.com/h-enk/doks.git doks 安装node modules npm install 本地部署服务器 不建议，会删除./public文件夹 npm run start 访问 http://localhost:1313/ 项目结构 # 基础结构 基础结构 说明 package.json和package-lock.json node modules信息；npm install命令根据这些信息安装需要的modules node_modules/ 下载的node modules archetypes/ 模板 static/ 可以把图片放在这 content/ 子文件对应一种语言 config/ 配置文件的查找可以是config.toml，也可以是config/_default/config.toml；支持更多配置 assets/ js和css代码 node.js node_modules/ 说明 bootstrap bootstrap插件大本营；getbootstrap 5.3.0 highlight.js 可配置的语法高亮 highLight.js/ 说明 scss highLight.js提供的高亮主题；下载的高亮主题保存到这里 lib/languages 支持高亮的语言 配置文件 config/_default/ 说明 menus/ 不同语言的主页配置 config.toml 类似简单的config.toml languages.toml 配置语言选项 markup.toml toc显示的层级 params.toml 简单config.toml的部分功能；此处可设置主题选项 darkMode ，采用doks还是hugo提供的高亮 highLight ；横向路径导航 breadCrumb ；全尺寸布局 fullWidth ；试验高亮目录 scrollSpy 设置语言 # 添加menu ./config/_default/menus/menus.zh.toml 设置语言 // ./config/_default/config.toml # Multilingual ## defaultContentLanguage = \u0026quot;en\u0026quot; ## disableLanguages = [\u0026quot;de\u0026quot;, \u0026quot;nl\u0026quot;] # defaultContentLanguageInSubdir = true defaultContentLanguage = \u0026quot;zh\u0026quot; disableLanguages = [\u0026quot;de\u0026quot;, \u0026quot;nl\u0026quot;, \u0026quot;en\u0026quot;] 设置语言项 // ./config/_default/languages.toml [zh] languageName = \u0026quot;Chinese\u0026quot; contentDir = \u0026quot;content/zh\u0026quot; weight = 5 [zh.params] languageISO = \u0026quot;ZH\u0026quot; languageTag = \u0026quot;zh-CN\u0026quot; 设置翻译 新增 ./i18n/zh.yaml，同en.yaml 设置中文对应content 创建文件夹 content/zh content/zh/blog content/zh/docs 设置主页 # 1. title # # ./config/_default/params.toml ## title = \u0026quot;Doks\u0026quot; title = \u0026quot;ToughCactus\u0026quot; 2. get-started 链接 # \u0026lt;!-- ./layout/index.html :9 --\u0026gt; \u0026lt;a class=\u0026quot;btn btn-primary btn-lg px-4 mb-2\u0026quot; href=\u0026quot;/docs/{{ if .Site.Params.options.docsVersioning }}{{ .Site.Params.docsVersion }}/{{ end }}prologue/introduction/\u0026quot; role=\u0026quot;button\u0026quot;\u0026gt;{{ i18n \u0026quot;get-started\u0026quot; }}\u0026lt;/a\u0026gt; 3. 文本块 # 定义 my-sidebar-prefooter \u0026lt;!-- ./layout/index.html :60 --\u0026gt; {{ define \u0026quot;my-sidebar-prefooter\u0026quot; }} {{ if eq $.Site.Language.LanguageName \u0026quot;Chinese\u0026quot; }} \u0026lt;section class=\u0026quot;section section-sm\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;row justify-content-center text-center\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;虚幻引擎\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;C++, 蓝图.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;开发工具 ⚡️\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Git, VSCode.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;开发语言\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Bash.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;row justify-content-center text-center\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;C++\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;Emacs\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;图形学\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;row justify-content-center text-center\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;Hugo\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026quot;/docs/分享/hugo/doks主题/\u0026quot;\u0026gt;Doks主题\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;MacOS应用\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;Linux\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; {{ end }} {{ end }} 激活 \u0026lt;!-- ./layout/_default/baseof.html :22 --\u0026gt; {{ block \u0026quot;my-sidebar-prefooter\u0026quot; . }}{{ end }} 4. 文本 # \u0026lt;!-- ./content/zh/_index.html --\u0026gt; --- title : \u0026quot;好记性不如烂键盘。\u0026quot; description: \u0026quot;none.\u0026quot; lead: \u0026quot;\u0026quot; date: \u0026quot;\u0026quot; lastmod: \u0026quot;\u0026quot; draft: false images: [] --- 5. footer # # ./config/_default/params.toml ## footer = \u0026quot;Powered by \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://www.netlify.com/\\\u0026quot;\u0026gt;Netlify\u0026lt;/a\u0026gt;, \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://gohugo.io/\\\u0026quot;\u0026gt;Hugo\u0026lt;/a\u0026gt;, and \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://getdoks.org/\\\u0026quot;\u0026gt;Doks\u0026lt;/a\u0026gt;\u0026quot; footer = \u0026quot;Powered by \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://github.com/\\\u0026quot;\u0026gt;Github\u0026lt;/a\u0026gt;, \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://gohugo.io/\\\u0026quot;\u0026gt;Hugo\u0026lt;/a\u0026gt;, and \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://getdoks.org/\\\u0026quot;\u0026gt;Doks\u0026lt;/a\u0026gt;\u0026quot; 自定义配置 # 1. 横向路径导航 # Breadcrumb Navigation # ./config/_default/params.toml ## breadCrumb = false breadCrumb = true 2. 全尺寸布局 # # config/_default/params.toml ## fullWidth = true fullWidth = true 3. 试验高亮目录 # # config/_default/params.toml scrollSpy = false # experimental; needs Bootstrap \u0026gt;= 5.2.0-beta1 scrollSpy是node.js module 4. 使用highlight.js # hightlight.js 官网 开关 为false使用hugo默认代码高亮；为true则使用node modules，可以自行配置 # ./config/_default/params.toml highLight = true 下载高亮主题 Dracula git clone https://github.com/dracula/highlightjs.git cp Dracula/highlightjs/dracula.css doks/node_modules/highlight.js/scss/ 设置高亮主题 // ./assets/scss/app.scss // @import \u0026quot;highlight.js/scss/github-dark-dimmed\u0026quot;; // 自带 @import \u0026quot;highlight.js/scss/dracula\u0026quot;; // 新下载 设置要高亮的编程语言 到node_modules/highlight.js/lib/languages/去查找支持的语言，以及其名称 C++和elisp // ./assets/js/highlight.js import cpp from 'highlight.js/lib/languages/cpp'; import lisp from 'highlight.js/lib/languages/lisp'; hljs.registerLanguage('cpp', cpp); // 无法使用+ hljs.registerLanguage('elisp', lisp); hljs.registerLanguage('lisp', lisp); 不支持elisp，可以设置lisp 5. 目录导航 # // ./config/_default/markup.toml [tableOfContents] endLevel = 3 ordered = false ## startLevel = 2 startLevel = 1 6. 代码框背景色 # 若代码框的语言可识别，使用hljs配置 light主题，代码框背景色为浅色，换成深色 // ./assets/scss/components/_syntax.scss .hljs { display: block; overflow-x: auto; padding: 1.25rem 1.5rem; // background: $beige; // color: $body-color; background: $body-overlay-dark; color: $body-color-dark; } 代码框语言无法识别 不建议修改；文本块也使用这个样式 // ./assets/scss/components/_code.scss code { background: $beige; color: $black; padding: 0.25rem 0.5rem; } 7. 设置表格样式 # 参照 Book 主题 // ./assets/scss/components/_tables.scss // table { // @extend .table; // // margin: 3rem 0; // } $padding-1: 1px !default; $padding-4: 0.25rem !default; $padding-8: 0.5rem !default; $padding-16: 1rem !default; table { @extend .table; margin: 3rem 0; overflow: auto; display: block; border-spacing: 0; border-collapse: collapse; margin-top: $padding-16; margin-bottom: $padding-16; tr th, tr td { padding: $padding-8 $padding-16; border: $padding-1 solid $gray-200; } tr:nth-child(2n) { background: $gray-100; } } 8. 渐变条 # // ./assets/scss/layout/_header.scss // 橘 浅蓝 深蓝 .header-bar { border-top: 4px solid; // border-image-source: linear-gradient(90deg, $primary, #8ed6fb 50%, #d32e9d); border-image-source: linear-gradient(90deg, #cc3c11, #8edefb 50%, #2e31d3); border-image-slice: 1; } 9. 主题色 # // ./assets/scss/common/_variables.scss // $primary: $purple; $primary: rgb(18, 63, 160); 实现目录高亮 # Doks主题支持笔记本分区收起展开，博文目录，全尺寸布局，横向路径导航，以及分开的Docs和Blogs。 而对于内容较多的博文，目录高亮可以让读者有一个全局的把握。 目录高亮参考 高亮样式 实现目录高亮我知道的有两个相关的点，一个是scrollspy，另一个则是intersection observer scrollspy node.js module，也是bootstrap的一个插件 Doks主题自带的试验性的目录高亮使用的scrollspy # 安装 npm i scrollspy on npm on getbootstrap intersection observer js逻辑，我找的这个 js逻辑 我不知道怎么导入js代码，所以放在了 ./assets/js/hightlight.js的最后 // 样式设置 let options = { root: document.querySelector('#article'), rootMargin: '0px 0px -75%', threshold: 1.0 } // MyToc：叫什么名字不重要；作用是执行操作 // .my-toc 的 . 说明是class；# 说明是element // .my-toc 即是nac class，保存TableOfContents文本 const MyToc = document.querySelector('.my-toc'), headingObserver = new IntersectionObserver(headings =\u0026gt; { headings.forEach(heading =\u0026gt; { // 对heading遍历 const id = heading.target.getAttribute('id'); //获取heading id if (heading.isIntersecting) { inactive(); // 取消之前添加的class subItem = document.querySelector(`.my-toc a[href=\u0026quot;#${id}\u0026quot;]`).classList.add('active'); // 为当前heading添加class } }); }, options); // 对指定级别heading进行遍历；未指定，该级别标题不会被高亮 document.querySelectorAll('h0[id],h1[id],h2[id],h3[id]').forEach((heading) =\u0026gt; { headingObserver.observe(heading); }); function inactive() { document.querySelectorAll('.my-toc a').forEach((a) =\u0026gt; { a.classList.remove('active'); }); } 为当前TableOfContents设置nav class 根据有无配置scrollSpy，对TableOfContents的设置不同 当scrollSpy为false时，最下方的{{ .TableOfContents }}对应右侧的目录 用 nav class将其围起来 \u0026lt;!-- ./layout/partials/sidebar/docs-toc.html --\u0026gt; \u0026lt;div class=\u0026quot;page-links d-none d-xl-block\u0026quot;\u0026gt; \u0026lt;h3\u0026gt;{{ i18n \u0026quot;on-this-page\u0026quot; }}\u0026lt;/h3\u0026gt; {{ if eq .Site.Params.options.scrollSpy true -}} {{ .TableOfContents | replaceRE \u0026quot;\u0026lt;nav id=\\\u0026quot;TableOfContents\\\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;nav id=\\\u0026quot;toc\\\u0026quot;\u0026gt;\u0026quot; | safeHTML }} {{ else -}} \u0026lt;nav class=\u0026quot;my-toc\u0026quot;\u0026gt; {{ .TableOfContents }} \u0026lt;/nav\u0026gt; {{ end -}} \u0026lt;/div\u0026gt; 设置class包含active的标题的样式 light // ./assets/scss/common/_global.scss .my-toc a.active { color: $primary; font-weight: 800; transition: all .25s ease-in-out } dark // ./assets/scss/common/_dark.scss [data-dark-mode] .my-toc a.active { color: $link-color-dark; } 遗留问题 # 博文目录跳转偏移 受到navbarSticky影响 说明 描述 [pc] org文件所有标题均偏移；md文件一级标题导航到标题之下，其他级别标题正常 [平板] md文件从三级标题显示正常 解决方法 org转md；使用ox-hugo完成转换，md从二级标题开始 doks无法正确显示 ox-hugo 生成的图片链接 "}),e.add({id:43,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/",title:"健康系统",description:"",content:""}),e.add({id:44,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/",title:"进阶课程",description:"",content:""}),e.add({id:45,href:"/docs/brick/",title:"🧱",description:"",content:""}),e.add({id:46,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E8%B7%9F%E9%9A%8F%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E6%BB%9A%E5%8A%A8/",title:"文章目录跟随文章内容滚动",description:"如果在目录项高亮时设置文章目录滚动跟随，文章目录跳转功能失效 文章目录跳转时，会高亮中间的每一个目录项。在高亮下一个目录项时，文章目录立即滚动跟随，此时会终止跳转。 滚动触发 找到了文章目录对应的元素 document.querySelector('.docs-toc') ，没有找到页面对应的元素 1. 两种滚动注册 # 监听 所有滚动都会触发。配合定时器，如果在定时器到时间之前没有跳转到目的目录项，文章目录滚动偏移重置 window.addEventListener('scroll', () =\u0026gt; { // 处理 }); 绑定事件处理函数 对window绑定处理函数，只在滚动页面时触发 ✔️ 参考./assets/js/to-top.js window.onscroll = function() { // 处理 }; 2. 处理函数调用时间点 # 如果文章目录滚动即触发，因为持续滚动，文章目录跳转功能完全失效。得在滚动结束后，再调用处理函数。 使用定时器。滚动即重启定时器，定时器到时间再调用处理函数。 let timer = null; window.onscroll = function () { clearTimeout(timer); timer = setTimeout(function () { // 处理 }, 300); // 设置定时器间隔；要求不小于最长跳转时间 }; 3. 设置文章目录滚动 # 每个目录项占用的高度 single ，和文章目录除去\u0026quot;On This Page\u0026quot;文本之后的高度有关 document.querySelector('.my-toc').scrollHeight 。 考虑到文章目录上方\u0026quot;On This Page\u0026quot;文本，窗口可供显示目录的高度应减去\u0026quot;On This Page\u0026quot;文本的高度。 根据窗口高度 window.",content:" 如果在目录项高亮时设置文章目录滚动跟随，文章目录跳转功能失效 文章目录跳转时，会高亮中间的每一个目录项。在高亮下一个目录项时，文章目录立即滚动跟随，此时会终止跳转。 滚动触发 找到了文章目录对应的元素 document.querySelector('.docs-toc') ，没有找到页面对应的元素 1. 两种滚动注册 # 监听 所有滚动都会触发。配合定时器，如果在定时器到时间之前没有跳转到目的目录项，文章目录滚动偏移重置 window.addEventListener('scroll', () =\u0026gt; { // 处理 }); 绑定事件处理函数 对window绑定处理函数，只在滚动页面时触发 ✔️ 参考./assets/js/to-top.js window.onscroll = function() { // 处理 }; 2. 处理函数调用时间点 # 如果文章目录滚动即触发，因为持续滚动，文章目录跳转功能完全失效。得在滚动结束后，再调用处理函数。 使用定时器。滚动即重启定时器，定时器到时间再调用处理函数。 let timer = null; window.onscroll = function () { clearTimeout(timer); timer = setTimeout(function () { // 处理 }, 300); // 设置定时器间隔；要求不小于最长跳转时间 }; 3. 设置文章目录滚动 # 每个目录项占用的高度 single ，和文章目录除去\u0026quot;On This Page\u0026quot;文本之后的高度有关 document.querySelector('.my-toc').scrollHeight 。 考虑到文章目录上方\u0026quot;On This Page\u0026quot;文本，窗口可供显示目录的高度应减去\u0026quot;On This Page\u0026quot;文本的高度。 根据窗口高度 window.innerHeight 和\u0026quot;On This Page\u0026quot;文本的高度差，计算页面能展示的最大目录项 max 。一开始，页面会显示\u0026quot;On This Page\u0026quot;文本，此时展示的目录项数目小于 max 。 若当前目录项超出窗口最大可展示目录项的一半，滚动文章目录，偏移量使得之后的当前目录项位于文章目录下半部分。 如果目录项高度根据.docs-toc计算得到，偏移量使得当前目录项位于文章目录中间。 完整代码 放在./assets/js/hightlight.js最后 let timer = null; window.onscroll = function () { clearTimeout(timer); timer = setTimeout(function () { locate_heading(); }, 300); }; function locate_heading() { let res = document.querySelectorAll('.my-toc a.active'); if (res.length != 1) { return; } let active_heading = res.item(0); let count = 0, current = 0; document.querySelectorAll('.my-toc a').forEach((a) =\u0026gt; { if (a == active_heading) { current = count; // console.log(\u0026quot;current heading\u0026quot;, a); } ++count; }); ++current; count /= 2; console.log(current, \u0026quot;/\u0026quot;, count); let fullToc = document.querySelector('.docs-toc'); //修改scrolltop let myToc = document.querySelector('.my-toc'); let single = myToc.scrollHeight / count; let offset = fullToc.scrollHeight - myToc.scrollHeight; // on-this-page height let max = parseInt((window.innerHeight - offset) / single); let mid = parseInt(max / 2); // console.log(\u0026quot;single: \u0026quot;, single, \u0026quot;max: \u0026quot;, max); if (current \u0026gt;= max - mid) { fullToc.scrollTop = single * (current - mid); } else { fullToc.scrollTop = 0; } } 不知道什么原因，.my-toc的元素个数是认为的2倍，而包含active类的a标签个数仍为1；使用.docs-toc更毛病 "}),e.add({id:47,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/",title:"开发语言",description:"",content:""}),e.add({id:48,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/",title:"武器",description:"",content:""}),e.add({id:49,href:"/docs/",title:"笔记",description:"",content:""}),e.add({id:50,href:"/docs/%E5%88%86%E4%BA%AB/",title:"分享",description:"",content:""}),e.add({id:51,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/",title:"开发工具",description:"",content:""}),e.add({id:52,href:"/docs/%E5%88%86%E4%BA%AB/macos/",title:"MacOS",description:"",content:""}),e.add({id:53,href:"/docs/%E5%88%86%E4%BA%AB/hugo/",title:"Hugo",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()