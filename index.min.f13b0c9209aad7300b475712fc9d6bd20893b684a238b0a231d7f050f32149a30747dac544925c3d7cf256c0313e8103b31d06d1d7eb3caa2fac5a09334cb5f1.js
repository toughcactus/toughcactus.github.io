var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/%E5%88%86%E4%BA%AB/emacs/",title:"Emacs",description:"",content:""}),e.add({id:1,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%94%9F%E5%91%BD%E5%80%BC/",title:"实时显示游戏角色生命值",description:"Overview # 自定义健康组件 ActorComponent 纯逻辑 显示生命值 TextRenderComponent Part 1 创建健康组件 # 虚幻编辑器 ActorComponent 一、创建 Component/STHealthComponent # ActorComponent 公有类 Part 2 调整健康组件框架并给出初步实现 # C++ 一、调整框架 # 默认构造函数 将每帧调用TickComponent函数标志置为false PrimaryComponentTick.bCanEverTick = false; BeginPlay 屏蔽派生类 TickComponent 函数，使用基类实现 二、新增逻辑：实时生命值和最大生命值 # 数据成员 实时生命值 private float float Health = 0.0f; 最大生命值 protected 可设置类成员初始值 分组Health ( 0, 1000 ) UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Health\u0026quot;, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1000.0\u0026quot;)) float MaxHealth = 100.0f;	三、新增逻辑：获取生命值和初始化生命值 # 函数成员 获取生命值 public 蓝图可调用 const函数 隐式inline UFUNCTION(BlueprintCallable) float GetHealth() const { return Health; } 初始化生命值 private 在BeginPlay中调用 void USTHealthComponent::InitHealth() { Health = MaxHealth; } Part 3 为 Character 添加健康组件 # C++ STBaseCharacter 包含健康组件头文件 头文件 前向声明 class USTHealthComponent; 源文件 #include \u0026quot;Components/STHealthComponent.",content:"Overview # 自定义健康组件 ActorComponent 纯逻辑 显示生命值 TextRenderComponent Part 1 创建健康组件 # 虚幻编辑器 ActorComponent 一、创建 Component/STHealthComponent # ActorComponent 公有类 Part 2 调整健康组件框架并给出初步实现 # C++ 一、调整框架 # 默认构造函数 将每帧调用TickComponent函数标志置为false PrimaryComponentTick.bCanEverTick = false; BeginPlay 屏蔽派生类 TickComponent 函数，使用基类实现 二、新增逻辑：实时生命值和最大生命值 # 数据成员 实时生命值 private float float Health = 0.0f; 最大生命值 protected 可设置类成员初始值 分组Health ( 0, 1000 ) UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Health\u0026quot;, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1000.0\u0026quot;)) float MaxHealth = 100.0f;	三、新增逻辑：获取生命值和初始化生命值 # 函数成员 获取生命值 public 蓝图可调用 const函数 隐式inline UFUNCTION(BlueprintCallable) float GetHealth() const { return Health; } 初始化生命值 private 在BeginPlay中调用 void USTHealthComponent::InitHealth() { Health = MaxHealth; } Part 3 为 Character 添加健康组件 # C++ STBaseCharacter 包含健康组件头文件 头文件 前向声明 class USTHealthComponent; 源文件 #include \u0026quot;Components/STHealthComponent.h\u0026quot; 添加健康组件 数据成员 protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \u0026quot;Health\u0026quot;) USTHealthComponent *Health; 初始化组件 函数成员 private 在构造函数中调用 无表示，不用设置上级组件 void ASTBaseCharacter::InitHealthComponent() { Health = CreateDefaultSubobject\u0026lt;USTHealthComponent\u0026gt;(\u0026quot;HealthComponent\u0026quot;); } Part 4 为 Character 添加文本组件 # C++ STBaseCharacter 使用UTextRenderComponent 包含头文件 头文件 前向声明 class UTextRenderComponent; 源文件 #include \u0026quot;Components/TextRenderComponent.h\u0026quot; 添加TextRender组件 数据成员 protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \u0026quot;Health\u0026quot;) UTextRenderComponent *HealthText;	初始化组件 函数成员 private 在构造函数中调用 有视觉表示，挂到根组件下面 void ASTBaseCharacter::InitHealthTextComponent() { HealthText = CreateDefaultSubobject\u0026lt;UTextRenderComponent\u0026gt;(\u0026quot;HealthTextComponent\u0026quot;); HealthText-\u0026gt;SetupAttachment(GetRootComponent()); } 每帧更新显示文本 函数成员 private 在Tick函数中调用 void ASTBaseCharacter::DisplayHealthText() { HealthText-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), Health-\u0026gt;GetHealth()))); } 检查组件是否成功初始化 函数成员 private 在BeginPlay中调用 使用IDE编译时，若运行游戏崩溃，可在IDE中查看断点 void ASTBaseCharacter::CheckHealth() { check(Health); check(HealthText); } Part 5 调整文本组件 # 虚幻编辑器 BP_STBaseCharacter 一、查看无表示的组件 # Health 组件和 CharacterMovementComponent 无层级： 二者均无表示，纯逻辑 创建后无需挂在其他组件下面 二、查看Health组件 # 三、调整TextRender组件 # 设置属性 默认值 Text 水平对齐 Horizontal Alignment 文本颜色 Text Render Color 0 Center 天青色 将文本组件移动到 Character 上方 Location 因为运行时摄像机对着 Character 背面，旋转 RenderText Rotation 四、效果图 # "}),e.add({id:2,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E5%BF%AB%E6%8D%B7%E9%94%AE/",title:"快捷键",description:"导航 # 字符 操作 快捷键 函数 左移 C-b backward-char 右移 C-f forward-char 上移 C-p previous-line 下移 C-n next-line 行首 C-a move-beginning-of-line 行尾 C-e move-end-of-line 文件头 M-\u0026lt; beginning-of-buffer 文件尾 M-\u0026gt; 所在行居中 C-l recenter-top-bottom 向前翻页 M-v 向后翻页 C-v 语义 操作 快捷键 函数 句首 M-a 句尾 M-e 下一个单词 M-f 上一个单词 M-b 调整段落换行 M-q ",content:"导航 # 字符 操作 快捷键 函数 左移 C-b backward-char 右移 C-f forward-char 上移 C-p previous-line 下移 C-n next-line 行首 C-a move-beginning-of-line 行尾 C-e move-end-of-line 文件头 M-\u0026lt; beginning-of-buffer 文件尾 M-\u0026gt; 所在行居中 C-l recenter-top-bottom 向前翻页 M-v 向后翻页 C-v 语义 操作 快捷键 函数 句首 M-a 句尾 M-e 下一个单词 M-f 上一个单词 M-b 调整段落换行 M-q "}),e.add({id:3,href:"/docs/%E5%88%86%E4%BA%AB/macos/%E7%BB%88%E7%AB%AF/",title:"终端",description:"Part 1 iTerm2 # 官网下载 参考 窗口管理 # 快捷键 操作 Command-w 关闭窗口 分屏 快捷键 操作 Command-d 左右分屏 Command-Shift-d 上下分屏 Command-[ 标签页内切换窗口 Command-] Option-Command-UP 根据方向键切换窗口 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 快捷键 操作 Command-t 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right status bar # Preferences \u0026gt; Profiles \u0026gt; Session 勾选Status bar enabled，点击Configure Status Bar Preferences \u0026gt; Appearence \u0026gt; General \u0026gt; Status bar location Bottom 配色 # 官方提供的配色 常用配色 Dracula lovelace , lovelace文本 导入配色 Preferences Profiles Color \u0026gt; Color Presets \u0026gt; Import 窗口大小 # Preferences \u0026gt; Profiles \u0026gt; Window 设置 Columns 和 Rows 透明度 # Preferences \u0026gt; Profiles \u0026gt; Window \u0026gt; Transparency 3 字体 # Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Font Victor Mono 14 consolas下载指南 victor mono Part 2 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 安装 # /bin/bash -c \u0026quot;$(curl -fsSL https://mirrors.",content:"Part 1 iTerm2 # 官网下载 参考 窗口管理 # 快捷键 操作 Command-w 关闭窗口 分屏 快捷键 操作 Command-d 左右分屏 Command-Shift-d 上下分屏 Command-[ 标签页内切换窗口 Command-] Option-Command-UP 根据方向键切换窗口 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 快捷键 操作 Command-t 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right status bar # Preferences \u0026gt; Profiles \u0026gt; Session 勾选Status bar enabled，点击Configure Status Bar Preferences \u0026gt; Appearence \u0026gt; General \u0026gt; Status bar location Bottom 配色 # 官方提供的配色 常用配色 Dracula lovelace , lovelace文本 导入配色 Preferences Profiles Color \u0026gt; Color Presets \u0026gt; Import 窗口大小 # Preferences \u0026gt; Profiles \u0026gt; Window 设置 Columns 和 Rows 透明度 # Preferences \u0026gt; Profiles \u0026gt; Window \u0026gt; Transparency 3 字体 # Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Font Victor Mono 14 consolas下载指南 victor mono Part 2 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 安装 # /bin/bash -c \u0026quot;$(curl -fsSL https://mirrors.ustc.edu.cn/misc/brew-install.sh)\u0026quot; 设置源 # vi ～/.zshrc source ～/.zshrc 源代码仓库 export HOMEBREW_BREW_GIT_REMOTE=\u0026quot;https://mirrors.ustc.edu.cn/brew.git\u0026quot; 预编译二进制软件包与软件包元数据文件 export HOMEBREW_BOTTLE_DOMAIN=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-bottles\u0026quot; export HOMEBREW_API_DOMAIN=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-bottles/api\u0026quot; 核心软件仓库 export HOMEBREW_CORE_GIT_REMOTE=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026quot; 管理软件 # brew install --cask emacs # 安装 brew uninstall --cask emacs # 卸载 brew list # 当前管理的程序 使用cask选项则安装编译好的软件包，通常是一些带界面的软件；默认下载源码在本地编译安装，通常是不带界面的命令行工具和第三方库 Part 3 代理 Privoxy # 使用Homebrew安装 依赖pcre 设置iTerm2走代理 终端下Github走代理 要求本地已有代理软件，还有一种方法SS 参考 安装 brew install privoxy 配置 Privoxy使用端口号8118 vi /usr/local/etc/privoxy/config # 在文件末尾添加以下代码 listen-address 0.0.0.0:8118 forward-socks5 / localhost:1080 . 手动启动Privoxy sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config # 查看端口是否被监听 netstat -na | grep 8118 查询本地代理使用端口 系统偏好设置 \u0026gt; 网络 \u0026gt; Wi-Fi \u0026gt; 高级 \u0026gt; 代理 \u0026gt; 网页代理 / 安全网页代理 配置环境变量 vi ~/.zshrc # 添加以下内容 # 端口信息需查询，替换1949 export http_proxy='http://localhost:1949' export https_proxy=$http_proxy # 重载配置文件 source ~/.zshrc Part 4 oh-my-zsh # 官网 sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; 配置文件 vi .zshrc # 配置文件 source ~/.zshrc # 载入配置 下载Dracula主题 ln -s Dracula/zsh/dracula.zsh-theme ~/.oh-my-zsh/themes/ 设置主题 官方提供的主题已下载到本地 官方主题展示 ZSH_THEME=\u0026quot;robbyrussell\u0026quot; # 默认 ZSH_THEME=\u0026quot;random\u0026quot; # 随机 ZSH_THEME=\u0026quot;dracula\u0026quot; "}),e.add({id:4,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/bash/",title:"Shell脚本",description:"花括号的使用 # 资料 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，可以将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这么玩，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 tr命令 # runoob 去除引号 # tr -d '\u0026quot;' 使用sed sed 's/\\\u0026quot;//g' sed命令 # MacOS安装gsed runoob 1. 匹配行打印 # p gsed -n \u0026quot;/abc/p\u0026quot; file 2.",content:"花括号的使用 # 资料 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，可以将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这么玩，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 tr命令 # runoob 去除引号 # tr -d '\u0026quot;' 使用sed sed 's/\\\u0026quot;//g' sed命令 # MacOS安装gsed runoob 1. 匹配行打印 # p gsed -n \u0026quot;/abc/p\u0026quot; file 2. 修改源文件 匹配行删除 # -i d gsed -i \u0026quot;/abc/d\u0026quot; file 3. 修改源文件 匹配行文本替换 # 首个匹配项 gsed -i \u0026quot;s/abc/edf/\u0026quot; file 所有匹配项 gsed -i \u0026quot;s/abc/edf/g\u0026quot; file awk命令 # 指定分隔符，打印第3个参数 # awk -F ',' '{print $3}' file命令 # 查看文件编码 # file FILE echo命令 # 输出单行 # var=\u0026quot;hello world!\u0026quot; echo $var 输出多行 # echo -e \u0026quot;\\nhello world!\\n\u0026quot; "}),e.add({id:5,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/",title:"Git",description:"安装与配置 # 安装 方法 官网下载git-2.40.0 make install xcode自带 本地配置git账户 git -v # 配置账户信息 git config --global user.name \u0026quot;USERNAME\u0026quot; git config --global user.email \u0026quot;EMAIL-ADDRESS\u0026quot; 配置ssh # 生成秘钥 | 拷贝公钥到github ssh-keygen cat /Users/USERNAME/.ssh/id_rsa.pub 本地初始化，设置上游 # git init git remote add cute git@github.com:xxx/xx.git # cute为上游别名 git remote -v git fetch cute # 拉取上游内容，和Github项目同步 创建分支与切换 # git branch -a # 查看当前分支 git checkout main # 切换到分支main git branch master # 创建新分支master git checkout master 首次提交，需关联上游分支 # # 提交 git add -A git commit -m \u0026quot;Commit public and set-up-blog.",content:"安装与配置 # 安装 方法 官网下载git-2.40.0 make install xcode自带 本地配置git账户 git -v # 配置账户信息 git config --global user.name \u0026quot;USERNAME\u0026quot; git config --global user.email \u0026quot;EMAIL-ADDRESS\u0026quot; 配置ssh # 生成秘钥 | 拷贝公钥到github ssh-keygen cat /Users/USERNAME/.ssh/id_rsa.pub 本地初始化，设置上游 # git init git remote add cute git@github.com:xxx/xx.git # cute为上游别名 git remote -v git fetch cute # 拉取上游内容，和Github项目同步 创建分支与切换 # git branch -a # 查看当前分支 git checkout main # 切换到分支main git branch master # 创建新分支master git checkout master 首次提交，需关联上游分支 # # 提交 git add -A git commit -m \u0026quot;Commit public and set-up-blog.\u0026quot; git push --set-upstream cute master # 上游cute 分支master 删除commit记录 # git log # 最新提交 F E D C B，要删除F和E，记录D git rebase -i D # 将F E的pick改为drop git log # 查看当前提交 D C B git push cute master --force # 上游cute 分支master 存在多个文件添加/删除/修改，在上次提交的基础上再次提交 # 不建议如此操作，风险较大 项目文件夹一式两份，A和A_BAK 删除文件夹A内所有代码 不会删除.git文件夹，提交和同步记录均保留 rm -rf A/* 将A_BAK内的所有文件拷贝到A 不会拷贝.git cp -r A_BAK/* A/ 再次提交 git add -A git commit -m \u0026quot;Comments.\u0026quot; git push 设置代理 # # 查看配置 git config --list # 使用代理端口替换1949 git config --global https.proxy https://localhost:1949 git config --global http.proxy http://localhost:1949 # 取消设置 git config --global --unset http.proxy git config --global --unset https.proxy 设置项目同步链接 # SSH git remote set-url cute git@github.com:xxx/xx.git HTTPS push时需要验证，Github不再支持用户名和密码 git remote set-url cute https://github.com/xx.git "}),e.add({id:6,href:"/docs/brick/%E7%BB%88%E7%AB%AF/",title:"终端",description:"Overview # 介绍CLI，Terminal，Shell和Prompt视频 shell概念 # 接口 shell，和core相区分，是操作系统的外层。通过shell程序，可以使用系统服务或其他程序提供的功能。 根据操作系统类别和操作类型，shell可以分为图形shell（GUI）和命令行shell（CLI）。通常说的shell，指的命令行shell。 CLI Command-Line Interface 命令行界面 通过文本命令和计算机交互 GUI Graphical User Interface 图形用户界面 终端程序 # Terminal Wrapper Program 在终端输入文本命令 GUI或者程序提供的用于键入命令的窗口 终端程序 说明 iTerm MacOS Windows Terminal Windows Gnome Terminal 使用Gnome作为桌面的Linux自带的终端程序 Hyper Warp 目前MacOS；自动补全，鼠标交互，内置工作流，AI功能 Alacrity 命令解释器 # Shell 程序 终端中运行的程序。接受命令，然后解释并执行。 Shell启动时自动读取配置文件。 Shell 说明 sh Bourne Shell UNIX上的标准shell bash Bourne-Again Shell GNU开发；Linux默认；MacOS之前默认 不完全兼容sh shell，对一些命令和参数进行了扩展 配置文件 ~/.bash_profile zsh 19年起MacOS默认 配置文件 ~/zshrc 第三方框架oh-my-zsh提供其他功能 phish 脚本语言 # 需要解释器，每次运行时都需要解释。 脚本语言 JavaScript PHP Lua Python C# Shell脚本 # 开发语言 Shell Script 由一连串shell命令组成，可以指定用来解释脚本的shell程序 命令提示符 # Prompt 命令解释器提供并在终端显示，如当前路径和git信息。 类别 第三方提示 Powerline Starship Power Level 10K Spaceship 第三方框架 oh-my-zsh 提供各种promots，configuration options，aliases，plugins。支持自定义prompt，调整shell行为 查看Shell信息 # 命令解释器 当前使用的shell echo $SHELL echo $0 已安装shell cat /etc/shells Shell操作 # 切换shell程序 重新打开终端生效 chsh -s /bin/bash 不修改SHELL环境变量 zsh 手动读取配置文件 zsh source ~/.",content:"Overview # 介绍CLI，Terminal，Shell和Prompt视频 shell概念 # 接口 shell，和core相区分，是操作系统的外层。通过shell程序，可以使用系统服务或其他程序提供的功能。 根据操作系统类别和操作类型，shell可以分为图形shell（GUI）和命令行shell（CLI）。通常说的shell，指的命令行shell。 CLI Command-Line Interface 命令行界面 通过文本命令和计算机交互 GUI Graphical User Interface 图形用户界面 终端程序 # Terminal Wrapper Program 在终端输入文本命令 GUI或者程序提供的用于键入命令的窗口 终端程序 说明 iTerm MacOS Windows Terminal Windows Gnome Terminal 使用Gnome作为桌面的Linux自带的终端程序 Hyper Warp 目前MacOS；自动补全，鼠标交互，内置工作流，AI功能 Alacrity 命令解释器 # Shell 程序 终端中运行的程序。接受命令，然后解释并执行。 Shell启动时自动读取配置文件。 Shell 说明 sh Bourne Shell UNIX上的标准shell bash Bourne-Again Shell GNU开发；Linux默认；MacOS之前默认 不完全兼容sh shell，对一些命令和参数进行了扩展 配置文件 ~/.bash_profile zsh 19年起MacOS默认 配置文件 ~/zshrc 第三方框架oh-my-zsh提供其他功能 phish 脚本语言 # 需要解释器，每次运行时都需要解释。 脚本语言 JavaScript PHP Lua Python C# Shell脚本 # 开发语言 Shell Script 由一连串shell命令组成，可以指定用来解释脚本的shell程序 命令提示符 # Prompt 命令解释器提供并在终端显示，如当前路径和git信息。 类别 第三方提示 Powerline Starship Power Level 10K Spaceship 第三方框架 oh-my-zsh 提供各种promots，configuration options，aliases，plugins。支持自定义prompt，调整shell行为 查看Shell信息 # 命令解释器 当前使用的shell echo $SHELL echo $0 已安装shell cat /etc/shells Shell操作 # 切换shell程序 重新打开终端生效 chsh -s /bin/bash 不修改SHELL环境变量 zsh 手动读取配置文件 zsh source ~/.zshrc 指定shell脚本的命令解释器 #!/bin/bash "}),e.add({id:7,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/",title:"搭建个人博客",description:"Overview # 环境 说明 Github Page 部署服务器 Hugo 构建静态网页 anubis 主题 安装依赖 # Hugo 1. 使用go安装 # Windows系统 安装go 官网下载 环境变量 # go export PATH=/usr/local/go/bin:$PATH export GOROOT=/usr/local/go export GOPATH=/Users/USERNAME/go export GOBIN=/Users/USERNAME/go/bin # go安装的软件 export PATH=$GOBIN:$PATH 生效 vi ~/.zshrc source ~/.zshrc 安装hugo 如若遇上网络不佳 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off 安装，验证 go install github.com/gohugoio/hugo@latest hugo env -v 如果需要使用hugo扩展功能，替换hugo文件 2. 使用homebrew安装 # MacOS brew install hugo 初始化项目 # 初始化项目 hugo new site /site/path 通用项目结构 文件 说明 config.",content:"Overview # 环境 说明 Github Page 部署服务器 Hugo 构建静态网页 anubis 主题 安装依赖 # Hugo 1. 使用go安装 # Windows系统 安装go 官网下载 环境变量 # go export PATH=/usr/local/go/bin:$PATH export GOROOT=/usr/local/go export GOPATH=/Users/USERNAME/go export GOBIN=/Users/USERNAME/go/bin # go安装的软件 export PATH=$GOBIN:$PATH 生效 vi ~/.zshrc source ~/.zshrc 安装hugo 如若遇上网络不佳 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off 安装，验证 go install github.com/gohugoio/hugo@latest hugo env -v 如果需要使用hugo扩展功能，替换hugo文件 2. 使用homebrew安装 # MacOS brew install hugo 初始化项目 # 初始化项目 hugo new site /site/path 通用项目结构 文件 说明 config.toml 配置文件；yaml格式也可以 content 存放blog；支持md和org theme 存放主题 public 生成的静态页面；同步到Github项目 archetypes 文章模版 创建页面 保存到 ./content/post hugo new post/first-blog.org 使用主题anubis # 下载主题 anubis on hugo anubis on github 如果使用git管理静态网页项目 git init git submodule add https://github.com/mitrichius/hugo-theme-anubis.git themes/anubis 或者直接下载，并存放到./theme目录下 使用anubis提供的模板 ./themes/anubis/exampleSite cp themes/anubis/exampleSite/config.toml . cp themes/anubis/exampleSite/content/. content config.toml 说明 menu 有三项，about，tags和archives tags 按tag统计后的文章分类；还可以进入到categories archives 存放所有blog content 说明 tags 对blog进行tag categories 对blog进行分类 post 所有blog存放在post；会统计post路径下blog的tag和categories，并遍历到对应menu项 about about.md；about-subpage.md和about-subpage2.md是about的两个子页 文章模板 yaml \u0026mdash; author: \u0026ldquo;author\u0026rdquo; title: \u0026ldquo;article title\u0026rdquo; date: \u0026ldquo;2023-03-17\u0026rdquo; description: \u0026ldquo;article description\u0026rdquo; tags: [ \u0026ldquo;tag-1\u0026rdquo;, \u0026ldquo;tag-2\u0026rdquo;, ] categories: [ \u0026ldquo;category\u0026rdquo;, ] \u0026mdash; 简单介绍 \u0026lt;!\u0026ndash;more\u0026ndash;\u0026gt; 正文 使用hugo构建静态网页 # 选项 说明 \u0026ndash;theme=anubis 设置主题； -t anubis both --watch 修改文件后自动刷新浏览器； -w server --buildDrafts 包括标记为draft的笔记； -D both --buildFuture 包括新发布笔记；检查date选项； -F both \u0026ndash;baseUrl=\u0026quot;http://toughcactus.github.io/\u0026quot; 编译时不包含，GithubPage部署会丢失样式 both --cleanDestinationDir 将public文件夹中不再使用的文件删除 hugo 1. 运行服务器 # 查询server选项 参考 hugo help server 本地测试，访问 http://localhost:1313/ hugo server --theme=anubis --watch # hugo server 2. 生成静态页面 # 生成文件在 ./public hugo --theme=anubis --baseUrl=\u0026quot;https://toughcactus.github.io/\u0026quot; # hugo 在Github创建项目 # 创建repository toughcactus.github.io 为github设置主题 创建_config.yml文件 remote_theme: pages-themes/midnight@v0.2.0 将public内容提交到repository "}),e.add({id:8,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E4%BC%A4%E5%AE%B3/",title:"计算伤害",description:"Overview # 虚幻引擎提供一组函数，用来对Actor造成伤害 在Tick函数中，持续对游戏角色造成伤害；每次造成伤害，委托机制触发处理函数，更新角色生命值 一、每帧对 Character 造成伤害 # STBaseCharacter 函数成员 private 在Tick中调用 伤害来源是自己 void ASTBaseCharacter::CharacterTakeDamage() { TakeDamage(0.1f, FDamageEvent{}, GetController(), this); } 二、定义空的伤害委托处理函数，并注册到 Character # USTHealthComponent 包含头文件 源文件 #include \u0026quot;GameFramework/Actor.h\u0026quot; 定义日志类型 源文件 DEFINE_LOG_CATEGORY_STATIC(LogHealthComponent, All, All) 搭建处理函数框架 函数成员 private 委托类型FTakeAnyDamageSignature：从委托类型的定义获取处理函数签名；委托属性多播，支持蓝图，需要UFUNCTION宏 UFUNCTION() void OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 注册处理函数 函数成员 private 在BeginPlay中调用 void USTHealthComponent::RegisterDamageHandler() { AActor *ThisActor = GetOwner(); if (ThisActor) { ThisActor-\u0026gt;OnTakeAnyDamage.AddDynamic(this, \u0026amp;USTHealthComponent::OnTakeAnyDamage); } } 实现伤害委托处理函数 Health减为0，作为负数仍在减；差不多一秒10帧，即1s调用十次处理函数 触发处理函数时，不会传入整个FDamageEvent变量，而是传入UDamageType void USTHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) { Health -= Damage; } ",content:"Overview # 虚幻引擎提供一组函数，用来对Actor造成伤害 在Tick函数中，持续对游戏角色造成伤害；每次造成伤害，委托机制触发处理函数，更新角色生命值 一、每帧对 Character 造成伤害 # STBaseCharacter 函数成员 private 在Tick中调用 伤害来源是自己 void ASTBaseCharacter::CharacterTakeDamage() { TakeDamage(0.1f, FDamageEvent{}, GetController(), this); } 二、定义空的伤害委托处理函数，并注册到 Character # USTHealthComponent 包含头文件 源文件 #include \u0026quot;GameFramework/Actor.h\u0026quot; 定义日志类型 源文件 DEFINE_LOG_CATEGORY_STATIC(LogHealthComponent, All, All) 搭建处理函数框架 函数成员 private 委托类型FTakeAnyDamageSignature：从委托类型的定义获取处理函数签名；委托属性多播，支持蓝图，需要UFUNCTION宏 UFUNCTION() void OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 注册处理函数 函数成员 private 在BeginPlay中调用 void USTHealthComponent::RegisterDamageHandler() { AActor *ThisActor = GetOwner(); if (ThisActor) { ThisActor-\u0026gt;OnTakeAnyDamage.AddDynamic(this, \u0026amp;USTHealthComponent::OnTakeAnyDamage); } } 实现伤害委托处理函数 Health减为0，作为负数仍在减；差不多一秒10帧，即1s调用十次处理函数 触发处理函数时，不会传入整个FDamageEvent变量，而是传入UDamageType void USTHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) { Health -= Damage; } "}),e.add({id:9,href:"/docs/%E5%88%86%E4%BA%AB/emacs/org-mode/",title:"org-mode",description:"Overview # The Org Manual 样式 # 删除线 +Content+ 下划线 ox-hugo转markdown存在问题 _Content_ 文本块 =test= ~test~ 斜体 /test/ 加粗 *test* 选项设置 # 关闭toc Table of Contents #+OPTIONS: toc:nil 指定toc显示层级 #+TOC: headlines 2 上标和下标 a_b a^b 关闭 #+OPTIONS: ^:nil 需要使用{}转义 #+OPTIONS ^:{} a_{b} a^{b} 自动为标题添加标号 关闭 #+OPTIONS num:nil 选项合并 #+OPTIONS: toc:nil ^:{} #+STARTUP: showall hidestars 显示所有内容 #+STARTUP: showall 只显示一级标题 #+STARTUP: overview 隐藏星号 #+STARTUP: hidestars 模板 # Structure Templates C-c C-, org-insert-structure-template 代码框 填写编程语言 // C++样式 #+begin_src LANGUAGE #+end_src 文本框 文本框样式 #+begin_example #+end_example quote quote样式 #+begin_quote #+end_quote ",content:"Overview # The Org Manual 样式 # 删除线 +Content+ 下划线 ox-hugo转markdown存在问题 _Content_ 文本块 =test= ~test~ 斜体 /test/ 加粗 *test* 选项设置 # 关闭toc Table of Contents #+OPTIONS: toc:nil 指定toc显示层级 #+TOC: headlines 2 上标和下标 a_b a^b 关闭 #+OPTIONS: ^:nil 需要使用{}转义 #+OPTIONS ^:{} a_{b} a^{b} 自动为标题添加标号 关闭 #+OPTIONS num:nil 选项合并 #+OPTIONS: toc:nil ^:{} #+STARTUP: showall hidestars 显示所有内容 #+STARTUP: showall 只显示一级标题 #+STARTUP: overview 隐藏星号 #+STARTUP: hidestars 模板 # Structure Templates C-c C-, org-insert-structure-template 代码框 填写编程语言 // C++样式 #+begin_src LANGUAGE #+end_src 文本框 文本框样式 #+begin_example #+end_example quote quote样式 #+begin_quote #+end_quote "}),e.add({id:10,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/elisp/",title:"Elisp",description:"执行shell命令 # (shell-command \u0026quot;ps\u0026quot;) 当前文件路径+文件名 # (buffer-file-name) ",content:"执行shell命令 # (shell-command \u0026quot;ps\u0026quot;) 当前文件路径+文件名 # (buffer-file-name) "}),e.add({id:11,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/chrome/",title:"Chrome",description:"开发者工具 # F12 设置页面布局 查看日志 查看元素信息 跟踪事件 # 开始Record 停止 页面滚动事件 文章目录滚动 ",content:"开发者工具 # F12 设置页面布局 查看日志 查看元素信息 跟踪事件 # 开始Record 停止 页面滚动事件 文章目录滚动 "}),e.add({id:12,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E4%BD%BF%E7%94%A8ox-hugo%E8%AE%BE%E7%BD%AE%E9%80%89%E9%A1%B9/",title:"使用ox-hugo设置选项",description:"Overview # ox-hugo manual 根目录 # 如果使能 org-hugo-external-file-extensions-allowed-for-copying，要求根目录下必须有static文件夹，默认创建ox-hugo文件夹，并将图片拷贝到ox-hugo 分区对应 根目录/content/分区，默认创建content文件夹 #+HUGO_BASE_DIR: ../ 生成博文方式 # manual 子树 每个org子树作为一篇博文 ​* 每棵子树作为一篇博文 :PROPERTIES: :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true :weight 2 :END: ** 第一篇博文 ** 第二篇博文 org文件作为博文 #+HUGO_CUSTOM_FRONT_MATTER: :bookCollapseSection true :weight 20 #+HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true :weight 2 配置自定义选项 # 如果同时在子树和文件配置，根据子树导出时，只有子树定义项 子树 :PROPERTIES: :EXPROT_HUGO_CUSTOM_FRONT_MATTER: :foo bar :baz zoo :END: 文件 #+HUGO_CUSTOM_FRONT_MATTER: :foo bar :baz zoo 分区 + 样式 + 权重 # 子树 :PROPERTIES: :EXPORT_HUGO_SECTION: ./ :EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml :EXPORT_HUGO_WEIGHT: 4 :END: 文件 #+HUGO_SECTION: .",content:"Overview # ox-hugo manual 根目录 # 如果使能 org-hugo-external-file-extensions-allowed-for-copying，要求根目录下必须有static文件夹，默认创建ox-hugo文件夹，并将图片拷贝到ox-hugo 分区对应 根目录/content/分区，默认创建content文件夹 #+HUGO_BASE_DIR: ../ 生成博文方式 # manual 子树 每个org子树作为一篇博文 ​* 每棵子树作为一篇博文 :PROPERTIES: :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true :weight 2 :END: ** 第一篇博文 ** 第二篇博文 org文件作为博文 #+HUGO_CUSTOM_FRONT_MATTER: :bookCollapseSection true :weight 20 #+HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true :weight 2 配置自定义选项 # 如果同时在子树和文件配置，根据子树导出时，只有子树定义项 子树 :PROPERTIES: :EXPROT_HUGO_CUSTOM_FRONT_MATTER: :foo bar :baz zoo :END: 文件 #+HUGO_CUSTOM_FRONT_MATTER: :foo bar :baz zoo 分区 + 样式 + 权重 # 子树 :PROPERTIES: :EXPORT_HUGO_SECTION: ./ :EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml :EXPORT_HUGO_WEIGHT: 4 :END: 文件 #+HUGO_SECTION: ./ #+TITLE: Doks主题 #+HUGO_FRONT_MATTER_FORMAT: toml #+HUGO_WEIGHT: 10 文件 最后修改 # #+HUGO_AUTO_SET_LASTMOD: t 文件 草稿+分类+tag+日期 # 日期格式 yyyy-mm-dd，发布时会检查时区 #+HUGO_DRAFT: true #+HUGO_CATEGORIES: emacs #+HUGO_TAGS: hugo #+DATE: 2021-09-10 子树 分类+tag+日期+导出文件名 # * CATEGORY :@emacs: ** Doks主题 :hugo:org: :PROPERTIES: :EXPORT_DATE: 2023-06-07 :EXPORT_FILE_NAME: Doks主题 :END: 导出子树 # 参考 C-c C-e H A (org-hugo-export-wim-to-md :all-subtrees) 炫技 # title = \u0026quot;`(cdr (assoc \u0026quot;ITEM\u0026quot; (org-entry-properties)))`\u0026quot; date = \u0026quot;`(format-time-string \u0026quot;%Y-%m-%dT%H:%M:%S\u0026quot;)`\u0026quot; "}),e.add({id:13,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E6%8B%9F%E6%A6%B4%E5%BC%B9%E7%88%86%E7%82%B8/",title:"模拟榴弹爆炸",description:"Part 1 建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 Part 2 创建伤害来源 Dev/STDevDamageActor # 虚幻编辑器 STDevDamageActor，模拟榴弹爆炸 Actor 公有类 Part 3 准备工作 # C++ 屏蔽 ASTBaseCharacter::Tick中调用CharacterTakeDamage 添加头文件路径 ShootTraining/Source/ShootTraining/ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootTraining/Public/Player\u0026quot;, \u0026quot;ShootTraining/Public/Components\u0026quot;, \u0026quot;ShootTraining/Public/Dev\u0026quot; }); Part 4 实现 STDevDamageActor # C++ STDevDamageActor 一、添加可视化组件，使得伤害源可变换 # 添加 SceneComponent 数据成员 protected 蓝图可设置 UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent;	初始化 SceneComponent 函数成员 private 在构造函数中调用 void ASTDevDamageActor::InitSceneComponent() { SceneComponent = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(\u0026quot;SceneComponent\u0026quot;); SetRootComponent(SceneComponent); } 二、绘制球体，爆炸范围可视化 # 包含头文件 源文件 #include \u0026quot;DrawDebugHelpers.h\u0026quot; 球体半径和颜色 数据成员 protected 蓝图可设置 UPROPERTY(EditAnywhere) float Radius = 300.",content:"Part 1 建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 Part 2 创建伤害来源 Dev/STDevDamageActor # 虚幻编辑器 STDevDamageActor，模拟榴弹爆炸 Actor 公有类 Part 3 准备工作 # C++ 屏蔽 ASTBaseCharacter::Tick中调用CharacterTakeDamage 添加头文件路径 ShootTraining/Source/ShootTraining/ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootTraining/Public/Player\u0026quot;, \u0026quot;ShootTraining/Public/Components\u0026quot;, \u0026quot;ShootTraining/Public/Dev\u0026quot; }); Part 4 实现 STDevDamageActor # C++ STDevDamageActor 一、添加可视化组件，使得伤害源可变换 # 添加 SceneComponent 数据成员 protected 蓝图可设置 UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent;	初始化 SceneComponent 函数成员 private 在构造函数中调用 void ASTDevDamageActor::InitSceneComponent() { SceneComponent = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(\u0026quot;SceneComponent\u0026quot;); SetRootComponent(SceneComponent); } 二、绘制球体，爆炸范围可视化 # 包含头文件 源文件 #include \u0026quot;DrawDebugHelpers.h\u0026quot; 球体半径和颜色 数据成员 protected 蓝图可设置 UPROPERTY(EditAnywhere) float Radius = 300.0f; UPROPERTY(EditAnywhere) FColor SphereColor = FColor::Red; 绘制球体 函数成员 private 在Tick中调用，每帧都绘制球体 DrawDebugSphere 的第一个参数类型为 UWorld ，所以不用包含 UWorld 的头文件 void ASTDevDamageActor::DrawSphere() { DrawDebugSphere(GetWorld(), GetActorLocation(), Radius, 24, SphereColor); } 三、对伤害范围内 Actor 造成半径伤害 # 包含头文件 源文件 #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;Kismet/GameplayStatics.h\u0026quot; 伤害数值特征和半径伤害计算选项 数据成员 protected 蓝图可设置 UPROPERTY(EditAnywhere) float Damage = 10.0f; UPROPERTY(EditAnywhere) bool DoFullDamage = false; 对伤害范围内 Actor 造成半径伤害 函数成员 private 在Tick中调用 ApplyRadialDamage 的第一个参数类型为 UObject ，此时传入 UWorld ，需包含 UWorld 头文件 void ASTDevDamageActor::DevTakeDamage() { UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); } 在伤害处理函数 USTHealthComponent::OnTakeAnyDamage 中输出伤害值，验证 DoFullDamage 机制 UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;Damage: %.0f\u0026quot;), Damage); Part 5 在关卡中添加伤害源 # 虚幻编辑器 一、调整 BP_STBaseCharacter 的 Camera 组件位置 # 向上，向后 二、在关卡中添加 STDevDamageActor # 一个使用默认设置，根据 Character 到球心的距离计算伤害 另一个设置半径和颜色，处在伤害范围内受到伤害数值恒定（开销小） 调整 STDevDamageActor 的位置，效果图 三、验证 DoFullDamage # 处于蓝色球内，伤害值一致 处于红色球内，离球心越近，伤害值越大 球心在空中，跳跃也会缩短到球心的距离 四、伤害球内的所有Actor都会受到伤害 # "}),e.add({id:14,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6%E7%AF%87-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/",title:"插件篇 | 文件管理",description:"Overview # speedbar Emacs内置功能，可以浏览文件内符号 neotree 文件管理 treemacs 工作区管理，和tags文件协作时，亦支持浏览文件内符号 speedbar # (semantic-mode) ;; 使能mode，进行语义分析 (speedbar) ;; 打开文件目录 neotree # 安装 (use-package neotree :ensure t :config (global-set-key [f8] 'neotree-toggle) (setq neo-theme 'icons) ;; 无需安装all-the-icons ) 使用 操作 快捷键 上级目录 U 将光标所在目录设为根目录 C-c C-c 显示 / 隐藏 H 上一行 / 下一行 p / n 打开文件 SPC / RET 打开 / 关闭 目录 TAB 刷新目录 g 最大化 / 最小化 窗口 A 删除文件 C-c C-d treemacs # 安装 (use-package treemacs :ensure t :defer t :init (with-eval-after-load 'winum (define-key winum-keymap (kbd \u0026quot;M-0\u0026quot;) #'treemacs-select-window)) :config (progn ;;	(setq treemacs-show-cursor -1) (treemacs-resize-icons 15) (with-eval-after-load 'treemacs (define-key treemacs-mode-map [mouse-1] #'treemacs-single-click-expand-action)) ;; 单击打开文件 ) :bind (:map global-map (\u0026quot;M-0\u0026quot; .",content:"Overview # speedbar Emacs内置功能，可以浏览文件内符号 neotree 文件管理 treemacs 工作区管理，和tags文件协作时，亦支持浏览文件内符号 speedbar # (semantic-mode) ;; 使能mode，进行语义分析 (speedbar) ;; 打开文件目录 neotree # 安装 (use-package neotree :ensure t :config (global-set-key [f8] 'neotree-toggle) (setq neo-theme 'icons) ;; 无需安装all-the-icons ) 使用 操作 快捷键 上级目录 U 将光标所在目录设为根目录 C-c C-c 显示 / 隐藏 H 上一行 / 下一行 p / n 打开文件 SPC / RET 打开 / 关闭 目录 TAB 刷新目录 g 最大化 / 最小化 窗口 A 删除文件 C-c C-d treemacs # 安装 (use-package treemacs :ensure t :defer t :init (with-eval-after-load 'winum (define-key winum-keymap (kbd \u0026quot;M-0\u0026quot;) #'treemacs-select-window)) :config (progn ;;	(setq treemacs-show-cursor -1) (treemacs-resize-icons 15) (with-eval-after-load 'treemacs (define-key treemacs-mode-map [mouse-1] #'treemacs-single-click-expand-action)) ;; 单击打开文件 ) :bind (:map global-map (\u0026quot;M-0\u0026quot; . treemacs-select-window) (\u0026quot;C-x t 1\u0026quot; . treemacs-delete-other-windows) (\u0026quot;C-x t t\u0026quot; . treemacs) (\u0026quot;C-x t d\u0026quot; . treemacs-select-directory) (\u0026quot;C-x t B\u0026quot; . treemacs-bookmark) (\u0026quot;C-x t C-t\u0026quot; . treemacs-find-file) )) 1. 使用 # 创建工作区，以及设置工作区内项目 M-x 操作 函数 创建工作区 treemacs-create-workspace 添加项目 treemacs-add-project-to-workspace 切换工作区 treemacs-switch-workspace 配置主题 treemacs-load-theme 创建主题 treemacs-create-theme 修改主题 treemacs-modify-theme 操作 快捷键 操作 t h 显示/隐藏 隐藏文件 RET 在固定窗口打开文件 双击 在前一个窗口打开文件 2. 主题 # 安装 (use-package treemacs-all-the-icons :ensure t :config (treemacs-load-theme \u0026quot;all-the-icons\u0026quot;) ) 需要安装all-the-icons字体，无需安装all-the-icons 3. 自定义主题图标 # 图标使用all-the-icons或icons-in-terminal-re 查看文件类型的名称 (treemacs-icons-catalogue) 给出文件后缀，设置该类型文件图标 (defvar treemacs-custom-org-icon (all-the-icons-fileicon \u0026quot;org\u0026quot;)) ;;(defvar treemacs-custom-org-icon (all-the-icons-icon-for-file \u0026quot;name.org\u0026quot;)) (treemacs-define-custom-icon treemacs-custom-org-icon \u0026quot;org\u0026quot; \u0026quot;org_archive\u0026quot;) (defvar treemacs-custom-elisp-icon (all-the-icons-fileicon \u0026quot;elisp\u0026quot;)) ;;(defvar treemacs-custom-elisp-icon (all-the-icons-icon-for-file \u0026quot;name.el\u0026quot;)) (treemacs-define-custom-icon treemacs-custom-elisp-icon \u0026quot;el\u0026quot; \u0026quot;eln\u0026quot; \u0026quot;elc\u0026quot;) 通过文件类型名称设置图标 使用treemacs-all-the-icons-tab控制缩进 (treemacs-create-icon :icon (all-the-icons-octicon \u0026quot;file-directory\u0026quot;) :extensions (dir-closed)) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-directory\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (dir-closed dir-open) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot;%s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-directory\u0026quot; :v-adjust 0) treemacs-all-the-icons-tab) :extensions (root-closed root-open) :fallback 'same-as-icon) 创建主题 必须设置 root-open root-closed 的图标，其他类型未设置则无图标 使用all-the-icons (treemacs-create-theme \u0026quot;Use-all-the-icons\u0026quot; :config (progn (treemacs-create-icon :icon (format \u0026quot;%s%s\u0026quot; (all-the-icons-icon-for-file \u0026quot;name.org\u0026quot; :v-adjust 0) treemacs-all-the-icons-tab) :extensions (\u0026quot;org\u0026quot;)) (treemacs-create-icon :icon (format \u0026quot;%s%s\u0026quot; (all-the-icons-icon-for-file \u0026quot;name.el\u0026quot; :v-adjust 0) treemacs-all-the-icons-tab) :extensions (\u0026quot;el\u0026quot;)) (treemacs-create-icon :icon (format \u0026quot;%s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-directory\u0026quot; :v-adjust 0) treemacs-all-the-icons-tab) :extensions (dir-closed dir-open root-open root-closed)) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-fileicon \u0026quot;go\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;go\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-fileicon \u0026quot;markdownlint\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;markdown\u0026quot; \u0026quot;md\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-alltheicon \u0026quot;python\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;py\u0026quot; \u0026quot;pyc\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-code\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (fallback) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-code\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;png\u0026quot; \u0026quot;gif\u0026quot; \u0026quot;jpg\u0026quot; \u0026quot;jpeg\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-code\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;.gitignore\u0026quot; \u0026quot;cache\u0026quot; \u0026quot;apk\u0026quot; \u0026quot;pptx\u0026quot; \u0026quot;ppt\u0026quot; \u0026quot;xls\u0026quot; \u0026quot;xlsx\u0026quot; \u0026quot;pl\u0026quot; \u0026quot;dmg\u0026quot; \u0026quot;xmind\u0026quot; \u0026quot;desktop\u0026quot; \u0026quot;eld\u0026quot; \u0026quot;dap-breakpoints\u0026quot; ) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (all-the-icons-octicon \u0026quot;file-code\u0026quot; :v-adjust 0 :face 'all-the-icons-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;.lsp-session-v1\u0026quot; \u0026quot;amx-items\u0026quot; \u0026quot;recentf\u0026quot; ) :fallback 'same-as-icon) )) (treemacs-load-theme \u0026quot;Use-all-the-icons\u0026quot;) 使用icons-in-terminal (treemacs-create-theme \u0026quot;Use-icons-in-terminal\u0026quot; :config (progn (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-fileicon \u0026quot;org\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;org\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-octicon \u0026quot;file-directory\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (root-open root-closed) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-faicon \u0026quot;folder-open\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (dir-open) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-faicon \u0026quot;folder\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (dir-closed) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-octicon \u0026quot;file\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;note\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-octicon \u0026quot;markdown\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;markdown\u0026quot; \u0026quot;md\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-fileicon \u0026quot;elisp\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;el\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-fileicon \u0026quot;python\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;py\u0026quot; \u0026quot;pyc\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-faicon \u0026quot;file-text\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (fallback) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-faicon \u0026quot;image\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;png\u0026quot; \u0026quot;gif\u0026quot; \u0026quot;jpg\u0026quot; \u0026quot;jpeg\u0026quot;) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-octicon \u0026quot;file-text\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;.gitignore\u0026quot; \u0026quot;cache\u0026quot; \u0026quot;apk\u0026quot; \u0026quot;pptx\u0026quot; \u0026quot;ppt\u0026quot; \u0026quot;xls\u0026quot; \u0026quot;xlsx\u0026quot; \u0026quot;pl\u0026quot; \u0026quot;dmg\u0026quot; \u0026quot;xmind\u0026quot; \u0026quot;desktop\u0026quot; \u0026quot;eld\u0026quot; \u0026quot;dap-breakpoints\u0026quot; ) :fallback 'same-as-icon) (treemacs-create-icon :icon (format \u0026quot; %s%s\u0026quot; (icons-in-terminal-faicon \u0026quot;book\u0026quot; :v-adjust 0 :face 'icons-in-terminal-dblue) treemacs-all-the-icons-tab) :extensions (\u0026quot;.lsp-session-v1\u0026quot; \u0026quot;amx-items\u0026quot; \u0026quot;recentf\u0026quot; ) :fallback 'same-as-icon) )) (treemacs-load-theme \u0026quot;Use-icons-in-terminal\u0026quot;) "}),e.add({id:15,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/markdown/",title:"Markdown",description:"代码框 # ```elisp ``` 插入图片 # ![img](/pic/在本地运行ShooterGame示例项目/运行效果.png) 插入连接 # [参考](https://learn.microsoft.com/zh-cn/cpp/cpp/conditional-operator-q?view=msvc-170) 下划线 # \u0026lt;u\u0026gt;ddd\u0026lt;/u\u0026gt; 换行 # \u0026lt;br\u0026gt; 分隔线 # --- 注释 # \u0026lt;!--哈哈我是注释，不会在浏览器中显示。--\u0026gt; ",content:"代码框 # ```elisp ``` 插入图片 # ![img](/pic/在本地运行ShooterGame示例项目/运行效果.png) 插入连接 # [参考](https://learn.microsoft.com/zh-cn/cpp/cpp/conditional-operator-q?view=msvc-170) 下划线 # \u0026lt;u\u0026gt;ddd\u0026lt;/u\u0026gt; 换行 # \u0026lt;br\u0026gt; 分隔线 # --- 注释 # \u0026lt;!--哈哈我是注释，不会在浏览器中显示。--\u0026gt; "}),e.add({id:16,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/vscode/",title:"VSCode",description:"快捷键 # 操作 快捷键 减小字体 Command\u0026ndash; 放大字体 Command-+ 文件内查找 Command-F 注释代码 Command-K Command-C 去注释 Command-K Command-U 使用clang-format # 参考 安装扩展C/C++，自动安装clang-format 首选项 \u0026gt; Text Editor \u0026gt; Formatting，勾选 Format On Save 保存文件时，应用格式 插件 # 类别 C++ C/C++ C/C++ Extension Pack C/C++ Themes C# C# 项目编译 CMake CMakeTools 代码调试 CodeLLDB 主题 Dracula Official SynthWave '84 其他 file-picker Mono Debug Emacs 自定义快捷键无法使用 ",content:"快捷键 # 操作 快捷键 减小字体 Command\u0026ndash; 放大字体 Command-+ 文件内查找 Command-F 注释代码 Command-K Command-C 去注释 Command-K Command-U 使用clang-format # 参考 安装扩展C/C++，自动安装clang-format 首选项 \u0026gt; Text Editor \u0026gt; Formatting，勾选 Format On Save 保存文件时，应用格式 插件 # 类别 C++ C/C++ C/C++ Extension Pack C/C++ Themes C# C# 项目编译 CMake CMakeTools 代码调试 CodeLLDB 主题 Dracula Official SynthWave '84 其他 file-picker Mono Debug Emacs 自定义快捷键无法使用 "}),e.add({id:17,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E4%BC%A4%E5%AE%B3%E7%B1%BB%E5%9E%8B/",title:"使用伤害类型",description:"Part 1 创建伤害类型 # C++ 1. 创建 Dev/STFireDamageType # UDamageType 公有类 2. 创建 Dev/STIceDamageType # UDamageType 公有类 Part 2 为伤害来源添加伤害类型属性 # C++ Dev/STDevDamageActor 添加 DamamgeType 属性 protected 蓝图可设置 UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UDamageType\u0026gt; DamageType; 造成伤害时，传入 DamageType 函数成员 private 在Tick中调用 取消在Tick中调用DevTakeDamage void ASTDevDamageActor::DevTakeDamageWithDamageType() { UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); } Part 3 在 HealthComponent 输出伤害来源信息 # C++ STHealthComponent 在处理函数中，根据 DamageType 的具体类型，做出相应处理 包含头文件 #include \u0026quot;Dev/STFireDamageType.h\u0026quot; #include \u0026quot;Dev/STIceDamageType.h\u0026quot; 输出伤害来源信息 函数成员 private 在OnTakeAnyDamage中调用 void USTHealthComponent::HandleDamage(const UDamageType *DamageType) { if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !",content:"Part 1 创建伤害类型 # C++ 1. 创建 Dev/STFireDamageType # UDamageType 公有类 2. 创建 Dev/STIceDamageType # UDamageType 公有类 Part 2 为伤害来源添加伤害类型属性 # C++ Dev/STDevDamageActor 添加 DamamgeType 属性 protected 蓝图可设置 UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UDamageType\u0026gt; DamageType; 造成伤害时，传入 DamageType 函数成员 private 在Tick中调用 取消在Tick中调用DevTakeDamage void ASTDevDamageActor::DevTakeDamageWithDamageType() { UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); } Part 3 在 HealthComponent 输出伤害来源信息 # C++ STHealthComponent 在处理函数中，根据 DamageType 的具体类型，做出相应处理 包含头文件 #include \u0026quot;Dev/STFireDamageType.h\u0026quot; #include \u0026quot;Dev/STIceDamageType.h\u0026quot; 输出伤害来源信息 函数成员 private 在OnTakeAnyDamage中调用 void USTHealthComponent::HandleDamage(const UDamageType *DamageType) { if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !!!\u0026quot;)); } } } Part 4 查看 # 虚幻编辑器 一、为伤害来源设置 DamageType 属性 # DamageSphere-Red 选择 STFireDamageType DamageSphere-Blue 选择 STIceDamageType 二、查看日志 # 角色进入到 DamageSphere-Red ，去到处理函数 STFireDamageType 分支 角色进入到 DamageSphere-Blue ，去到处理函数 STIceDamageType 分支 "}),e.add({id:18,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/makefile/",title:"Makefile",description:"求C(n, k) = n! / (k! * (n - k)!) # 说明 combo(n, k) = C(n, k) fact(n) = n! fact.h // fact.h int fact(int); fact.cpp // fact.cpp #include \u0026quot;fact.h\u0026quot; int fact(int n) { int p = 1; for (int i = 1; i \u0026lt;= n; ++i) { p *= i; } return p; } combination.h // combination.h int combo(int n, int k); combination.cpp // combination.cpp #include \u0026quot;combination.h\u0026quot; #include \u0026quot;fact.h\u0026quot; int combo(int n, int k) { return fact(n) / fact(n-k) / fact(k); } main.",content:"求C(n, k) = n! / (k! * (n - k)!) # 说明 combo(n, k) = C(n, k) fact(n) = n! fact.h // fact.h int fact(int); fact.cpp // fact.cpp #include \u0026quot;fact.h\u0026quot; int fact(int n) { int p = 1; for (int i = 1; i \u0026lt;= n; ++i) { p *= i; } return p; } combination.h // combination.h int combo(int n, int k); combination.cpp // combination.cpp #include \u0026quot;combination.h\u0026quot; #include \u0026quot;fact.h\u0026quot; int combo(int n, int k) { return fact(n) / fact(n-k) / fact(k); } main.cpp // main.cpp #include \u0026lt;iostream\u0026gt; #include \u0026quot;combination.h\u0026quot; #include \u0026quot;fact.h\u0026quot; using std::cout; using std::endl; int main() { for (int i = 1; i \u0026lt; 10; ++i) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;:\u0026quot; \u0026lt;\u0026lt; fact(i) \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; combo(10, 3) \u0026lt;\u0026lt; endl; return 0; } 编写makefile # g++ 查询单个文件依赖 g++ -MM main.cpp 批量查询依赖 g++ -MM *cpp makefile main: main.o fact.o combination.o g++ -o main main.o fact.o combination.o combination.o: combination.cpp combination.h fact.h g++ -c combination.cpp fact.o: fact.cpp fact.h g++ -c fact.cpp main.o: main.cpp combination.h fact.h g++ -c main.cpp Emacs 编译命令 # (compile) 命令 make -p # g++ main.cpp fact.cpp combination.cpp "}),e.add({id:19,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/javascrpit/",title:"JavaScrpit",description:"foreach # 中断foreach循环不能使用break 获取窗口和显示器屏幕参数 # 参考 窗口 # 浏览器窗口可以改变大小 验证情况 内部高度 window.innerHeight o 内部宽度 window.innerWidth 外部高度 window.outerheight 外部宽度 window.outerwidth 显示器屏幕 # 验证情况 显示器屏幕高度，除windows任务栏以外 screen.availHeight 显示器屏幕宽度，除windows任务栏以外 screen.availWidth 显示器屏幕高度 screen.height 显示器屏幕宽度 screen.width 传参 # runoob 不需要给出参数类型 function myFunction(x, y = 10) { // y is 10 if not passed or undefined return x + y; } myFunction(0, 2) // 输出 2 myFunction(5); // 输出 15, y 参数的默认值 处理滚动 # 参考 注册 # 添加监听事件 滚动 window 所有滚动都会触发 window.",content:"foreach # 中断foreach循环不能使用break 获取窗口和显示器屏幕参数 # 参考 窗口 # 浏览器窗口可以改变大小 验证情况 内部高度 window.innerHeight o 内部宽度 window.innerWidth 外部高度 window.outerheight 外部宽度 window.outerwidth 显示器屏幕 # 验证情况 显示器屏幕高度，除windows任务栏以外 screen.availHeight 显示器屏幕宽度，除windows任务栏以外 screen.availWidth 显示器屏幕高度 screen.height 显示器屏幕宽度 screen.width 传参 # runoob 不需要给出参数类型 function myFunction(x, y = 10) { // y is 10 if not passed or undefined return x + y; } myFunction(0, 2) // 输出 2 myFunction(5); // 输出 15, y 参数的默认值 处理滚动 # 参考 注册 # 添加监听事件 滚动 window 所有滚动都会触发 window.addEventListener('scroll', () =\u0026gt; { // 处理滚动事件 }); Element 需要检查元素有效性；只在元素滚动时触发 let fullToc = document.querySelector('.docs-toc'); if (fullToc != null) { fullToc.addEventListener('scroll', () =\u0026gt; { // 处理滚动事件 }); } 给目标元素的onscroll属性绑定事件处理函数 页面滚动触发 window.onscroll = function () { // 处理滚动事件 }; [未验证] document.body.onscroll同window.onscroll [待验证] document.document.Element和document.body的区别，其scrollTop、clientHeight、scrollHeight参数 出处 设置元素滚动偏移 # 参数 说明 scrollLeft 和左侧偏移量 scrollTop 和顶部偏移量 滚动结束后处理 # 定时器 参考1 参考2 let timer = null; let fullToc = document.querySelector('.docs-toc'); if (fullToc != null) { fullToc.addEventListener('scroll', () =\u0026gt; { clearTimeout(timer); timer = setTimeout(function () { // 处理 }, 400); }); } 周期性处理滚动事件 [未验证] 节流 let scrolling = false; window.onscroll = () =\u0026gt; { scrolling = true; }; setInterval(() =\u0026gt; { if (scrolling) { scrolling = false; // 处理逻辑 } },300); .和# # class=\u0026quot;a\u0026quot; .a id=\u0026quot;b\u0026quot; #b querySelectorAll # runoob 返回NodeList类型对象 elementList = document.querySelectorAll('.my-toc a.active'); // .my-toc中，a标签，其包含类active elementList = document.querySelectorAll('.my-toc a'); // .my-toc中，a标签 subItem = document.querySelector(`.my-toc a[href=\u0026quot;#${id}\u0026quot;]`); //.my-toc中，href属性为${id}的a标签 document.querySelectorAll('h0[id],h1[id],h2[id],h3[id]'); // 所有有id属性的h0,h1,h2,h3标题 NodeList类型 # 获取元素个数 let count = document.querySelectorAll('.my-toc a').length; 按索引访问元素 参考 let res = document.querySelectorAll('.my-toc a'); if (res.length \u0026gt;= 1) { let active_heading = res.item(0); } 遍历元素 let count = 0, current = 0; document.querySelectorAll('.my-toc a').forEach((a) =\u0026gt; { if (a == active_heading) { current = count; // console.log(\u0026quot;current heading\u0026quot;, a); } ++count; }); "}),e.add({id:20,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%B7%BB%E5%8A%A0%E6%AD%BB%E4%BA%A1%E9%80%BB%E8%BE%91/",title:"为游戏角色添加死亡逻辑",description:"Part 1 使用委托：当生命值发生改变时，更新 TextRender 文本 # C++ 一、屏蔽当前 HealthText 的设置 # 之前，每帧都会根据生命值设置 TextRender 组件 ASTBaseCharacter::Tick中，屏蔽DisplayHealthText 在ASTBaseCharacter::BeginPlay中，调用DisplayHealthText初始化设置 先调用Component的BeginPlay，而后调用Character的BeginPlay 当前委托机制中，Character在BeginPlay中注册服务。如果由HealthComponent的BeginPlay中初始化生命值并广播，此时Character还未注册服务，广播在前，注册在后，则Character无法收到通知并初始化 TextRender 组件文本 二、使用委托修改HealthText，服务端修改 # Components/STHealthComponent OnTakeAnyDamage中，屏蔽HandleDamage 伤害类型仅做示例 定义委托类型 头文件 多播 仅C++ DECLARE_MULTICAST_DELEGATE(FOnHealthChanged) 添加委托类型成员 数据成员 public FOnHealthChanged OnHealthChanged; 生命值改变时，通知客户端 OnTakeAnyDamage OnHealthChanged.Broadcast(); 三、使用委托修改HealthText，客户端修改 # STBaseCharacter 处理函数 函数成员 private void ASTBaseCharacter::OnHealthChanged() { DisplayHealthText(); } 注册处理函数 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::BindOnHealthChanged() { Health-\u0026gt;OnHealthChanged.AddUObject(this, \u0026amp;ASTBaseCharacter::OnHealthChanged); } Part 2 若Character死亡，不再造成伤害 # C++ 一、判断Character死亡 # 函数成员 public 蓝图可调用，const函数 UFUNCTION(BlueprintCallable) bool IsDead() const { return Health \u0026lt;= 0.",content:"Part 1 使用委托：当生命值发生改变时，更新 TextRender 文本 # C++ 一、屏蔽当前 HealthText 的设置 # 之前，每帧都会根据生命值设置 TextRender 组件 ASTBaseCharacter::Tick中，屏蔽DisplayHealthText 在ASTBaseCharacter::BeginPlay中，调用DisplayHealthText初始化设置 先调用Component的BeginPlay，而后调用Character的BeginPlay 当前委托机制中，Character在BeginPlay中注册服务。如果由HealthComponent的BeginPlay中初始化生命值并广播，此时Character还未注册服务，广播在前，注册在后，则Character无法收到通知并初始化 TextRender 组件文本 二、使用委托修改HealthText，服务端修改 # Components/STHealthComponent OnTakeAnyDamage中，屏蔽HandleDamage 伤害类型仅做示例 定义委托类型 头文件 多播 仅C++ DECLARE_MULTICAST_DELEGATE(FOnHealthChanged) 添加委托类型成员 数据成员 public FOnHealthChanged OnHealthChanged; 生命值改变时，通知客户端 OnTakeAnyDamage OnHealthChanged.Broadcast(); 三、使用委托修改HealthText，客户端修改 # STBaseCharacter 处理函数 函数成员 private void ASTBaseCharacter::OnHealthChanged() { DisplayHealthText(); } 注册处理函数 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::BindOnHealthChanged() { Health-\u0026gt;OnHealthChanged.AddUObject(this, \u0026amp;ASTBaseCharacter::OnHealthChanged); } Part 2 若Character死亡，不再造成伤害 # C++ 一、判断Character死亡 # 函数成员 public 蓝图可调用，const函数 UFUNCTION(BlueprintCallable) bool IsDead() const { return Health \u0026lt;= 0.0f; } 二、重新实现的OnTakeAnyDamage # Character生命值不会小于0：OnTakeAnyDamage中，若伤害的数量特征不大于0，或者当前生命值不大于0，无法继续对Character造成伤害 void USTHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) { if (Damage \u0026lt;= 0.0f || IsDead()) return; // UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;Damage: %.0f\u0026quot;), Damage); // Health -= Damage; Health = FMath::Clamp(Health - Damage, 0.0f, MaxHealth); // HandleDamage(DamageType); OnHealthChanged.Broadcast(); } Part 3 若Character死亡，销毁Character # C++ 使用委托完成。当生命值发生改变时修改HealthText文本，当生命值变为0时销毁Character，一码归一码 一、服务端设置 # STHealthComponent 定义委托类型 DECLARE_MULTICAST_DELEGATE(FOnDeath) 添加委托类型数据成员 public FOnDeath OnDeath; 如Character死亡，通知客户端 函数成员 private 在OnTakeAnyDamage中调用 void USTHealthComponent::InformClientOnDeath() { if (IsDead()) { OnDeath.Broadcast(); } }	二、设置客户端 # STBaseCharacter 判断CharacterMovementComponent有效性 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::CheckCharacterMovement() { check(GetCharacterMovement()); } 实现处理函数：玩家失去对游戏角色的控制，定时销毁Character 函数成员 private void ASTBaseCharacter::OnDeath() { GetCharacterMovement()-\u0026gt;DisableMovement(); SetLifeSpan(5.0f); } 注册服务 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::BindOnDeath() { Health-\u0026gt;OnDeath.AddUObject(this, \u0026amp;ASTBaseCharacter::OnDeath); } Part 4 创建死亡动画剪辑 # 虚幻编辑器 参考之前的跳跃动画，跑步动画，转向动画，均对应状态机中的一个状态。如果当事件发生时，每个状态都可迁移到死亡状态，想想都觉得麻烦。 动画剪辑 AnimMontage 可以将多个动画组合播放。我们可以把希望连续播放的动画添加到时间线 timeline ，在代码或蓝图中播放动画剪辑。 使用动画剪辑 AnimMontage 资产，当事件发生时，播放死亡动画。 Slot 若此时有动画剪辑正在播放，输出输入动画和动画剪辑的拼接；若无动画剪辑在播放，输出输入动画 一、创建AnimMontage资产 # 命名参考 跑步动画资产 路径 ExternalContent/Animations/TTP_Animations/Death 选中跑步动画资产，右键 \u0026gt; Create \u0026gt; Create AnimMontage \u0026gt; 命名为AM_Death 移动到Content/Player/Animations/路径下 二、设置动画蓝图的输入 # ABP_BaseCharacter \u0026gt; AnimGraph 在Locomotion和OutputPose之间添加Slot 注意，Slot和AM_Death中分组应该一致 SlotName DefaultGroup.DefaultSlot Montage 三、设置动画剪辑 # AM_Death 死亡动画结束后，不再播放其他动画 Asset Details \u0026gt; BlendOptions \u0026gt; EnableAutoBlendOut，取消勾选 Part 5 Character死亡时，播放动画剪辑 # C++ STBaseCharacter 动画剪辑(AnimMontage)在C++中的类型为UAnimMontage 一、添加可配置动画剪辑属性 # 数据成员 protected 原型可设置 UPROPERTY(EditDefaultsOnly) UAnimMontage *DeathAnimMontage; 二、在Character死亡时，播放动画剪辑 # 在OnDeath开始处添加如下语句 PlayAnimMontage(DeathAnimMontage); Part 6 查看 # 虚幻编辑器 一、设置游戏角色死亡时播放的动画剪辑 # BP_STBaseCharacter AM_Death 二、效果图 # 禁止移动Character之后，销毁Character之前，仍可以移动摄像机；即，可以旋转Character(TurnAround) "}),e.add({id:21,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/sublime/",title:"Sublime",description:"快捷键 # 操作 分屏 View \u0026gt; Layout \u0026gt; 默认Single，选择Columns: 2 右侧分屏 Option-Command-N；2-4 下方分屏 Option-Command-Shift-N；2-3 右侧分屏和下方分屏不能同时进行 分屏复原 Option-Command-1 Grid分屏 田字型；Option-Command-5 打开命令面板 Windows Control-P MacOS Command-P 行号跳转 Control-G ",content:"快捷键 # 操作 分屏 View \u0026gt; Layout \u0026gt; 默认Single，选择Columns: 2 右侧分屏 Option-Command-N；2-4 下方分屏 Option-Command-Shift-N；2-3 右侧分屏和下方分屏不能同时进行 分屏复原 Option-Command-1 Grid分屏 田字型；Option-Command-5 打开命令面板 Windows Control-P MacOS Command-P 行号跳转 Control-G "}),e.add({id:22,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E8%A7%82%E5%AF%9F%E8%A7%86%E8%A7%92/",title:"添加观察视角",description:"Overview # 观察视角的实现，对应一个APawn派生类，ASpectatorPawn。关卡的默认类型里，观察者类即使用ASpectatorPawn。 场景中的SpectatorPawn，即漂浮的摄像机，可以前后左右上下移动，键位控制，可以旋转，由鼠标控制。 观察视角的存在，使得玩家死亡后，仍能继续观看游戏。当Character死亡并销毁，Controller无其他Pawn可控制。当Character死亡后，使Controller切换到ASpectatorPawn对象。 本小节使用默认的观察者类，所做的修改在STBaseCharacter中。 Part 1 Character死亡后，切换到观察视角 # C++ STBaseCharacter 添加头文件 先前我们已设置STBaseCharacter使用STPlayerController类。 APawn::Controller成员和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STPlayerController的 #include \u0026quot;GameFramework/Controller.h\u0026quot; Character死亡时，使用观察视角 private 在Character死亡处理函数OnDeath中调用 void ASTBaseCharacter::SwitchToSpectatorPawn() { if (Controller) { Controller-\u0026gt;ChangeState(NAME_Spectating); } } Part 2 查看 # 虚幻编辑器 查看WorldSetting中，GameMode使用的Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 Character死亡后，世界大纲新增SpectatorPawn1 因为Character死亡的处理函数中，立即切换到SpectatorPawn，在Character销毁之前，无法继续操作Character，也就无法旋转Character的Camera ",content:"Overview # 观察视角的实现，对应一个APawn派生类，ASpectatorPawn。关卡的默认类型里，观察者类即使用ASpectatorPawn。 场景中的SpectatorPawn，即漂浮的摄像机，可以前后左右上下移动，键位控制，可以旋转，由鼠标控制。 观察视角的存在，使得玩家死亡后，仍能继续观看游戏。当Character死亡并销毁，Controller无其他Pawn可控制。当Character死亡后，使Controller切换到ASpectatorPawn对象。 本小节使用默认的观察者类，所做的修改在STBaseCharacter中。 Part 1 Character死亡后，切换到观察视角 # C++ STBaseCharacter 添加头文件 先前我们已设置STBaseCharacter使用STPlayerController类。 APawn::Controller成员和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STPlayerController的 #include \u0026quot;GameFramework/Controller.h\u0026quot; Character死亡时，使用观察视角 private 在Character死亡处理函数OnDeath中调用 void ASTBaseCharacter::SwitchToSpectatorPawn() { if (Controller) { Controller-\u0026gt;ChangeState(NAME_Spectating); } } Part 2 查看 # 虚幻编辑器 查看WorldSetting中，GameMode使用的Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 Character死亡后，世界大纲新增SpectatorPawn1 因为Character死亡的处理函数中，立即切换到SpectatorPawn，在Character销毁之前，无法继续操作Character，也就无法旋转Character的Camera "}),e.add({id:23,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%8A%A8%E6%B2%BB%E7%96%97/",title:"自动治疗",description:"Overview # 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现。获取定时器管理对象有两种方式 UActorComponent::GetOwner \u0026gt; AActor::GetWorldTimerManager UActorComponent::GetWorld \u0026gt; UWorld::GetTimerManager 修改HealthComponent逻辑 C++ 一、封装更新生命值逻辑 # 之前在处理函数OnTakeAnyDamage中，更新生命值并广播。现在会有两个地方改变生命值，新增自动治疗，所以封装改变生命值逻辑。 受到伤害和自动治疗均会修改生命值，随之通知客户端(STBaseCharacter)修改HealthText。 函数成员 private 在OnTakeAnyDamage计算伤害时，改为调用SetHealth void USTHealthComponent::SetHealth(float NewHealth) { Health = FMath::Clamp(NewHealth, 0.0f, MaxHealth); OnHealthChanged.Broadcast(); } 二、添加治疗参数 # 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealDelay = 3.",content:"Overview # 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现。获取定时器管理对象有两种方式 UActorComponent::GetOwner \u0026gt; AActor::GetWorldTimerManager UActorComponent::GetWorld \u0026gt; UWorld::GetTimerManager 修改HealthComponent逻辑 C++ 一、封装更新生命值逻辑 # 之前在处理函数OnTakeAnyDamage中，更新生命值并广播。现在会有两个地方改变生命值，新增自动治疗，所以封装改变生命值逻辑。 受到伤害和自动治疗均会修改生命值，随之通知客户端(STBaseCharacter)修改HealthText。 函数成员 private 在OnTakeAnyDamage计算伤害时，改为调用SetHealth void USTHealthComponent::SetHealth(float NewHealth) { Health = FMath::Clamp(NewHealth, 0.0f, MaxHealth); OnHealthChanged.Broadcast(); } 二、添加治疗参数 # 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealDelay = 3.0f; UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Auto Heal\u0026quot;, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealModifier = 5.0f; 三、添加定时器 # 添加定时器 数据成员 private FTimerHandle HealTimer; 包含头文件 源文件 #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;TimerManager.h\u0026quot; 生命值满格时关闭定时器；收到伤害时关闭定时器 添加函数 private OnTakeAnyDamage中调用 恢复到满生命值时调用 void USTHealthComponent::StopHealTimer() { if (AutoHeal \u0026amp;\u0026amp; GetWorld()) { GetWorld()-\u0026gt;GetTimerManager().ClearTimer(HealTimer); } } 定时器回调函数 函数成员 private void USTHealthComponent::HealUpdate() { SetHealth(Health + HealModifier); if (FMath::IsNearlyEqual(Health, MaxHealth)) { StopHealTimer(); } } 初始化定时器 函数成员 private OnTakeAnyDamage最后调用，受到伤害后，延后开始自动治疗 void USTHealthComponent::InitHealTimer() { if (!IsDead() \u0026amp;\u0026amp; AutoHeal \u0026amp;\u0026amp; GetWorld()) { GetWorld()-\u0026gt;GetTimerManager().SetTimer(HealTimer, this, \u0026amp;USTHealthComponent::HealUpdate, HealRate, true, HealDelay); } } 四、重写IsDead # bool IsDead() const { return FMath::IsNearlyZero(Health); } "}),e.add({id:24,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E9%AB%98%E5%A4%84%E5%9D%A0%E8%90%BD%E4%BC%A4%E5%AE%B3/",title:"高处坠落伤害",description:"Overview # STBaseCharacter逻辑 C++ 落地时获取Z方向的速度，其和坠落高度相关，速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落伤害范围 LandedDamageRange [c, d] 落地时速度范围 LandedDamageVelocityRange [a, b] 速度小于a无伤； 在[a, b]范围内，对应伤害[c, d] c + (Velocity - a) (d - c) / (b - a) 速度大于b，伤害为d 在Character中获取速度的方式有两种： APawn::GetVelocity ACharacter:: GetCharacterMovement \u0026gt; UCharacterMovementComponent::Velocity 一、添加属性 # 原型可设置 参数 名称 LandedDamageRange 伤害范围 LandedDamageVelocityRange 落地受伤的速度范围 UPROPERTY(EditDefaultsOnly) FVector2D LandedDamageVelocityRange = {900.0f, 1200.0f}; UPROPERTY(EditDefaultsOnly)	FVector2D LandedDamageRange = {10.0f, 100.0f}; 二、订阅委托 # 委托处理函数 函数成员 private 委托支持蓝图 声明 UFUNCTION() void OnGroundLanded(const FHitResult\u0026amp; Hit); OnLanded已被使用 实现 坠落伤害属于环境伤害，无伤害源(Actor)和阵营(Controller) void ASTBaseCharacter::OnGroundLanded(const FHitResult\u0026amp; Hit) { float Velocity = -GetVelocity().",content:"Overview # STBaseCharacter逻辑 C++ 落地时获取Z方向的速度，其和坠落高度相关，速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落伤害范围 LandedDamageRange [c, d] 落地时速度范围 LandedDamageVelocityRange [a, b] 速度小于a无伤； 在[a, b]范围内，对应伤害[c, d] c + (Velocity - a) (d - c) / (b - a) 速度大于b，伤害为d 在Character中获取速度的方式有两种： APawn::GetVelocity ACharacter:: GetCharacterMovement \u0026gt; UCharacterMovementComponent::Velocity 一、添加属性 # 原型可设置 参数 名称 LandedDamageRange 伤害范围 LandedDamageVelocityRange 落地受伤的速度范围 UPROPERTY(EditDefaultsOnly) FVector2D LandedDamageVelocityRange = {900.0f, 1200.0f}; UPROPERTY(EditDefaultsOnly)	FVector2D LandedDamageRange = {10.0f, 100.0f}; 二、订阅委托 # 委托处理函数 函数成员 private 委托支持蓝图 声明 UFUNCTION() void OnGroundLanded(const FHitResult\u0026amp; Hit); OnLanded已被使用 实现 坠落伤害属于环境伤害，无伤害源(Actor)和阵营(Controller) void ASTBaseCharacter::OnGroundLanded(const FHitResult\u0026amp; Hit) { float Velocity = -GetVelocity().Z; UE_LOG(LogBaseCharacter, Log, TEXT(\u0026quot;Velocity: %0.f\u0026quot;), Velocity); if (Velocity \u0026lt; LandedDamageVelocityRange.X) return; float LandedDamage = FMath::GetMappedRangeValueClamped(LandedDamageVelocityRange, LandedDamageRange, Velocity); UE_LOG(LogBaseCharacter, Log, TEXT(\u0026quot;Damage: %0.f\u0026quot;), LandedDamage); TakeDamage(LandedDamage, FDamageEvent{}, nullptr, nullptr); } 注册委托 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::BindOnLanded() { LandedDelegate.AddDynamic(this, \u0026amp;ASTBaseCharacter::OnGroundLanded); } "}),e.add({id:25,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F%E5%92%8C%E6%94%B6%E5%B0%BE/",title:"打包游戏和收尾",description:"一、打包游戏 # Shipping看不到Debug球 二、优化 # 定义委托类型之后，使用分号 定义委托类型时，类型名以F打头，以Signature结尾 建议 类定义顺序 public 构造函数 \u0026gt; 委托类型变量 \u0026gt; UFUNCTION \u0026gt; 其他函数 添加LifeSpanOnDeath属性 蓝图可设置 在SetupPlayerInputComponent中检查PlayInputComponent ",content:"一、打包游戏 # Shipping看不到Debug球 二、优化 # 定义委托类型之后，使用分号 定义委托类型时，类型名以F打头，以Signature结尾 建议 类定义顺序 public 构造函数 \u0026gt; 委托类型变量 \u0026gt; UFUNCTION \u0026gt; 其他函数 添加LifeSpanOnDeath属性 蓝图可设置 在SetupPlayerInputComponent中检查PlayInputComponent "}),e.add({id:26,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/",title:"代码重构",description:"Part 1 新增 Components/STHealthComponent # C++ STHEalthComponent 当前生命值和最大生命值 数据成员 Health MaxHealth 提供 public 接口，可以获取当前生命值 函数成员 GetHealth 提供 public 接口，判断角色是否死亡 函数成员 IsDead 定义委托类型并添加数据成员，生命值改变时通知 FOnHealthChangedSignature 定义委托类型并添加数据成员，生命值为0时通知 FOnDeathSignature 提供 private 接口，更新生命值并通知 SetHealth 添加定时器，受到伤害后延后治疗 数据成员 参数 名称 使能自动治疗 AutoHeal 治疗量 HealModifier 治疗频率 HealRate 延后治疗时长 HealDelay 函数成员 函数 名称 回调函数 OnHealTrigger 开启定时器 StartHealTimer 关闭定时器 StopHealTimer 注册受伤处理函数，更新生命值，死亡时广播 函数成员 OnTakeAnyDamage Part 2 为Character添加HealthComponent和TextRender组件 # C++ STBaseCharacter 添加组件并初始化 添加函数，修改HealthText组件文本；初始化和生命值改变时调用 注册HealthComponent的OnHealthChanged 添加数据成员，蓝图可设置死亡动画剪辑 添加数据成员，蓝图可设置角色死亡销毁延时 注册HealthComponent的OnDeath 角色死亡时，播放死亡动画剪辑，禁止控制游戏角色，定时销毁，并切换到观察者视角 添加数据成员，坠落伤害范围和受到伤害时落地速度范围 添加函数成员，坠落时委托处理函数，并注册委托服务 Part 3 新增 Dev/STDevDamageActor # C++ STDevDamageActor 添加SceneComponent，使能变换 添加数据成员，设置球体颜色和半径 绘制球体，显示爆炸伤害范围 添加数据成员，设置伤害数值特征和计算伤害选项 对伤害半径内的角色造成伤害 Part 4 相关设置 # 虚幻编辑器 调整TextRender组件 创建死亡动画剪辑 AM_Death，并设置AM_Death播放完结束 在动画蓝图中，通过Slot，连接状态机动画和OutputPose ABP_BaseCharacter \u0026gt; AnimGraph 设置DeathAnimMontage属性 AM_Death BP_STBaseCharacter 在场景中添加伤害源 Part 5 项目结构更新 # 资产 Content/ ExternalContent/ Levels/ DefaultMap Player/ Animations/ ABP_BaseCharacter BS_Run BS_Walk AM_Death BP_STBaseCharacter [-] BP_STPlayerController BP_STGameModeBase C++ ShootTrainingSecond/ ShootTrainingSecondGameModeBase Public/ Components/ STCharacterMovementComponent STHealthComponent Player/ STBaseCharacter [-] STPlayerController Dev/ STDevDamageActor Part 6 阶段性总结 # 一、游戏角色 # C++ Player/STBaseCharacter Blueprint Player/BP_STBaseCharacter Player/Animations/ABP_BaseCharacter 其他 Player/Animations Blueprint BS_Run BS_Walk AM_Death 1.",content:"Part 1 新增 Components/STHealthComponent # C++ STHEalthComponent 当前生命值和最大生命值 数据成员 Health MaxHealth 提供 public 接口，可以获取当前生命值 函数成员 GetHealth 提供 public 接口，判断角色是否死亡 函数成员 IsDead 定义委托类型并添加数据成员，生命值改变时通知 FOnHealthChangedSignature 定义委托类型并添加数据成员，生命值为0时通知 FOnDeathSignature 提供 private 接口，更新生命值并通知 SetHealth 添加定时器，受到伤害后延后治疗 数据成员 参数 名称 使能自动治疗 AutoHeal 治疗量 HealModifier 治疗频率 HealRate 延后治疗时长 HealDelay 函数成员 函数 名称 回调函数 OnHealTrigger 开启定时器 StartHealTimer 关闭定时器 StopHealTimer 注册受伤处理函数，更新生命值，死亡时广播 函数成员 OnTakeAnyDamage Part 2 为Character添加HealthComponent和TextRender组件 # C++ STBaseCharacter 添加组件并初始化 添加函数，修改HealthText组件文本；初始化和生命值改变时调用 注册HealthComponent的OnHealthChanged 添加数据成员，蓝图可设置死亡动画剪辑 添加数据成员，蓝图可设置角色死亡销毁延时 注册HealthComponent的OnDeath 角色死亡时，播放死亡动画剪辑，禁止控制游戏角色，定时销毁，并切换到观察者视角 添加数据成员，坠落伤害范围和受到伤害时落地速度范围 添加函数成员，坠落时委托处理函数，并注册委托服务 Part 3 新增 Dev/STDevDamageActor # C++ STDevDamageActor 添加SceneComponent，使能变换 添加数据成员，设置球体颜色和半径 绘制球体，显示爆炸伤害范围 添加数据成员，设置伤害数值特征和计算伤害选项 对伤害半径内的角色造成伤害 Part 4 相关设置 # 虚幻编辑器 调整TextRender组件 创建死亡动画剪辑 AM_Death，并设置AM_Death播放完结束 在动画蓝图中，通过Slot，连接状态机动画和OutputPose ABP_BaseCharacter \u0026gt; AnimGraph 设置DeathAnimMontage属性 AM_Death BP_STBaseCharacter 在场景中添加伤害源 Part 5 项目结构更新 # 资产 Content/ ExternalContent/ Levels/ DefaultMap Player/ Animations/ ABP_BaseCharacter BS_Run BS_Walk AM_Death BP_STBaseCharacter [-] BP_STPlayerController BP_STGameModeBase C++ ShootTrainingSecond/ ShootTrainingSecondGameModeBase Public/ Components/ STCharacterMovementComponent STHealthComponent Player/ STBaseCharacter [-] STPlayerController Dev/ STDevDamageActor Part 6 阶段性总结 # 一、游戏角色 # C++ Player/STBaseCharacter Blueprint Player/BP_STBaseCharacter Player/Animations/ABP_BaseCharacter 其他 Player/Animations Blueprint BS_Run BS_Walk AM_Death 1. C++ STBaseCharacter # 函数成员 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 委托 委托成员 作用 处理函数 操作 HealthComponent::OnHealthChanged 修改显示生命值 OnHealthChanged 调用DisplayHealthText HealthComponent::OnDeath 游戏角色死亡处理 OnDeath 播放死亡动画剪辑；禁止操作Character；定时销毁；切换到观察视角 ACharacter::LandedDelegate 计算落地伤害 OnGroundLanded 计算落地伤害；对Character调用TakeDamage 键位绑定 回调函数 键位 相关函数 MoveRight 左右移动 AddMovementInput；GetActorRightVector MoveForward 前后移动 AddMovementInput；GetActorForwardVector 左右旋转 ACharacter::AddControllerYawInput 上下旋转 ACharacter::AddControllerPitchInput 跳跃 ACharacter::Jump RunEnable，RunDisable 跑步 功能函数 函数 操作 相关函数 DisplayHealthText 设置TextRender文本 HealthTextComponent UTextRenderComponent::SetText 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STCharacterMovementComponent使用；供ABP_STBaseCharacter使用 数据成员 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 HealthComponent 生命值系统 HealthTextComponent 显示生命值 CharacterMovementComponent 运动组件 标志位 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 游戏角色死亡逻辑 DeathAnimMontage 死亡动画剪辑 LifeSpanOnDeath 销毁角色定时间隔 落地伤害逻辑 LandedDamageRange 伤害范围 LandedDamageVelocityRange 造成伤害的速度范围 2. Blueprint Player/BP_STBaseCharacter # CapsuleComponent HealthTextComponent Horizontal Alignment Center SpringArmComponent UsePawnControlRotation true MeshComponent Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter 3. Blueprint Player/Animations/ABP_BaseCharacter # AnimGraph Locomotion \u0026gt; Slot \u0026gt; OutputPose 状态 状态 说明 走路 Walk BS_Walk；混合空间 跑步 Run BS_Run；混合空间1D 跳跃 JumpStart JumpLoop JumpEnd 死亡 AM_Death；动画剪辑 动画输入 速度 Velocity 速度和前进方向的夹角 Directon 转换条件 IsRunning C++ 满足3个条件：按下Shift；速度和前进方向夹角为0（按下W）；速度不为0 IsFalling CharacterMovementComponent::IsFalling 返回true，意味着游戏角色跳起；接着返回false，意味着游戏角色回到地面 EventGraph 设置变量 Velocity Directon IsRunning IsFalling 二、组件 # C++ 1. STCharacterMovementComponent # 满足跑步判断时，增加最大速度 SpeedAcceleration 可设置类数据成员初始值；速度系数 2. STHealthCompoennt # 函数成员 基本函数 操作 构造函数 每帧调用Tick标志位置为false BeginPlay 初始化生命值；注册Actor::OnTakeAnyDamage TickComponent 屏蔽 接口 接口函数 操作 GetHealth 获取当前生命值；STBaseCharacter调用 内部逻辑 IsDead 判断角色是否死亡 SetHealth 修改生命值；受到伤害或治疗时调用，随之广播 治疗 OnHealTrigger 定时器回调函数；治疗；满生命值停止定时器 StartHealTimer 受到伤害则开启定时器 StopHealTimer 收到伤害会关闭之前开启的定时器；满生命值时停止定时器 受伤处理函数 OnTakeAnyDamage 进入条件：伤害为正数，当前角色存活；受伤后，停止已开启的治疗定时器；更新生命值；若角色死亡，广播，否则，开启治疗定时器 数据成员 Health 生命值 MaxHealth 最大生命值 委托成员 OnHealthChanged 修改生命值(SetHealth)时广播 OnDeath 受到伤害时，若死亡，广播 治疗 HealTimer 定时器 AutoHeal 使能治疗 HealModifier 治疗量 HealRate 治疗频率 HealDelay 治疗延时 三、伤害源 # 函数成员 基本函数 操作 构造函数 初始化组件 BeginPlay Tick 绘制球体模拟爆炸范围；对球体内以及相交Actor造成伤害 数据成员 SceneComponent 变换属性 Radius 球体半径 SphereColor 球体颜色 Damage 伤害的数值特征 DoFullDamage 计算伤害机制标志位 "}),e.add({id:27,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/",title:"角色和动画",description:"",content:""}),e.add({id:28,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/",title:"基础课程",description:"",content:""}),e.add({id:29,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/",title:"虚幻引擎",description:"",content:""}),e.add({id:30,href:"/docs/%E5%88%86%E4%BA%AB/hugo/doks%E4%B8%BB%E9%A2%98/",title:"Doks主题",description:"Overview # demo github 依赖 说明 Git 并不知道为什么会依赖Git Node.js 前端插件 环境 Github Node.js Doks Hugo 安装依赖 # Git git --version Node.js 官网下载 18.16.0 LTS node --version npm --version npm config list # 查看配置 # 设置代理 npm config set proxy http://localhost:15236 npm config set https-proxy http://localhost:15236 # 如果代理不支持https npm config set registry \u0026quot;http://registry.npmjs.org\u0026quot; 初始化项目 # 下载到本地 和之前的hugo theme不同，不放到theme/，而是直接作为项目 官网提供两个项目，Child theme适合新手 git clone https://github.com/h-enk/doks.git doks 安装node modules npm install 本地部署服务器 不建议，会删除./public文件夹 npm run start 访问 http://localhost:1313/ 项目结构 # 基础结构 基础结构 说明 package.",content:"Overview # demo github 依赖 说明 Git 并不知道为什么会依赖Git Node.js 前端插件 环境 Github Node.js Doks Hugo 安装依赖 # Git git --version Node.js 官网下载 18.16.0 LTS node --version npm --version npm config list # 查看配置 # 设置代理 npm config set proxy http://localhost:15236 npm config set https-proxy http://localhost:15236 # 如果代理不支持https npm config set registry \u0026quot;http://registry.npmjs.org\u0026quot; 初始化项目 # 下载到本地 和之前的hugo theme不同，不放到theme/，而是直接作为项目 官网提供两个项目，Child theme适合新手 git clone https://github.com/h-enk/doks.git doks 安装node modules npm install 本地部署服务器 不建议，会删除./public文件夹 npm run start 访问 http://localhost:1313/ 项目结构 # 基础结构 基础结构 说明 package.json和package-lock.json node modules信息；npm install命令根据这些信息安装需要的modules node_modules/ 下载的node modules archetypes/ 模板 static/ 可以把图片放在这 content/ 子文件对应一种语言 config/ 配置文件的查找可以是config.toml，也可以是config/_default/config.toml；支持更多配置 assets/ js和css代码 node.js node_modules/ 说明 bootstrap bootstrap插件大本营；getbootstrap 5.3.0 highlight.js 可配置的语法高亮 highLight.js/ 说明 scss highLight.js提供的高亮主题；下载的高亮主题保存到这里 lib/languages 支持高亮的语言 配置文件 config/_default/ 说明 menus/ 不同语言的主页配置 config.toml 类似简单的config.toml languages.toml 配置语言选项 markup.toml toc显示的层级 params.toml 简单config.toml的部分功能；此处可设置主题选项 darkMode ，采用doks还是hugo提供的高亮 highLight ；横向路径导航 breadCrumb ；全尺寸布局 fullWidth ；试验高亮目录 scrollSpy 设置语言 # 添加menu ./config/_default/menus/menus.zh.toml 设置语言 // ./config/_default/config.toml # Multilingual ## defaultContentLanguage = \u0026quot;en\u0026quot; ## disableLanguages = [\u0026quot;de\u0026quot;, \u0026quot;nl\u0026quot;] # defaultContentLanguageInSubdir = true defaultContentLanguage = \u0026quot;zh\u0026quot; disableLanguages = [\u0026quot;de\u0026quot;, \u0026quot;nl\u0026quot;, \u0026quot;en\u0026quot;] 设置语言项 // ./config/_default/languages.toml [zh] languageName = \u0026quot;Chinese\u0026quot; contentDir = \u0026quot;content/zh\u0026quot; weight = 5 [zh.params] languageISO = \u0026quot;ZH\u0026quot; languageTag = \u0026quot;zh-CN\u0026quot; 设置翻译 新增 ./i18n/zh.yaml，同en.yaml 设置中文对应content 创建文件夹 content/zh content/zh/blog content/zh/docs 设置主页 # 1. title # # ./config/_default/params.toml ## title = \u0026quot;Doks\u0026quot; title = \u0026quot;ToughCactus\u0026quot; 2. get-started 链接 # \u0026lt;!-- ./layout/index.html :9 --\u0026gt; \u0026lt;a class=\u0026quot;btn btn-primary btn-lg px-4 mb-2\u0026quot; href=\u0026quot;/docs/{{ if .Site.Params.options.docsVersioning }}{{ .Site.Params.docsVersion }}/{{ end }}prologue/introduction/\u0026quot; role=\u0026quot;button\u0026quot;\u0026gt;{{ i18n \u0026quot;get-started\u0026quot; }}\u0026lt;/a\u0026gt; 3. 文本块 # 定义 my-sidebar-prefooter \u0026lt;!-- ./layout/index.html :60 --\u0026gt; {{ define \u0026quot;my-sidebar-prefooter\u0026quot; }} {{ if eq $.Site.Language.LanguageName \u0026quot;Chinese\u0026quot; }} \u0026lt;section class=\u0026quot;section section-sm\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;row justify-content-center text-center\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;虚幻引擎\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;C++, 蓝图.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;开发工具 ⚡️\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Git, VSCode.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;开发语言\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Bash.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;row justify-content-center text-center\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;C++\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;Emacs\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;图形学\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;row justify-content-center text-center\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;Hugo\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026quot;/docs/分享/hugo/doks主题/\u0026quot;\u0026gt;Doks主题\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;MacOS应用\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;col-lg-5\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;h4\u0026quot;\u0026gt;Linux\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; {{ end }} {{ end }} 激活 \u0026lt;!-- ./layout/_default/baseof.html :22 --\u0026gt; {{ block \u0026quot;my-sidebar-prefooter\u0026quot; . }}{{ end }} 4. 文本 # \u0026lt;!-- ./content/zh/_index.html --\u0026gt; --- title : \u0026quot;好记性不如烂键盘。\u0026quot; description: \u0026quot;none.\u0026quot; lead: \u0026quot;\u0026quot; date: \u0026quot;\u0026quot; lastmod: \u0026quot;\u0026quot; draft: false images: [] --- 5. footer # # ./config/_default/params.toml ## footer = \u0026quot;Powered by \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://www.netlify.com/\\\u0026quot;\u0026gt;Netlify\u0026lt;/a\u0026gt;, \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://gohugo.io/\\\u0026quot;\u0026gt;Hugo\u0026lt;/a\u0026gt;, and \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://getdoks.org/\\\u0026quot;\u0026gt;Doks\u0026lt;/a\u0026gt;\u0026quot; footer = \u0026quot;Powered by \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://github.com/\\\u0026quot;\u0026gt;Github\u0026lt;/a\u0026gt;, \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://gohugo.io/\\\u0026quot;\u0026gt;Hugo\u0026lt;/a\u0026gt;, and \u0026lt;a class=\\\u0026quot;text-muted\\\u0026quot; href=\\\u0026quot;https://getdoks.org/\\\u0026quot;\u0026gt;Doks\u0026lt;/a\u0026gt;\u0026quot; 自定义配置 # 1. 横向路径导航 # Breadcrumb Navigation # ./config/_default/params.toml ## breadCrumb = false breadCrumb = true 2. 全尺寸布局 # # config/_default/params.toml ## fullWidth = true fullWidth = true 3. 试验高亮目录 # # config/_default/params.toml scrollSpy = false # experimental; needs Bootstrap \u0026gt;= 5.2.0-beta1 scrollSpy是node.js module 4. 使用highlight.js # hightlight.js 官网 开关 为false使用hugo默认代码高亮；为true则使用node modules，可以自行配置 # ./config/_default/params.toml highLight = true 下载高亮主题 Dracula git clone https://github.com/dracula/highlightjs.git cp Dracula/highlightjs/dracula.css doks/node_modules/highlight.js/scss/ 设置高亮主题 // ./assets/scss/app.scss // @import \u0026quot;highlight.js/scss/github-dark-dimmed\u0026quot;; // 自带 @import \u0026quot;highlight.js/scss/dracula\u0026quot;; // 新下载 设置要高亮的编程语言 到node_modules/highlight.js/lib/languages/去查找支持的语言，以及其名称 C++和elisp // ./assets/js/highlight.js import cpp from 'highlight.js/lib/languages/cpp'; import lisp from 'highlight.js/lib/languages/lisp'; hljs.registerLanguage('cpp', cpp); // 无法使用+ hljs.registerLanguage('elisp', lisp); hljs.registerLanguage('lisp', lisp); 不支持elisp，可以设置lisp 5. 目录导航 # // ./config/_default/markup.toml [tableOfContents] endLevel = 3 ordered = false ## startLevel = 2 startLevel = 1 6. 代码框背景色 # 若代码框的语言可识别，使用hljs配置 light主题，代码框背景色为浅色，换成深色 // ./assets/scss/components/_syntax.scss .hljs { display: block; overflow-x: auto; padding: 1.25rem 1.5rem; // background: $beige; // color: $body-color; background: $body-overlay-dark; color: $body-color-dark; } 代码框语言无法识别 不建议修改；文本块也使用这个样式 // ./assets/scss/components/_code.scss code { background: $beige; color: $black; padding: 0.25rem 0.5rem; } 7. 设置表格样式 # 参照 Book 主题 // ./assets/scss/components/_tables.scss // table { // @extend .table; // // margin: 3rem 0; // } $padding-1: 1px !default; $padding-4: 0.25rem !default; $padding-8: 0.5rem !default; $padding-16: 1rem !default; table { @extend .table; margin: 3rem 0; overflow: auto; display: block; border-spacing: 0; border-collapse: collapse; margin-top: $padding-16; margin-bottom: $padding-16; tr th, tr td { padding: $padding-8 $padding-16; border: $padding-1 solid $gray-200; } tr:nth-child(2n) { background: $gray-100; } } 8. 渐变条 # // ./assets/scss/layout/_header.scss // 橘 浅蓝 深蓝 .header-bar { border-top: 4px solid; // border-image-source: linear-gradient(90deg, $primary, #8ed6fb 50%, #d32e9d); border-image-source: linear-gradient(90deg, #cc3c11, #8edefb 50%, #2e31d3); border-image-slice: 1; } 9. 主题色 # // ./assets/scss/common/_variables.scss // $primary: $purple; $primary: rgb(18, 63, 160); 实现目录高亮 # Doks主题支持笔记本分区收起展开，博文目录，全尺寸布局，横向路径导航，以及分开的Docs和Blogs。 而对于内容较多的博文，目录高亮可以让读者有一个全局的把握。 目录高亮参考 高亮样式 实现目录高亮我知道的有两个相关的点，一个是scrollspy，另一个则是intersection observer scrollspy node.js module，也是bootstrap的一个插件 Doks主题自带的试验性的目录高亮使用的scrollspy # 安装 npm i scrollspy on npm on getbootstrap intersection observer js逻辑，我找的这个 js逻辑 我不知道怎么导入js代码，所以放在了 ./assets/js/hightlight.js的最后 // 样式设置 let options = { root: document.querySelector('#article'), rootMargin: '0px 0px -75%', threshold: 1.0 } // MyToc：叫什么名字不重要；作用是执行操作 // .my-toc 的 . 说明是class；# 说明是element // .my-toc 即是nac class，保存TableOfContents文本 const MyToc = document.querySelector('.my-toc'), headingObserver = new IntersectionObserver(headings =\u0026gt; { headings.forEach(heading =\u0026gt; { // 对heading遍历 const id = heading.target.getAttribute('id'); //获取heading id if (heading.isIntersecting) { inactive(); // 取消之前添加的class subItem = document.querySelector(`.my-toc a[href=\u0026quot;#${id}\u0026quot;]`).classList.add('active'); // 为当前heading添加class } }); }, options); // 对指定级别heading进行遍历；未指定，该级别标题不会被高亮 document.querySelectorAll('h0[id],h1[id],h2[id],h3[id]').forEach((heading) =\u0026gt; { headingObserver.observe(heading); }); function inactive() { document.querySelectorAll('.my-toc a').forEach((a) =\u0026gt; { a.classList.remove('active'); }); } 为当前TableOfContents设置nav class 根据有无配置scrollSpy，对TableOfContents的设置不同 当scrollSpy为false时，最下方的{{ .TableOfContents }}对应右侧的目录 用 nav class将其围起来 \u0026lt;!-- ./layout/partials/sidebar/docs-toc.html --\u0026gt; \u0026lt;div class=\u0026quot;page-links d-none d-xl-block\u0026quot;\u0026gt; \u0026lt;h3\u0026gt;{{ i18n \u0026quot;on-this-page\u0026quot; }}\u0026lt;/h3\u0026gt; {{ if eq .Site.Params.options.scrollSpy true -}} {{ .TableOfContents | replaceRE \u0026quot;\u0026lt;nav id=\\\u0026quot;TableOfContents\\\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;nav id=\\\u0026quot;toc\\\u0026quot;\u0026gt;\u0026quot; | safeHTML }} {{ else -}} \u0026lt;nav class=\u0026quot;my-toc\u0026quot;\u0026gt; {{ .TableOfContents }} \u0026lt;/nav\u0026gt; {{ end -}} \u0026lt;/div\u0026gt; 设置class包含active的标题的样式 light // ./assets/scss/common/_global.scss .my-toc a.active { color: $primary; font-weight: 800; transition: all .25s ease-in-out } dark // ./assets/scss/common/_dark.scss [data-dark-mode] .my-toc a.active { color: $link-color-dark; } 遗留问题 # 博文目录跳转偏移 受到navbarSticky影响 说明 描述 [pc] org文件所有标题均偏移；md文件一级标题导航到标题之下，其他级别标题正常 [平板] md文件从三级标题显示正常 解决方法 org转md；使用ox-hugo完成转换，md从二级标题开始 doks无法正确显示 ox-hugo 生成的图片链接 "}),e.add({id:31,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/",title:"健康系统",description:"",content:""}),e.add({id:32,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/",title:"进阶课程",description:"",content:""}),e.add({id:33,href:"/docs/brick/",title:"🧱",description:"",content:""}),e.add({id:34,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E8%B7%9F%E9%9A%8F%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E6%BB%9A%E5%8A%A8/",title:"文章目录跟随文章内容滚动",description:"如果在目录项高亮时设置文章目录滚动跟随，文章目录跳转功能失效 文章目录跳转时，会高亮中间的每一个目录项。在高亮下一个目录项时，文章目录立即滚动跟随，此时会终止跳转。 滚动触发 找到了文章目录对应的元素 document.querySelector('.docs-toc') ，没有找到页面对应的元素 1. 两种滚动注册 # 监听 所有滚动都会触发。配合定时器，如果在定时器到时间之前没有跳转到目的目录项，文章目录滚动偏移重置 window.addEventListener('scroll', () =\u0026gt; { // 处理 }); 绑定事件处理函数 对window绑定处理函数，只在滚动页面时触发 ✔️ 参考./assets/js/to-top.js window.onscroll = function() { // 处理 }; 2. 处理函数调用时间点 # 如果文章目录滚动即触发，因为持续滚动，文章目录跳转功能完全失效。得在滚动结束后，再调用处理函数。 使用定时器。滚动即重启定时器，定时器到时间再调用处理函数。 let timer = null; window.onscroll = function () { clearTimeout(timer); timer = setTimeout(function () { // 处理 }, 300); // 设置定时器间隔；要求不小于最长跳转时间 }; 3. 设置文章目录滚动 # 每个目录项占用的高度 single ，和文章目录除去\u0026quot;On This Page\u0026quot;文本之后的高度有关 document.querySelector('.my-toc').scrollHeight 。 考虑到文章目录上方\u0026quot;On This Page\u0026quot;文本，窗口可供显示目录的高度应减去\u0026quot;On This Page\u0026quot;文本的高度。 根据窗口高度 window.",content:" 如果在目录项高亮时设置文章目录滚动跟随，文章目录跳转功能失效 文章目录跳转时，会高亮中间的每一个目录项。在高亮下一个目录项时，文章目录立即滚动跟随，此时会终止跳转。 滚动触发 找到了文章目录对应的元素 document.querySelector('.docs-toc') ，没有找到页面对应的元素 1. 两种滚动注册 # 监听 所有滚动都会触发。配合定时器，如果在定时器到时间之前没有跳转到目的目录项，文章目录滚动偏移重置 window.addEventListener('scroll', () =\u0026gt; { // 处理 }); 绑定事件处理函数 对window绑定处理函数，只在滚动页面时触发 ✔️ 参考./assets/js/to-top.js window.onscroll = function() { // 处理 }; 2. 处理函数调用时间点 # 如果文章目录滚动即触发，因为持续滚动，文章目录跳转功能完全失效。得在滚动结束后，再调用处理函数。 使用定时器。滚动即重启定时器，定时器到时间再调用处理函数。 let timer = null; window.onscroll = function () { clearTimeout(timer); timer = setTimeout(function () { // 处理 }, 300); // 设置定时器间隔；要求不小于最长跳转时间 }; 3. 设置文章目录滚动 # 每个目录项占用的高度 single ，和文章目录除去\u0026quot;On This Page\u0026quot;文本之后的高度有关 document.querySelector('.my-toc').scrollHeight 。 考虑到文章目录上方\u0026quot;On This Page\u0026quot;文本，窗口可供显示目录的高度应减去\u0026quot;On This Page\u0026quot;文本的高度。 根据窗口高度 window.innerHeight 和\u0026quot;On This Page\u0026quot;文本的高度差，计算页面能展示的最大目录项 max 。一开始，页面会显示\u0026quot;On This Page\u0026quot;文本，此时展示的目录项数目小于 max 。 若当前目录项超出窗口最大可展示目录项的一半，滚动文章目录，偏移量使得之后的当前目录项位于文章目录下半部分。 如果目录项高度根据.docs-toc计算得到，偏移量使得当前目录项位于文章目录中间。 完整代码 放在./assets/js/hightlight.js最后 let timer = null; window.onscroll = function () { clearTimeout(timer); timer = setTimeout(function () { locate_heading(); }, 300); }; function locate_heading() { let res = document.querySelectorAll('.my-toc a.active'); if (res.length != 1) { return; } let active_heading = res.item(0); let count = 0, current = 0; document.querySelectorAll('.my-toc a').forEach((a) =\u0026gt; { if (a == active_heading) { current = count; // console.log(\u0026quot;current heading\u0026quot;, a); } ++count; }); ++current; count /= 2; console.log(current, \u0026quot;/\u0026quot;, count); let fullToc = document.querySelector('.docs-toc'); //修改scrolltop let myToc = document.querySelector('.my-toc'); let single = myToc.scrollHeight / count; let offset = fullToc.scrollHeight - myToc.scrollHeight; // on-this-page height let max = parseInt((window.innerHeight - offset) / single); let mid = parseInt(max / 2); // console.log(\u0026quot;single: \u0026quot;, single, \u0026quot;max: \u0026quot;, max); if (current \u0026gt;= max - mid) { fullToc.scrollTop = single * (current - mid); } else { fullToc.scrollTop = 0; } } 不知道什么原因，.my-toc的元素个数是认为的2倍，而包含active类的a标签个数仍为1；使用.docs-toc更毛病 "}),e.add({id:35,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/",title:"开发语言",description:"",content:""}),e.add({id:36,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/",title:"武器",description:"",content:""}),e.add({id:37,href:"/docs/",title:"笔记",description:"",content:""}),e.add({id:38,href:"/docs/%E5%88%86%E4%BA%AB/",title:"分享",description:"",content:""}),e.add({id:39,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/",title:"开发工具",description:"",content:""}),e.add({id:40,href:"/docs/%E5%88%86%E4%BA%AB/macos/",title:"MacOS",description:"",content:""}),e.add({id:41,href:"/docs/%E5%88%86%E4%BA%AB/hugo/",title:"Hugo",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()