<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>主页 on ToughCactus</title>
    <link>https://toughcactus.github.io/</link>
    <description>Recent content in 主页 on ToughCactus</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://toughcactus.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AActor类型</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/Actor%E5%8F%8A%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB/AActor%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/Actor%E5%8F%8A%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB/AActor%E7%B1%BB%E5%9E%8B/</guid>
      <description>Part 1 派生关系 # UObjectBaseUtility &amp;lt; UObject &amp;lt; AActor 1. AActor类型 # 虚幻C++基础类型，能放置到世界场景中的物体，具有相同的基类AActor。 所有能添加到世界场景中的物体都可称作Actor，如几何体，特效，声音。Actor对象有无实体均可。 初始状态不具备变换属性(有Gizmo表示，移动后会复位)，无法绑定模型。变换需要USceneComponent组件，模型需要UStaticMeshComponent组件。 可以在虚幻编辑器中往关卡添加Actor对象，也可以在代码中动态生成Actor对象。 Actor对象由各种Component组成，所有组件可以根据需求进行组装，方便重用。 2. UObject类型 # 虚幻引擎中最基础的类型，AActor类型的父类。 不能在场景中添加UObject对象，可以在代码中创建UObject对象并对逻辑进行封装。 Part 2 组件 Component # 具有视觉表示的组件，需要为其设置上级组件，或将其注册为根组件 1. 创建组件 UObject::CreateDefaultSubobject&amp;lt;T&amp;gt; # 返回指向组件的指针 参数 含义 说明 SubobjectName 虚幻编辑器中显示的组件名 FName类型 BTransient 使用默认值 使用 StaticMesh = CreateDefaultSubobject&amp;lt;UStaticMeshComponent&amp;gt;(&amp;#34;StaticMeshInEditor&amp;#34;); 在C++中对变量StaticMesh做设置，在虚幻编辑器中对名为&amp;quot;StaticMeshInEditor&amp;quot;的组件做设置；二者相对应。 可以在C++中修改变量名；如果修改组件名，虚幻编辑器中该组件的已有设置会因找不到目标载体而无法生效。 2. 设置为根组件 AActor::SetRootComponent # 根组件的设置会影响到变换矩阵求值 参数 含义 说明 NewRootComponent 指向组件的指针 使用 SetRootComponent(StaticMesh); USceneComponent *类型，可以接受UStaticMeshCompoent *(动态绑定)。因为UStaticMeshComponent派生自UMeshComponent，UMeshComponent派生自UPrimitiveComponent，UPrimitiveComponent派生自USceneComponent。 3. 获取根组件 AActor::GetRootComponent # 返回指向根组件的指针 使用 GetRootComponent(); 4.</description>
    </item>
    
    <item>
      <title>bash</title>
      <link>https://toughcactus.github.io/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/bash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/bash/</guid>
      <description> 花括号的使用 # 资料 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，可以将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这么玩，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 </description>
    </item>
    
    <item>
      <title>DrawDebugHelpers库</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/%E5%B8%B8%E7%94%A8%E5%BA%93/DrawDebugHelpers%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/%E5%B8%B8%E7%94%A8%E5%BA%93/DrawDebugHelpers%E5%BA%93/</guid>
      <description> Overview # 绘制图形基元(Graphic Primitives)库 头文件 UE5/Engine/Source/Runtime/Engine/Public/DrawDebugHelpers.h 源文件 UE5/Engine/Source/Runtime/Engine/Private/DrawDebugHelpers.cpp 一、头文件 # #include &amp;#34;DrawDebugHelpers.h&amp;#34; 二、绘制球体 DrawDebugSphere # 指向UWorld对象的指针 InWorld 球体中心坐标 Center 球体半径 Radius 细分参数(tessellation parameter) Segments 随着Segments的增大，球体棱角越少，绘制开销愈大 颜色 Color FColor类型 使用 DrawDebugSphere(GetWorld(), GetActorLocation(), Radius, 24, FColor::Red); </description>
    </item>
    
    <item>
      <title>org-mode</title>
      <link>https://toughcactus.github.io/docs/%E5%88%86%E4%BA%AB/Emacs/org-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E5%88%86%E4%BA%AB/Emacs/org-mode/</guid>
      <description> Overview # The Org Manual 一、样式 # 删除线 +Content+ 下划线 ox-hugo转markdown存在问题 _Content_ 文本块 =test= ~test~ 斜体 /test/ 加粗 *test* 二、选项设置 # 关闭toc Table of Contents #+OPTIONS: toc:nil 指定toc显示层级 #+TOC: headlines 2 上标和下标 a_b a^b 关闭 #+OPTIONS: ^:nil 需要使用{}转义 #+OPTIONS ^:{} a_{b} a^{b} 自动为标题添加标号 关闭 #+OPTIONS num:nil 选项合并 #+OPTIONS: toc:nil ^:{} #+STARTUP: showall hidestars 显示所有内容 #+STARTUP: showall 只显示一级标题 #+STARTUP: overview 隐藏星号 #+STARTUP: hidestars 三、模板 # Structure Templates C-c C-, org-insert-structure-template 代码框 填写编程语言 // C++样式 #+begin_src LANGUAGE #+end_src 文本框 文本框样式 #+begin_example #+end_example quote quote样式 #+begin_quote #+end_quote </description>
    </item>
    
    <item>
      <title>UEngine类型</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/%E5%85%A8%E5%B1%80%E7%B1%BB%E5%9E%8B/UEngine%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/%E5%85%A8%E5%B1%80%E7%B1%BB%E5%9E%8B/UEngine%E7%B1%BB%E5%9E%8B/</guid>
      <description> 一、头文件 # #include &amp;#34;Engine/Engine.h&amp;#34; 二、指向UEngine对象的指针 GEngine # 全局变量 使用前需检查 三、在屏幕输出信息 UEngine::AddOnScreenDebugMessage # 参数 名称 说明 消息标识 Key Key相同的消息只显示第一个；使用-1则一定会显示 文本显示时长 TimeToDisplay 文本颜色 DisplayColor 可以使用FColor预定义颜色，也可以使用自定义的FColor对象 文本内容 DebugMessage 在世界场景中的位置 bNewerOnTop 默认在顶部输出信息，为false则在屏幕底部输出 设置文字大小 TextScale 使用 if (GEngine) { GEngine-&amp;gt;AddOnScreenDebugMessage(-1, 3.0f, FColor::Orange, TEXT(&amp;#34;Hello&amp;#34;)); GEngine-&amp;gt;AddOnScreenDebugMessage(-1, 5.0f, FColor::Green, TEXT(&amp;#34;World!&amp;#34;)); } </description>
    </item>
    
    <item>
      <title>实时显示游戏角色生命值</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.1%E5%9C%A8Character%E4%B8%8A%E6%96%B9%E6%98%BE%E7%A4%BA%E7%94%9F%E5%91%BD%E5%80%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.1%E5%9C%A8Character%E4%B8%8A%E6%96%B9%E6%98%BE%E7%A4%BA%E7%94%9F%E5%91%BD%E5%80%BC/</guid>
      <description>Overview # 自定义健康组件 ActorComponent 纯逻辑 显示生命值 TextRenderComponent Part 1 创建健康组件 # 虚幻编辑器 ActorComponent 一、创建 Component/STHealthComponent # ActorComponent 公有类 Part 2 调整健康组件框架并给出初步实现 # C++ 一、调整框架 # 默认构造函数 将每帧调用TickComponent函数标志置为false PrimaryComponentTick.bCanEverTick = false; BeginPlay 屏蔽派生类 TickComponent 函数，使用基类实现 二、新增逻辑：实时生命值和最大生命值 # 数据成员 实时生命值 private float float Health = 0.0f; 最大生命值 protected 可设置类成员初始值 分组Health ( 0, 1000 ) UPROPERTY(EditDefaultsOnly, Category = &amp;#34;Health&amp;#34;, meta = (ClampMin = &amp;#34;0.0&amp;#34;, ClampMax = &amp;#34;1000.0&amp;#34;)) float MaxHealth = 100.0f;	三、新增逻辑：获取生命值和初始化生命值 # 函数成员 获取生命值 public 蓝图可调用 const函数 隐式inline UFUNCTION(BlueprintCallable) float GetHealth() const { return Health; } 初始化生命值 private 在BeginPlay中调用 void USTHealthComponent::InitHealth() { Health = MaxHealth; } Part 3 为 Character 添加健康组件 # C++ STBaseCharacter 包含健康组件头文件 头文件 前向声明 class USTHealthComponent; 源文件 #include &amp;#34;Components/STHealthComponent.</description>
    </item>
    
    <item>
      <title>终端</title>
      <link>https://toughcactus.github.io/docs/%E5%88%86%E4%BA%AB/MacOS/%E7%BB%88%E7%AB%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E5%88%86%E4%BA%AB/MacOS/%E7%BB%88%E7%AB%AF/</guid>
      <description>Part 1 iTerm2 # 官网下载 参考 一、窗口管理 # 快捷键 操作 Command-w 关闭窗口 分屏 快捷键 操作 Command-d 左右分屏 Command-Shift-d 上下分屏 Command-[ 标签页内切换窗口 Command-] Option-Command-UP 根据方向键切换窗口 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 快捷键 操作 Command-t 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right 二、status bar # Preferences &amp;gt; Profiles &amp;gt; Session 勾选Status bar enabled，点击Configure Status Bar Preferences &amp;gt; Appearence &amp;gt; General &amp;gt; Status bar location Bottom 三、配色 # 官方提供的配色 常用配色 Dracula lovelace , lovelace文本 导入配色 Preferences Profiles Color &amp;gt; Color Presets &amp;gt; Import 四、窗口大小 # Preferences &amp;gt; Profiles &amp;gt; Window 设置 Columns 和 Rows 五、透明度 # Preferences &amp;gt; Profiles &amp;gt; Window &amp;gt; Transparency 3 六、字体 # Preferences &amp;gt; Profiles &amp;gt; Text &amp;gt; Font Victor Mono 14 consolas下载指南 victor mono Part 2 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 一、安装 # /bin/bash -c &amp;#34;$(curl -fsSL https://mirrors.</description>
    </item>
    
    <item>
      <title>运行ShooterGame示例项目</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.1%E5%9C%A8%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8CShooterGame%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.1%E5%9C%A8%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8CShooterGame%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE/</guid>
      <description> 下载ShooterGame # Epic Games Launcher &amp;gt; Samples &amp;gt; Shooter Game 支持引擎版本 4.0 - 4.27 ，当前使用引擎版本 5.1.1 需要修改的地方 # UMatineeCameraShake 已被 ULegacyCameraShake 替代 PLATFORM_PS4 一个不合适的改法是在引擎代码中，紧接着 SWITCH 定义该宏 另一个麻烦但更合理的改法是，屏蔽该宏的出现 条件运算符的第二个和第三个操作数如果类型不一致，存在转换 参考 Source/ShooterGame/Private/Player/ShhoterCharacter.cpp:322 AController * 和 AActor * 可以相互转换，此处有歧义 运行效果 # </description>
    </item>
    
    <item>
      <title>APawn类型</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/Actor%E5%8F%8A%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB/APawn%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/Actor%E5%8F%8A%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB/APawn%E7%B1%BB%E5%9E%8B/</guid>
      <description>APawn # 玩家所操作的角色，提供键位绑定。 由PlayerController控制，可在多个Pawn之间进行切换 Part 1 配置用户输入 APawn::SetupPlayerInputComponent # 在该函数内绑定键位 Part 2 获取类型 APawn::StaticClass # 静态成员 返回指向UClass的指针 在GENERATED_BODY宏中定义 UObject也有StaticClass，UObjectBaseUtility没有 Part 3 Controller切换Pawn # 1. Controller控制当前Pawn时调用 APawn::PossessedBy # 2. Controller释放当前Pawn时调用 APawn::UnPossessed # 3. 是否被PlayerController接管 APawn::IsControlled # 4. 是否被Controller接管 APawn::IsPawnControlled # AIController或PlayerController Part 4 以Pawn为原点建立相对坐标系，修改平移的方向向量 APawn::AddMovementInput # 控制Pawn前后左右移动，前进或后退传入ForwardVector和步长，左右移动传入RightVector和步长 控制Character前后左右移动亦通过该接口 参数 含义 WorldDirection 移动角色的方向 ScaleValue 方向正负 bForce 使用默认值 AddMovementInput(GetActorForwardVector(), Amount); // AddMovementInput(GetActorRightVector(), Amount); 定义 对UPawnMovementComponent::AddInputVector进行封装，修改方向向量 Part 5 绕指定轴旋转PlayerController # 旋转的控制权不在Pawn，在PlayerController。对PlayerController的旋转进行了封装。 X轴向前，Z轴向上，Y轴向右。 Roll 绕X轴旋转，顺时针为正方向 YOZ平面 Pitch 绕Y轴旋转，向上为正方向 XOZ平面 Yaw 绕Z轴旋转，向右为正方向 XOY平面 绕Y轴和Z轴旋转时，若无其他处理，可以直接将AddControllerPitchInput和AddControllerYawInput注册为旋转回调函数 1.</description>
    </item>
    
    <item>
      <title>FMath库</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/%E5%B8%B8%E7%94%A8%E5%BA%93/FMath%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/%E5%B8%B8%E7%94%A8%E5%BA%93/FMath%E5%BA%93/</guid>
      <description>Overview # 定义了多种数学函数，包括sine, cosine, 和其他三角函数(Trigonometric Functions) API 通过命名空间FMath使用 头文件 UE5/Engine/Source/Runtime/Core/Public/Math/UnrealMathUtility.h 头文件 UE5/Engine/Source/Runtime/Core/Public/GenericPlatform/GenericPlatformMath.h 一、三角函数 # 1. 计算正弦值 FGenericPlatformMath::Sin # 静态成员 2. 弧度转角度 FMath::RadiansToDegrees # 3. 计算反余弦 FGenericPlatformMath::Acos # 二、获得随机布尔值 FMath::RandBool # 静态成员 三、取符号 FGenericPlatformMath::Sign # 四、获取二者中较小值 FGenericPlatformMath::Min # 五、范围 # 1. 获得满足范围的数值 FMath::Clamp # 模版函数 自动推测类型 要求三个参数类型一致 若 Min &amp;lt;= X &amp;lt;= Max，返回X； 若 X &amp;lt; Min，返回Min； 若 Max &amp;lt; X，返回Max 2. 区域线性映射 FMath::GetMappedRangeValueClamped&amp;lt;T&amp;gt; # 若给定值Value小于InputRange.X，返回OutputRange.X； 若给定值Value大于InputRange.Y，返回OutputRange.Y； 若给定值Value在范围内[InputRange.X, InputRange.Y]，返回线性映射值： 斜率 K = (OutputRange.</description>
    </item>
    
    <item>
      <title>UWorld类型</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/%E5%85%A8%E5%B1%80%E7%B1%BB%E5%9E%8B/UWorld%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/%E5%85%A8%E5%B1%80%E7%B1%BB%E5%9E%8B/UWorld%E7%B1%BB%E5%9E%8B/</guid>
      <description>Overview # 关卡编辑器中，视口所展示的即世界场景，简称场景。 Engine/Source/Runtime/Engine/Classes/Engine/World.h 可以使用AActor::GetWorld获取UWorld对象，使用前需判断指针对象是否成功获取 一、头文件 # #include &amp;#34;Engine/World.h&amp;#34; 二、获取程序运行时长 UWorld::GetTimeSeconds # 使用 if (GetWorld()) { float Time = GetWorld()-&amp;gt;GetTimeSeconds(); } 三、动态生成Actor对象 # 分两步 调用基类或派生类的构造函数 调用对象的函数成员BeginPlay 1. 生成Actor对象 UWorld::SpawnActor # 返回AActor指针，如需使用派生类对象，需转换 对象类型 InClass 初始位置 Location 使用默认值，原点 初始旋转 Rotation 使用默认值，不发生旋转 TSubclassOf&amp;lt;ASimpleGeometry&amp;gt; GeometryClass; GetWorld()-&amp;gt;SpawnActor(GeometryClass); 2. 生成Actor对象 UWorld::SpawnActor&amp;lt;T&amp;gt; # 返回指向生成对象的指针 对象类型 Class 变换信息 Transform 其他参数 SpawnParameters 使用默认值 TSubclassOf&amp;lt;ASimpleGeometry&amp;gt; GeometryClass; const FTransform FTransform = FTransform(FRotator::ZeroRotator, FVector(0.0f, 300.0f, 300.0f)); ASimpleGeometry *Geometry = GetWorld()-&amp;gt;SpawnActor&amp;lt;ASimpleGeometry&amp;gt;(GeometryClass, FTransform); 3.</description>
    </item>
    
    <item>
      <title>VSCode</title>
      <link>https://toughcactus.github.io/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VSCode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VSCode/</guid>
      <description> 一、快捷键 # 操作 快捷键 减小字体 Command&amp;ndash; 放大字体 Command-+ 二、使用clang-format # 参考 安装扩展C/C++，自动安装clang-format 首选项 &amp;gt; Text Editor &amp;gt; Formatting，勾选 Format On Save 保存文件时，应用格式 插件 # C++ C/C++ C/C++ Extension Pack C/C++ Themes C# 项目编译 CMake CMakeTools 代码调试 CodeLLDB 主题 Dracula Official 其他 file-picker Mono Debug Emacs 自定义快捷键无法使用 </description>
    </item>
    
    <item>
      <title>初始化ShootTraining项目</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.2%E5%88%9D%E5%A7%8B%E5%8C%96ShootTraining%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.2%E5%88%9D%E5%A7%8B%E5%8C%96ShootTraining%E9%A1%B9%E7%9B%AE/</guid>
      <description>虚幻编辑器 Overview # 将 ShooterGame 作为内容包，基于此开发 ShootTraining 。如有室内设计师提供游戏资料，我们基于此开发游戏。 一、创建 ShootTraining 项目 # Blank Blueprint 二、配置 ShootTraining # 添加 Copyright 项目设置 &amp;gt; Project &amp;gt; Description &amp;gt; Legal &amp;gt; Copyright Notice Shoot Training Game, All Rights Reserved. 关卡设置 添加关卡文件夹 Content/Levels 创建关卡 Content/Levels/DefaultMap Basic 设置 EditorStartupMap 和 GameDefaultMap 使用 DefaultMap 项目设置 &amp;gt; Project &amp;gt; Maps &amp;amp; Modes 不使用预编译头文件 ShootTraining.Build.cs // PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PCHUsage = PCHUsageMode.NoPCHs; 添加外部资产文件夹 Content/ExternalContent 三、从 ShooterGame 导入资产 # 打开ShooterGame项目 &amp;gt; 在内容浏览器选中Content/Animations/TTP_Animations，右键 &amp;gt; Migrate 取消Sounds勾选 默认勾选的文件夹里的内容都与 TTP_Animations 相关 保存到 Content 目录下 不能直接迁移到 ExternalContent ，虚幻引擎会检查目录，要求这些资产的上级目录是 Content ，即使根目录是 Content 也无法通过检查 通过虚幻编辑器，将 Content 目录下的 Animations Characters Environment 移动到 ExternalContent 目录下 不能直接将三个文件夹移动到 ExternalContent 中，会导致资产之间的相互引用路径出错 打开 ShootTraining 项目，为 ExternalContent 设置文件夹颜色 选中Content/ExternalContent，右键 &amp;gt; Set Color 效果图 外部资产结构 四、基于蓝图创建C++项目 # 添加C++类即可。创建蓝图项目的时间开销明显小于创建C++项目的时间开销。 创建 GameModeBase STGameModeBase 不设置类类型 Content同级目录出现C++ Classes文件夹 设置关卡使用 STGameModeBase 五、脚本 # 编译项目 build.</description>
    </item>
    
    <item>
      <title>计算伤害</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.2%E8%AE%A1%E7%AE%97%E4%BC%A4%E5%AE%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.2%E8%AE%A1%E7%AE%97%E4%BC%A4%E5%AE%B3/</guid>
      <description> Overview # 虚幻引擎提供一组函数，用来对Actor造成伤害 在Tick函数中，持续对游戏角色造成伤害；每次造成伤害，调用处理函数，更新角色生命值 一、每帧对 Character 造成伤害 # STBaseCharacter 函数成员 private 在Tick中调用 伤害来源是自己 void ASTBaseCharacter::CharacterTakeDamage() { TakeDamage(0.1f, FDamageEvent{}, GetController(), this); } 二、定义空的伤害委托处理函数，并注册到 Character # USTHealthComponent 包含头文件 源文件 #include &amp;#34;GameFramework/Actor.h&amp;#34; 定义日志类型 源文件 DEFINE_LOG_CATEGORY_STATIC(LogHealthComponent, All, All) 搭建处理函数框架 函数成员 private 委托类型FTakeAnyDamageSignature：从委托类型的定义获取处理函数签名；委托属性多播，支持蓝图，需要UFUNCTION宏 UFUNCTION() void OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 注册处理函数 函数成员 private 在BeginPlay中调用 void USTHealthComponent::RegisterDamageHandler() { AActor *ThisActor = GetOwner(); if (ThisActor) { ThisActor-&amp;gt;OnTakeAnyDamage.AddDynamic(this, &amp;amp;USTHealthComponent::OnTakeAnyDamage); } } 实现伤害委托处理函数 Health减为0，作为负数仍在减；差不多一秒10帧，即1s调用十次处理函数 触发处理函数时，不会传入整个FDamageEvent变量，而是传入UDamageType void USTHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) { Health -= Damage; } </description>
    </item>
    
    <item>
      <title>ACharacter类型</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/Actor%E5%8F%8A%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB/ACharacter%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/Actor%E5%8F%8A%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB/ACharacter%E7%B1%BB%E5%9E%8B/</guid>
      <description>Overview # 派生自APawn，实现了角色的动作(motion)，动画(animation)和物理交互(physical interaction) Part 1 跳跃回调函数 ACharacter::Jump # 若无其他处理，可以直接将Jump注册为跳跃回调函数 定义 将bPressedJump置为true，在下次调用Tick函数时，让Actor在Z轴跳跃 Part 2 构造函数 ACharacter::ACharacter # 设置使用组件的类型(派生类or基类) Part 3 子组件类型名 # 保存在FName中 静态成员 1. CharacterMovementComponent类型名 ACharacter::CharacterMovementComponentName # 角色运动组件 2. MeshComponent类型名 ACharacter::MeshComponentName # 网格体组件 3. CapsuleComponent类型名 ACharacter::CapsuleComponentName # 碰撞胶囊组件 Part 4 获取指向CharacterMovement组件的指针 ACharacter::GetCharacterMovement # CharacterMovementComponent或其派生类，根据ACharacter构造函数中设置的组件类型来 Part 5 播放动画剪辑 ACharacter::PlayAnimMontage # 定义 不需要在调用前检查动画剪辑指针的有效性，函数负责检查 参数 含义 AnimMontage 指向动画剪辑的指针 Part 6 落地事件 # 使用委托机制实现 处理流程 方法一 为落地事件数据成员注册处理函数，发生落地事件时，处理函数被调用 方法二 覆写虚函数Landed 1. Character提供的落地委托类型 FLandedSignature # 多播 支持蓝图 处理函数格式 void OnGroundLanded(const FHitResult&amp;amp; Hit); OnLanded函数名已被使用 2.</description>
    </item>
    
    <item>
      <title>UGameplayStatics类型</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/%E5%B8%B8%E7%94%A8%E5%BA%93/UGameplayStatics%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/%E5%B8%B8%E7%94%A8%E5%BA%93/UGameplayStatics%E7%B1%BB%E5%9E%8B/</guid>
      <description> Overview # 虚幻引擎提供的辅助类；提供多种静态函数，均可在蓝图中使用 源文件 UE5/Engine/Source/Runtime/Engine/Private/GameplayStatics.cpp 头文件 UE5/Engine/Source/Runtime/Engine/Classes/Kismet/GameplayStatics.h 一、头文件 # #include &amp;#34;Kismet/GameplayStatics.h&amp;#34; 二、获得场景中的指定类型的所有Actor对象 UGameplayStatics::GetAllActorsOfClass # 和类模板TSubclassOf搭配使用 保存到传入的数组引用参数中 指向游戏中任意Object WorldContextObject 可以使用GetWorld传入世界对象，或者使用指向PlayerController的指针(this) UGameplayStatics::GetAllActorsOfClass(GetWorld(), AGeometryPawn::StaticClass(), Pawns); 三、计算伤害 # 半径伤害 UGameplayStatics::ApplyRadialDamageWithFalloff # 静态成员 调用OverlapMultiByObjectType搜索和球体重叠的Actor，对这些Actor调用TakeDamage 三、计算伤害 包裹函数 # 半径伤害 UGameplayStatics::ApplyRadialDamage # 静态成员 包裹函数，封装UGameplayStatics::ApplyRadialDamageWithFalloff 参数 名称 说明 可以传入指向UWorld对象的指针 WorldContextObject 伤害的数量特征(quantitative characteristic) BaseDamage 半径伤害的中心位置 Origin 伤害半径 DamageRadius 伤害类型 DamageTypeClass UDamageType及其派生类，类型变量；处理函数根据伤害类型做出相应处理 不受伤害的Actor数组 IgnoreActors 伤害来源 DamageCauser 可以是武器 伤害来源的上级Controller InstigatedByController 当伤害来源是Pawn或Character时，传入上级Controller，用以判断阵营 计算半径伤害用标志 bDoFullDamage 为true时，处于伤害半径球体内的Actor，受到相同伤害值，计算半径伤害模型简单；为false时，离球体中心越近，伤害值越大，需要一定开销 减免伤害用枚举变量 DamagePreventionChannel 碰撞系数；当Character和伤害中心有隔挡时，如何计算伤害；在某些情形，允许Character不受伤害 使用 UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); 点伤害 UGameplayStatics::ApplyPointDamage # 存在碰撞，需要知道指向目标Actor的指针 其他类型 UGameplayStatics::ApplyDamage # 需要知道指向目标Actor的指针 </description>
    </item>
    
    <item>
      <title>代码规范</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.3%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.3%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
      <description>Overview # .clang-format .gitignore 参考 按个人习惯来，非建议 大括号 放在新行 缩进 使用制表符，缩进宽度和制表符宽度一致 虚幻引擎建议使用制表符，也可以使用空格 缩进、制表符和空格 # 缩进 indent 编写代码时，按下tab键，即按格式留出空位，用以控制格式 默认使用制表符 tab 因为制表符的宽度可设置，不同平台制表符的宽度不一，视觉上，查看代码会有不习惯的感觉；可在本地设置使用空格，即用空格替换制表符 制表符宽度和缩进宽度 若缩进使用空格，制表符宽度参数无效，缩进对应的空格个数和缩进宽度一致 TabWidth参数无效；一次缩进对应7个空格 IndentWidth: &amp;#39;7&amp;#39; TabWidth: &amp;#39;9&amp;#39; UseTab: &amp;#39;Never&amp;#39; 若缩进使用制表符，当缩进对应的空格个数不小于制表符宽度，使用制表符替换对应个数个空格 一次缩进对应7个空格，不会被替换为制表符；两个缩进对应14个空格，会被替换为1个制表符加5个空格 IndentWidth: &amp;#39;7&amp;#39; TabWidth: &amp;#39;9&amp;#39; UseTab: &amp;#39;Always&amp;#39; 一、定义格式化代码规则 # .clang-format 参考 YAML标记文件 作为项目的一部分，描述管理代码文件的统一格式 每行遵循格式 key: value 1. 设置受约束的开发语言 # Language: Cpp 如果项目中只一种开发语言，或者所有开发语言使用相同规范，可忽略该配置 2. 通用样式 # Google 一个制表符对应2个空格，大括号不在新行 BasedOnStyle: Google Microsoft 一个制表符对应4个空格，大括号在新行 BasedOnStyle: Microsoft 3. 缩进宽度 # IndentWidth: &amp;#39;4&amp;#39; 4. 缩进样式 # 空格 UseTab: Never 制表符 源文件中既有空格又有制表符 UseTab: Always 5.</description>
    </item>
    
    <item>
      <title>模拟榴弹爆炸</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.3%E6%A8%A1%E6%8B%9F%E6%A6%B4%E5%BC%B9%E7%88%86%E7%82%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.3%E6%A8%A1%E6%8B%9F%E6%A6%B4%E5%BC%B9%E7%88%86%E7%82%B8/</guid>
      <description>Part 1 建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 Part 2 创建伤害来源 Dev/STDevDamageActor # 虚幻编辑器 STDevDamageActor，模拟榴弹爆炸 Actor 公有类 Part 3 准备工作 # C++ 屏蔽 ASTBaseCharacter::Tick中调用CharacterTakeDamage 添加头文件路径 ShootTraining/Source/ShootTraining/ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { &amp;#34;ShootTraining/Public/Player&amp;#34;, &amp;#34;ShootTraining/Public/Components&amp;#34;, &amp;#34;ShootTraining/Public/Dev&amp;#34; }); Part 4 实现 STDevDamageActor # C++ STDevDamageActor 一、添加可视化组件，使得伤害源可变换 # 添加 SceneComponent 数据成员 protected 蓝图可设置 UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent;	初始化 SceneComponent 函数成员 private 在构造函数中调用 void ASTDevDamageActor::InitSceneComponent() { SceneComponent = CreateDefaultSubobject&amp;lt;USceneComponent&amp;gt;(&amp;#34;SceneComponent&amp;#34;); SetRootComponent(SceneComponent); } 二、绘制球体，爆炸范围可视化 # 包含头文件 源文件 #include &amp;#34;DrawDebugHelpers.h&amp;#34; 球体半径和颜色 数据成员 protected 蓝图可设置 UPROPERTY(EditAnywhere) float Radius = 300.</description>
    </item>
    
    <item>
      <title>APlayerController类型</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/Actor%E5%8F%8A%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB/APlayerController%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/Actor%E5%8F%8A%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB/APlayerController%E7%B1%BB%E5%9E%8B/</guid>
      <description> Part 1 切换Pawn AController::Possess # Part 2 处理输入 APlayerController::SetupInputComponent # Part 3 获取类型 APlayerController::StaticClass # 静态成员 返回指向UClass的指针 在GENERATED_BODY中定义 Part 4 增减PlayerController旋转角度 # 1. 绕Y轴旋转 # 2. 绕Z轴旋转 # 3. 绕X轴旋转 # Part 5 设置Controller状态 AController::ChangeState # 修改StateName值并做相应修改 Part 6 使新Controller状态生效 APlayerController::ChangeState # 对先前状态进行收尾，为新状态做相应设置 参数 含义 NAME_Spectating 观察Pawn NAME_Playing 常规Pawn 二者都是常量 Part 7 使观察者状态生效 APlayerController::BeginSpectatingState # Controller释放当前Pawn 销毁当前SpectatorPawn 生成新SpectatorPawn并由Controller控制 定义 </description>
    </item>
    
    <item>
      <title>为游戏角色绑定模型</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.4%E4%B8%BACharacter%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.4%E4%B8%BACharacter%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%9E%8B/</guid>
      <description>Overview # 玩家控制的游戏角色 Character 游戏角色上级 PlayerController 关卡设置 GameModeBase DefaultPawnClass PlayerControllerClass 第三视角 Camera组件 Part 1 创建 Character 和 PlayController # 虚幻编辑器 一、创建 Player/STBaseCharacter # ACharacter 公有类 二、创建 Player/STPlayerController # APlayerController 公有类 Part 2 使用 Character 和 PlayController # C++ 一、查看头文件包含路径 # 源文件路径中有指明上级文件夹 Player 设置头文件搜索路径，之后可以不指明上级文件夹 ShootTraining.Build.cs PublicIncludePaths.AddRange(new string[] { &amp;#34;ShootTraining/Public/Player&amp;#34; }); 二、使用 STBaseCharacter 和 STPlayerController # STGameModeBase 包含头文件 源文件 #include &amp;#34;STBaseCharacter.h&amp;#34; #include &amp;#34;STPlayerController.h&amp;#34; 设置使用类 函数成员 private 在默认构造函数中调用 void ASTGameModeBase::InitCharacterAndPlayerController() { DefaultPawnClass = ASTBaseCharacter::StaticClass(); PlayerControllerClass = ASTPlayerController::StaticClass(); } 实现默认构造函数 public ASTGameModeBase::ASTGameModeBase() { InitCharacterAndPlayerController(); } 三、添加 Camera 组件 # STBaseCharacter 前向声明 头文件 class UCameraComponent; 包含头文件 源文件 #include &amp;#34;Camera/CameraComponent.</description>
    </item>
    
    <item>
      <title>使用伤害类型</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.4%E4%BD%BF%E7%94%A8%E4%BC%A4%E5%AE%B3%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.4%E4%BD%BF%E7%94%A8%E4%BC%A4%E5%AE%B3%E7%B1%BB%E5%9E%8B/</guid>
      <description>Part 1 创建伤害类型 # C++ 1. 创建 Dev/STFireDamageType # UDamageType 公有类 2. 创建 Dev/STIceDamageType # UDamageType 公有类 Part 2 为伤害来源添加伤害类型属性 # C++ Dev/STDevDamageActor 添加 DamamgeType 属性 protected 蓝图可设置 UPROPERTY(EditAnywhere) TSubclassOf&amp;lt;UDamageType&amp;gt; DamageType; 造成伤害时，传入 DamageType 函数成员 private 在Tick中调用 取消在Tick中调用DevTakeDamage void ASTDevDamageActor::DevTakeDamageWithDamageType() { UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); } Part 3 在 HealthComponent 输出伤害来源信息 # C++ STHealthComponent 在处理函数中，根据 DamageType 的具体类型，做出相应处理 包含头文件 #include &amp;#34;Dev/STFireDamageType.h&amp;#34; #include &amp;#34;Dev/STIceDamageType.h&amp;#34; 输出伤害来源信息 函数成员 private 在OnTakeAnyDamage中调用 void USTHealthComponent::HandleDamage(const UDamageType *DamageType) { if (DamageType) { if (DamageType-&amp;gt;IsA&amp;lt;USTFireDamageType&amp;gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(&amp;#34;So Hooooooot !</description>
    </item>
    
    <item>
      <title>AGameModeBase类型</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/Actor%E5%8F%8A%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB/AGameModeBase%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/API/%E8%99%9A%E5%B9%BBC&#43;&#43;/Actor%E5%8F%8A%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB/AGameModeBase%E7%B1%BB%E5%9E%8B/</guid>
      <description> 一、DefaultPawn设置 AGameModeBase::DefaultPawnClass # 数据成员 使用TSubOfClass定义的模板类 二、默认构造函数 AGameModeBase::AGameModeBase # 对关卡基础类型的设置可以参照这里 三、PlayerController设置 AGameModeBase::PlayerControllerClass # </description>
    </item>
    
    <item>
      <title>为游戏角色添加死亡逻辑</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.5%E6%B7%BB%E5%8A%A0Character%E6%AD%BB%E4%BA%A1%E9%80%BB%E8%BE%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.5%E6%B7%BB%E5%8A%A0Character%E6%AD%BB%E4%BA%A1%E9%80%BB%E8%BE%91/</guid>
      <description>Part 1 使用委托：当生命值发生改变时，更新 TextRender 文本 # C++ 一、屏蔽当前 HealthText 的设置 # 之前，每帧都会根据生命值设置 TextRender 组件 ASTBaseCharacter::Tick中，屏蔽DisplayHealthText 在ASTBaseCharacter::BeginPlay中，调用DisplayHealthText初始化设置 先调用Component的BeginPlay，而后调用Character的BeginPlay 当前委托机制中，Character在BeginPlay中注册服务。如果由HealthComponent的BeginPlay中初始化生命值并广播，此时Character还未注册服务，广播在前，注册在后，则Character无法收到通知并初始化 TextRender 组件文本 二、使用委托修改HealthText，服务端修改 # Components/STHealthComponent OnTakeAnyDamage中，屏蔽HandleDamage 伤害类型仅做示例 定义委托类型 头文件 多播 仅C++ DECLARE_MULTICAST_DELEGATE(FOnHealthChanged) 添加委托类型成员 数据成员 public FOnHealthChanged OnHealthChanged; 生命值改变时，通知客户端 OnTakeAnyDamage OnHealthChanged.Broadcast(); 三、使用委托修改HealthText，客户端修改 # STBaseCharacter 处理函数 函数成员 private void ASTBaseCharacter::OnHealthChanged() { DisplayHealthText(); } 注册处理函数 函数成员 private 在BeginPlay中调用 void ASTBaseCharacter::BindOnHealthChanged() { Health-&amp;gt;OnHealthChanged.AddUObject(this, &amp;amp;ASTBaseCharacter::OnHealthChanged); } Part 2 若Character死亡，不再造成伤害 # C++ 一、判断Character死亡 # 函数成员 public 蓝图可调用，const函数 UFUNCTION(BlueprintCallable) bool IsDead() const { return Health &amp;lt;= 0.</description>
    </item>
    
    <item>
      <title>实现游戏角色前后左右移动</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.5%E5%AE%9E%E7%8E%B0Character%E5%89%8D%E5%90%8E%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.5%E5%AE%9E%E7%8E%B0Character%E5%89%8D%E5%90%8E%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8/</guid>
      <description> Part 1 绑定键位 # 虚幻编辑器 项目设置 &amp;gt; Engine &amp;gt; Input 1. 轴映射 # 连续 如 前后左右移动 2. 动作映射 # 离散 如 跳跃，装弹，更换武器 Part 2 实现前后左右移动逻辑 # C++ STBaseCharacter 添加头文件 源文件 #include &amp;#34;Components/InputComponent.h&amp;#34; 实现回调函数 函数成员 private void ASTBaseCharacter::MoveForward(float Amount) { AddMovementInput(GetActorForwardVector(), Amount); } void ASTBaseCharacter::MoveRight(float Amount) { AddMovementInput(GetActorRightVector(), Amount); } 绑定函数描述和回调函数 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::BindMoveHandler(UInputComponent* PlayerInputComponent) { PlayerInputComponent-&amp;gt;BindAxis(&amp;#34;MoveForward&amp;#34;, this, &amp;amp;ASTBaseCharacter::MoveForward); PlayerInputComponent-&amp;gt;BindAxis(&amp;#34;MoveRight&amp;#34;, this, &amp;amp;ASTBaseCharacter::MoveRight); } </description>
    </item>
    
    <item>
      <title>插件篇 | 文件管理</title>
      <link>https://toughcactus.github.io/docs/%E5%88%86%E4%BA%AB/Emacs/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E5%88%86%E4%BA%AB/Emacs/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
      <description>Overview # speedbar Emacs内置功能，可以浏览文件内符号 neotree 文件管理 treemacs 工作区管理，和tags文件协作时，亦支持浏览文件内符号 一、 speedbar # (semantic-mode) ;; 使能mode，进行语义分析 (speedbar) ;; 打开文件目录 二、 neotree # 安装 (use-package neotree :ensure t :config (global-set-key [f8] &amp;#39;neotree-toggle) (setq neo-theme &amp;#39;icons) ;; 无需安装all-the-icons ) 使用 操作 快捷键 上级目录 U 将光标所在目录设为根目录 C-c C-c 显示 / 隐藏 H 上一行 / 下一行 p / n 打开文件 SPC / RET 打开 / 关闭 目录 TAB 刷新目录 g 最大化 / 最小化 窗口 A 删除文件 C-c C-d 三、 treemacs # 安装 (use-package treemacs :ensure t :defer t :init (with-eval-after-load &amp;#39;winum (define-key winum-keymap (kbd &amp;#34;M-0&amp;#34;) #&amp;#39;treemacs-select-window)) :config (progn ;;	(setq treemacs-show-cursor -1) (treemacs-resize-icons 15) (with-eval-after-load &amp;#39;treemacs (define-key treemacs-mode-map [mouse-1] #&amp;#39;treemacs-single-click-expand-action)) ;; 单击打开文件 ) :bind (:map global-map (&amp;#34;M-0&amp;#34; .</description>
    </item>
    
    <item>
      <title>实现游戏角色视角旋转</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.6%E5%AE%9E%E7%8E%B0Character%E8%A7%86%E8%A7%92%E6%97%8B%E8%BD%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.6%E5%AE%9E%E7%8E%B0Character%E8%A7%86%E8%A7%92%E6%97%8B%E8%BD%AC/</guid>
      <description>Part 1 绑定键位 # 虚幻编辑器 项目设置 &amp;gt; Engine &amp;gt; Input 轴映射 1. 抬头，低头 # 鼠标垂直方向的移动决定抬头角度，绕Y轴旋转 函数描述 键位 LookUp MouseY 2. 环顾四周 # 鼠标水平方向的移动决定身体旋转角度，绕Z轴旋转 函数描述 键位 TurnAround MouseX Part 2 实现视角旋转逻辑1 # C++ 一、搭建框架 # 添加空函数并绑定函数描述和回调函数，之后再实现函数逻辑 添加空函数 函数成员 函数体为空 private void LookUp(float Amount); void TurnAround(float Amount); 绑定函数描述和回调函数 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::InitCameraRotate(UInputComponent* PlayerInputComponent) { PlayerInputComponent-&amp;gt;BindAxis(&amp;#34;LookUp&amp;#34;, this, &amp;amp;ASTBaseCharacter::LookUp); PlayerInputComponent-&amp;gt;BindAxis(&amp;#34;TurnAround&amp;#34;, this, &amp;amp;ASTBaseCharacter::TurnAround); } 二、添加静态日志类型 # DEFINE_LOG_CATEGORY_STATIC(LogBaseCharacter, All, All) 三、实现回调函数 # void ASTBaseCharacter::LookUp(float Amount) { AddControllerPitchInput(Amount); UE_LOG(LogBaseCharacter, Log, TEXT(&amp;#34;LookUp Amount: %f&amp;#34;), Amount); } void ASTBaseCharacter::TurnAround(float Amount) { AddControllerYawInput(Amount); } Part 3 配置 Camera 组件在垂直方向上移动 # 虚幻编辑器 水平移动鼠标时，游戏角色和摄像机一齐左右旋转 垂直移动鼠标时，游戏角色无旋转 一、使 Camera 组件跟随 Pawn 旋转 # BP_STBaseCharacter 选中Camera组件 &amp;gt; 细节面板 &amp;gt; CameraOptions &amp;gt; 使能UsePawnControlRotation 保存并编译 此时向下移动鼠标时，摄像机向上旋转，向上移动鼠标时，摄像机向下旋转 查看日志，鼠标向上移动时，Amount的确是正数 二、调试 InputPitchScale # BP_PlayerController 参考 引擎版本 5.</description>
    </item>
    
    <item>
      <title>添加观察视角</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.6%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%A7%86%E8%A7%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.6%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%A7%86%E8%A7%92/</guid>
      <description> Overview # 观察视角的实现，对应一个APawn派生类，ASpectatorPawn。关卡的默认类型里，观察者类即使用ASpectatorPawn。 场景中的SpectatorPawn，即漂浮的摄像机，可以前后左右上下移动，键位控制，可以旋转，由鼠标控制。 观察视角的存在，使得玩家死亡后，仍能继续观看游戏。当Character死亡并销毁，Controller无其他Pawn可控制。当Character死亡后，使Controller切换到ASpectatorPawn对象。 本小节使用默认的观察者类，所做的修改在STBaseCharacter中。 Part 1 Character死亡后，切换到观察视角 # C++ STBaseCharacter 添加头文件 先前我们已设置STBaseCharacter使用STPlayerController类。 APawn::Controller成员和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STPlayerController的 #include &amp;#34;GameFramework/Controller.h&amp;#34; Character死亡时，使用观察视角 private 在Character死亡处理函数OnDeath中调用 void ASTBaseCharacter::SwitchToSpectatorPawn() { if (Controller) { Controller-&amp;gt;ChangeState(NAME_Spectating); } } Part 2 查看 # 虚幻编辑器 查看WorldSetting中，GameMode使用的Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 Character死亡后，世界大纲新增SpectatorPawn1 因为Character死亡的处理函数中，立即切换到SpectatorPawn，在Character销毁之前，无法继续操作Character，也就无法旋转Character的Camera </description>
    </item>
    
    <item>
      <title>为游戏角色添加向前跑步动画</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.7%E6%B7%BB%E5%8A%A0%E5%90%91%E5%89%8D%E8%B7%91%E6%AD%A5%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.7%E6%B7%BB%E5%8A%A0%E5%90%91%E5%89%8D%E8%B7%91%E6%AD%A5%E5%8A%A8%E7%94%BB/</guid>
      <description>虚幻编辑器 Overview # 动画随着 Character 运动速度变化。 brush 最简单的可编辑几何体，我们可以修改其顶点位置，调整其他参数，然后将其转换成静态网格体 CharacterMovementComponent 负责 Character 运动，其各种属性均和 Character 运动有关 一、重新设置平台 # 从场景中移除Floor 添加 Geometry/Box 恢复默认位置，设置 brush 长宽高 二、Character运动速度上限 # BP_STBaseCharacter CharacterMovementComponent 选择CharacterMovement组件 &amp;gt; 细节面板 &amp;gt; Character Movement: Walking &amp;gt; MaxWalkSpeed MaxWalkSpeed 即 Character 的最大运动速度，单位 cm/s 虚幻引擎里的步长使用 cm 修改 MaxWalkSpeed ，当速度改为 1600 时，可以看到单位时间内移动的距离增加，而跑步动画没有对应的加速过程 三、打印实时速度 # BP_STBaseCharacter EventGraph 获得Character速度 GetVelocity函数 获得Actor各个方向上的速度，保存在FVector中 获得速度标量 FVector::VectorLength 在屏幕上输出实时速度 PrintString 使用 AddOnScreenDebugMessage 移除打印 四、创建动画蓝图 # Animation Blueprint 动画蓝图和 Skeleton Mesh 有关 创建文件夹 Content/Players/Animations 动画蓝图命名：ABP_打头 方法一：基于 Skeleton Mesh 创建动画蓝图 # 选中ExternalContent/Characters/HeroTPP/HeroTPP &amp;gt; 右键 &amp;gt; Create &amp;gt; AnimBlueprint 方法二：在指定位置创建动画蓝图 # 去到 Content/Player/Animations ，右键 &amp;gt; Animation &amp;gt; 选择Animation Blueprint 选择 HeroTPP_Skeleton ，命名为 ABP_BaseCharacter 五、在蓝图编辑器中查看动画蓝图 # ABP_BaseCharacter 1.</description>
    </item>
    
    <item>
      <title>自动治疗</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.7%E8%87%AA%E5%8A%A8%E6%B2%BB%E7%96%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.7%E8%87%AA%E5%8A%A8%E6%B2%BB%E7%96%97/</guid>
      <description>Overview # 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现。获取定时器管理对象有两种方式 UActorComponent::GetOwner &amp;gt; AActor::GetWorldTimerManager UActorComponent::GetWorld &amp;gt; UWorld::GetTimerManager 修改HealthComponent逻辑 C++ 一、封装更新生命值逻辑 # 之前在处理函数OnTakeAnyDamage中，更新生命值并广播。现在会有两个地方改变生命值，新增自动治疗，所以封装改变生命值逻辑。 受到伤害和自动治疗均会修改生命值，随之通知客户端(STBaseCharacter)修改HealthText。 函数成员 private 在OnTakeAnyDamage计算伤害时，改为调用SetHealth void USTHealthComponent::SetHealth(float NewHealth) { Health = FMath::Clamp(NewHealth, 0.0f, MaxHealth); OnHealthChanged.Broadcast(); } 二、添加治疗参数 # 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier UPROPERTY(EditDefaultsOnly, Category = &amp;#34;Auto Heal&amp;#34;) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, Category = &amp;#34;Auto Heal&amp;#34;, meta = (EditCondition = &amp;#34;AutoHeal&amp;#34;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, Category = &amp;#34;Auto Heal&amp;#34;, meta = (EditCondition = &amp;#34;AutoHeal&amp;#34;)) float HealDelay = 3.</description>
    </item>
    
    <item>
      <title>实现游戏角色跳跃</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.8%E5%AE%9E%E7%8E%B0Character%E8%B7%B3%E8%B7%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.8%E5%AE%9E%E7%8E%B0Character%E8%B7%B3%E8%B7%83/</guid>
      <description> Part 1 绑定键位 # 虚幻编辑器 项目设置 &amp;gt; Engine &amp;gt; Input 动作映射 函数描述 键位 Jump SpaceBar Part 2 实现跳跃逻辑 # C++ 使用虚幻引擎提供的跳跃回调函数 绑定函数描述和回调函数 # 函数成员 private 在SetupPlayerInputComponent中调用 void ASTBaseCharacter::InitJump(UInputComponent* PlayerInputComponent) { PlayerInputComponent-&amp;gt;BindAction(&amp;#34;Jump&amp;#34;, IE_Pressed, this, &amp;amp;ASTBaseCharacter::Jump); } Part 3 添加跳跃动画 # 虚幻编辑器 ABP_BaseCharacter 跳跃动画资产 JumpStart JumpLoop JumpEnd 跳跃动画切换条件 使用 ACharacter::IsFalling 来设置变量 IsFalling ；true则Character在空中，false则说明Character在地面上。 上一小节中，变量 Velocity 横跨 ABP_BaseCharacter 的 EventGraph 和 AnimGraph ，这里，布尔类型变量 IsFalling 也一样 在 EventGraph 设置变量值，在 AnimGraph 中使用变量 使用状态机 在一个动画蓝图中管理多个动画，并定义动画之间的转换条件 一、设置布尔型变量 IsFalling # EventGraph ACharacter::IsFalling 需要 Pawn 到 Character 的转换 不能同时从 EventBlueprintUpdateAnimation 出发， SetVelocity 之后，执行转换 输入是 Character 的 MovementComponent ，从 AsCharacter 到 Target ，自动添加提取数据成员， IsFalling 函数的返回类型是布尔，作为 SetIsFalling 的输入 完整 EventGraph 二、实现 状态机 # AnimGraph 添加 状态机 ，命名为 Locomotion ，作为 OutputPose 的输入 StateMechine 双击 Locomotion ，进入 状态机 仅一个入口 Entry 为 Entry 添加 State ，命名为 Walk 双击 Walk 为 Walk 设置输入动画 BS_Locomotion 即之前 AnimGraph 中， OutputPose 的输入 到此， Character 的运动动画和上一小节一致 直接从 AssetBrowser 把 Jump 的三个动画拖入 Locomotion 动画自动被封装为 State ，和之前 AddState ，再将动画作为输入达到的效果一样 添加状态转换路径 添加转换条件 双击转换图标 Walk &amp;gt; JumpStart IsFalling 为 true JumpStart &amp;gt; JumpLoop JumpStart 将近结束 JumpStart 只播放一次 JumpLoop &amp;gt; JumpEnd IsFalling 为 false JumpLoop 循环播放 JumpEnd &amp;gt; Walk JumpEnd 将近结束 JumpEnd 只播放一次 三、设置 State 输入动画 # 拿 JumpStart 状态举例 选中JumpStart动画 &amp;gt; Details &amp;gt; Settings &amp;gt; LoopAnimation 默认循环播放动画 设置 JumpStart JumpEnd JumpLoop 的 LoopAnimation 设计 Jump 动画时， JumpStart 和 JumpEnd 只播放一次， JumpLoop 可循环。 如此设置还可修复Character跳跃时的卡顿 四、添加楼梯，查看 Jump 三阶段是否正常显示 # 添加楼梯 PlaceActors &amp;gt; Geometry &amp;gt; LinearStair 设置阶数 选中LinearStairBrush &amp;gt; Details &amp;gt; BrushSettings &amp;gt; NumSteps Character 从楼梯跳到平面时，一直保持 JumpLoop 五、跑步时跳跃，落地平滑 # 可以减少 JumpEnd &amp;gt; Walk 的 TimeRemaining 来缩短平滑 六、跳跃高度 # BP_STBaseCharacter JumpZVelocity 和 JumpStart 的时长有关 JumpLoop 动画更适合从临界点落下 </description>
    </item>
    
    <item>
      <title>高处坠落伤害</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.8%E9%AB%98%E5%A4%84%E5%9D%A0%E8%90%BD%E4%BC%A4%E5%AE%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.8%E9%AB%98%E5%A4%84%E5%9D%A0%E8%90%BD%E4%BC%A4%E5%AE%B3/</guid>
      <description>Overview # STBaseCharacter逻辑 C++ 落地时获取Z方向的速度，其和坠落高度相关，速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落伤害范围 LandedDamageRange [c, d] 落地时速度范围 LandedDamageVelocityRange [a, b] 速度小于a无伤； 在[a, b]范围内，对应伤害[c, d] c + (Velocity - a) (d - c) / (b - a) 速度大于b，伤害为d 在Character中获取速度的方式有两种： APawn::GetVelocity ACharacter:: GetCharacterMovement &amp;gt; UCharacterMovementComponent::Velocity 一、添加属性 # 原型可设置 参数 名称 LandedDamageRange 伤害范围 LandedDamageVelocityRange 落地受伤的速度范围 UPROPERTY(EditDefaultsOnly) FVector2D LandedDamageVelocityRange = {900.0f, 1200.0f}; UPROPERTY(EditDefaultsOnly)	FVector2D LandedDamageRange = {10.0f, 100.0f}; 二、订阅委托 # 委托处理函数 函数成员 private 委托支持蓝图 声明 UFUNCTION() void OnGroundLanded(const FHitResult&amp;amp; Hit); OnLanded已被使用 实现 坠落伤害属于环境伤害，无伤害源(Actor)和阵营(Controller) void ASTBaseCharacter::OnGroundLanded(const FHitResult&amp;amp; Hit) { float Velocity = -GetVelocity().</description>
    </item>
    
    <item>
      <title>实现游戏角色跑步</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.9%E5%AE%9E%E7%8E%B0Character%E8%B7%91%E6%AD%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.9%E5%AE%9E%E7%8E%B0Character%E8%B7%91%E6%AD%A5/</guid>
      <description>Part 1 绑定键位 # 虚幻编辑器 项目设置 &amp;gt; Engine &amp;gt; Input 动作映射 函数描述 键位 Run LeftShift 虽然是跑步键位，但是限制方向为向前 要求同时按下 W 或 Up 要求速度不为0 前方有障碍物时，不应该由走路转换成跑步动画 动作映射的回调函数参数列表为空 判断是否为前进方向时，还可根据速度矢量和朝向的夹角 Part 2 实现跑步逻辑 # C++ 一、判断跑步键位是否按下，方向是否为前进 # 数据成员 private bool IsForward = false; bool AbleRun = false; 二、实现键位按下逻辑，绑定函数描述和回调函数 # 函数成员 private 在SetupPlayerInputComponent中调用InitRun void ASTBaseCharacter::RunEnable() { AbleRun = true; } void ASTBaseCharacter::RunDisable() { AbleRun = false; } void ASTBaseCharacter::InitRun(UInputComponent* PlayerInputComponent) { PlayerInputComponent-&amp;gt;BindAction(&amp;#34;Run&amp;#34;, IE_Pressed, this, &amp;amp;ASTBaseCharacter::RunEnable); PlayerInputComponent-&amp;gt;BindAction(&amp;#34;Run&amp;#34;, IE_Released, this, &amp;amp;ASTBaseCharacter::RunDisable);	} 三、判断方向是否为前进 # 函数成员 private 在MoveForward中调用 void ASTBaseCharacter::SetIsForward(float Amount) { IsForward = Amount &amp;gt; 0.</description>
    </item>
    
    <item>
      <title>打包游戏和收尾</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.9%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F%E5%92%8C%E6%94%B6%E5%B0%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.9%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F%E5%92%8C%E6%94%B6%E5%B0%BE/</guid>
      <description> 一、打包游戏 # Shipping看不到Debug球 二、优化 # 定义委托类型之后，使用分号 定义委托类型时，类型名以F打头，以Signature结尾 建议 类定义顺序 public 构造函数 &amp;gt; 委托类型变量 &amp;gt; UFUNCTION &amp;gt; 其他函数 添加LifeSpanOnDeath属性 蓝图可设置 在SetupPlayerInputComponent中检查PlayInputComponent </description>
    </item>
    
    <item>
      <title>代码重构</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.a%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/2.a%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/</guid>
      <description>Part 1 新增 Components/STHealthComponent # C++ STHEalthComponent 当前生命值和最大生命值 数据成员 Health MaxHealth 提供 public 接口，可以获取当前生命值 函数成员 GetHealth 提供 public 接口，判断角色是否死亡 函数成员 IsDead 定义委托类型并添加数据成员，生命值改变时通知 FOnHealthChangedSignature 定义委托类型并添加数据成员，生命值为0时通知 FOnDeathSignature 提供 private 接口，更新生命值并通知 SetHealth 添加定时器，受到伤害后延后治疗 数据成员 参数 名称 使能自动治疗 AutoHeal 治疗量 HealModifier 治疗频率 HealRate 延后治疗时长 HealDelay 函数成员 函数 名称 回调函数 OnHealTrigger 开启定时器 StartHealTimer 关闭定时器 StopHealTimer 注册受伤处理函数，更新生命值，死亡时广播 函数成员 OnTakeAnyDamage Part 2 为Character添加HealthComponent和TextRender组件 # C++ STBaseCharacter 添加组件并初始化 添加函数，修改HealthText组件文本；初始化和生命值改变时调用 注册HealthComponent的OnHealthChanged 添加数据成员，蓝图可设置死亡动画剪辑 添加数据成员，蓝图可设置角色死亡销毁延时 注册HealthComponent的OnDeath 角色死亡时，播放死亡动画剪辑，禁止控制游戏角色，定时销毁，并切换到观察者视角 添加数据成员，坠落伤害范围和受到伤害时落地速度范围 添加函数成员，坠落时委托处理函数，并注册委托服务 Part 3 新增 Dev/STDevDamageActor # C++ STDevDamageActor 添加SceneComponent，使能变换 添加数据成员，设置球体颜色和半径 绘制球体，显示爆炸伤害范围 添加数据成员，设置伤害数值特征和计算伤害选项 对伤害半径内的角色造成伤害 Part 4 相关设置 # 虚幻编辑器 调整TextRender组件 创建死亡动画剪辑 AM_Death，并设置AM_Death播放完结束 在动画蓝图中，通过Slot，连接状态机动画和OutputPose ABP_BaseCharacter &amp;gt; AnimGraph 设置DeathAnimMontage属性 AM_Death BP_STBaseCharacter 在场景中添加伤害源 Part 5 项目结构更新 # 资产 Content/ ExternalContent/ Levels/ DefaultMap Player/ Animations/ ABP_BaseCharacter BS_Run BS_Walk AM_Death BP_STBaseCharacter [-] BP_STPlayerController BP_STGameModeBase C++ ShootTrainingSecond/ ShootTrainingSecondGameModeBase Public/ Components/ STCharacterMovementComponent STHealthComponent Player/ STBaseCharacter [-] STPlayerController Dev/ STDevDamageActor Part 6 阶段性总结 # 一、游戏角色 # C++ Player/STBaseCharacter Blueprint Player/BP_STBaseCharacter Player/Animations/ABP_BaseCharacter 其他 Player/Animations Blueprint BS_Run BS_Walk AM_Death 1.</description>
    </item>
    
    <item>
      <title>添加走路时转向动画</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.a%E6%B7%BB%E5%8A%A0%E8%BD%AC%E5%90%91%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.a%E6%B7%BB%E5%8A%A0%E8%BD%AC%E5%90%91%E5%8A%A8%E7%94%BB/</guid>
      <description>Overview # 当前实现了3种动作，走路，跑步和跳跃 走路这块，从静止到跑起来支持加速，使用 BS_Locomotion 本小节会重新实现走路动画，根据速度方向，加载转向和后退动画 之后还有 装弹 Reloading 、死亡 Death 、瞄准 Aiming 动画 Blend Space 2D混合空间 拥有两个轴： Vertial Axis Horizontal Axis Part 1 建模 # 一、 ForwardVector 和 RightVector # Actor 有 ForwardVector 和 RightVector ， Character 前后左右移动有使用到这两个方向向量 若我们水平移动鼠标， ForwardVector 和 RightVector 随之发生改变 在视觉上， ForwardVector 一直向前， RightVector 一直向右，二者在水平面垂直 二、数学基础 # 1. 点乘 # 计算向量夹角 其中一个向量为 0向量 时，点乘结果为 0 ，而反余弦计算得到其夹角为 PI/2 2. 叉乘 # 用来将向量夹角从[0, PI]扩充到[-PI, PI] c.z 向量c的z坐标 其符号说明向量c的方向 theta 为 0 PI 和 -PI 时，叉乘结果为 0 无法通过向量确定平面，也就无法得到平面法向量 三、 VelocityVector # Actor 的速度是一个矢量，其表现是单位时间内的位移方向 当速度不为 0 ， VelocityVector 和 ForwardVector 的夹角与此时 Actor 应该展现的动画有关 四、计算夹角 # 坐标 ( Velocity , Angle ) VelocityVector 和 ForwardVector 夹角的计算通过反余弦结果和 sign(c.</description>
    </item>
    
    <item>
      <title>打包游戏</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.b%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.b%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F/</guid>
      <description>Overview # 打包游戏，从二进制文件运行 定期打包游戏，确保所做改动能正常运行 一、设置游戏首页 # 项目设置 &amp;gt; Project &amp;gt; Maps &amp;amp; Modes 设置 GameDefaultMap 二、设置编译选项 # 项目设置 &amp;gt; Packaging &amp;gt; Project &amp;gt; Build Configuration 选择 发行 Shipping 三、设置玩家出发点 # 参考 LevelEditor &amp;gt; PlaceActors &amp;gt; Basic &amp;gt; PlayerStart，添加到关卡中 四、编译游戏 # 参考 可在日志窗口查看过程 创建文件夹 Projects/5.1.1/ShootTraining/Build 设置二进制文件保存路径 工具栏 &amp;gt; Platforms &amp;gt; Mac &amp;gt; Package Project，选择 Build 文件夹 1. metal-ar 报错 # 当前项目路径不包含空格，但包含汉字 打包项目 菜单栏 &amp;gt; File &amp;gt; Zip Project 移动到不含空格的英文路径 2. 打包成功 # 生成 Build/Mac/ShootTraining-Shipping.</description>
    </item>
    
    <item>
      <title>代码重构</title>
      <link>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.c%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/1.c%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/</guid>
      <description>一、在5.2.0中编译ShooterGame # 不搞这个 二、项目结构 # 资产 Content/ ExternalContent/ Levels/ DefaultMap Player/ Animations/ ABP_BaseCharacter BS_Run BS_Walk BP_STBaseCharacter BP_STPlayerController BP_STGameModeBase C++ ShootTrainingSecond/ ShootTrainingSecondGameModeBase Public/ Components/ STCharacterMovementComponent Player/ STBaseCharacter STPlayerController 三、基础设置 # 载入 ExternalContent 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 四、任务 # 1. 三个蓝图类 # 虚幻编辑器 BP_STBaseCharacter BP_STPlayerController BP_STGameModeBase 使用 BP_STGameModeBase BP_STGameModeBase 使用 BP_STBaseCharacter 和 BP_STPlayerController 2. 添加组件 # C++ STBaseCharacter CameraComponent SpringArmComponent 3. 为Character绑定模型 # 虚幻编辑器 BP_STBaseCharacter 4. 绑定键位并给出函数描述 # 虚幻编辑器 项目设置 移动 轴映射 MoveRight APawn::AddMovementInput AActor::GetActorRightVector MoveForward APawn::AddMovementInput AActor::GetActorForwardVector 视角旋转 轴映射 TurnAround APawn::AddControllerYawInput Camera 组件和 Character 一齐旋转 LookUp APawn::AddControllerPitchInput 需使能 SpringArmComponent::bUsePawnControlRotation 默认 PlayerController::InputPitchScale 是负数，所以 Scale 为 -1 CameraComponent 以 CameraComponent 为中心旋转， SpringArmComponent 以 Pawn 为中心旋转 动作 动作映射 Jump ACharacter::Jump Run 按下键位 速度不为0 Velocity和Forward夹角为0 可配置加速系数 通过覆写 CharacterMovementComponent::GetMaxSpeed 实现加速 5.</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://toughcactus.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://toughcactus.github.io/about/</guid>
      <description> Enjoy hobby, happy career. # 技能树 # Emacs C++ 计算机图形学 Shell脚本 Hobby # </description>
    </item>
    
  </channel>
</rss>
